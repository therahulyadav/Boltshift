
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model SubAccount
 * 
 */
export type SubAccount = $Result.DefaultSelection<Prisma.$SubAccountPayload>
/**
 * Model Permissions
 * 
 */
export type Permissions = $Result.DefaultSelection<Prisma.$PermissionsPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Pipeline
 * 
 */
export type Pipeline = $Result.DefaultSelection<Prisma.$PipelinePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Lane
 * 
 */
export type Lane = $Result.DefaultSelection<Prisma.$LanePayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model Trigger
 * 
 */
export type Trigger = $Result.DefaultSelection<Prisma.$TriggerPayload>
/**
 * Model Automation
 * 
 */
export type Automation = $Result.DefaultSelection<Prisma.$AutomationPayload>
/**
 * Model AutomationInstance
 * 
 */
export type AutomationInstance = $Result.DefaultSelection<Prisma.$AutomationInstancePayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Funnel
 * 
 */
export type Funnel = $Result.DefaultSelection<Prisma.$FunnelPayload>
/**
 * Model ClassName
 * 
 */
export type ClassName = $Result.DefaultSelection<Prisma.$ClassNamePayload>
/**
 * Model FunnelPage
 * 
 */
export type FunnelPage = $Result.DefaultSelection<Prisma.$FunnelPagePayload>
/**
 * Model AgencySidebarOption
 * 
 */
export type AgencySidebarOption = $Result.DefaultSelection<Prisma.$AgencySidebarOptionPayload>
/**
 * Model SubAccountSidebarOption
 * 
 */
export type SubAccountSidebarOption = $Result.DefaultSelection<Prisma.$SubAccountSidebarOptionPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model AddOns
 * 
 */
export type AddOns = $Result.DefaultSelection<Prisma.$AddOnsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  AGENCY_OWNER: 'AGENCY_OWNER',
  AGENCY_ADMIN: 'AGENCY_ADMIN',
  SUBACCOUNT_USER: 'SUBACCOUNT_USER',
  SUBACCOUNT_GUEST: 'SUBACCOUNT_GUEST'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TriggerTypes: {
  CONTACT_FORM: 'CONTACT_FORM'
};

export type TriggerTypes = (typeof TriggerTypes)[keyof typeof TriggerTypes]


export const ActionType: {
  CREATE_CONTACT: 'CREATE_CONTACT'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]


export const InvitationStatus: {
  ACCEPTED: 'ACCEPTED',
  REVOKED: 'REVOKED',
  PENDING: 'PENDING'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const Plan: {
  price_1OpACCFdfEv15JJwACWCyqW2: 'price_1OpACCFdfEv15JJwACWCyqW2',
  price_1OpACCFdfEv15JJw0k6lm8HC: 'price_1OpACCFdfEv15JJw0k6lm8HC'
};

export type Plan = (typeof Plan)[keyof typeof Plan]


export const Icon: {
  settings: 'settings',
  chart: 'chart',
  calendar: 'calendar',
  check: 'check',
  chip: 'chip',
  compass: 'compass',
  database: 'database',
  flag: 'flag',
  home: 'home',
  info: 'info',
  link: 'link',
  lock: 'lock',
  messages: 'messages',
  notification: 'notification',
  payment: 'payment',
  power: 'power',
  receipt: 'receipt',
  shield: 'shield',
  star: 'star',
  tune: 'tune',
  videorecorder: 'videorecorder',
  wallet: 'wallet',
  warning: 'warning',
  headphone: 'headphone',
  send: 'send',
  pipelines: 'pipelines',
  person: 'person',
  category: 'category',
  contact: 'contact',
  clipboardIcon: 'clipboardIcon'
};

export type Icon = (typeof Icon)[keyof typeof Icon]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TriggerTypes = $Enums.TriggerTypes

export const TriggerTypes: typeof $Enums.TriggerTypes

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type Plan = $Enums.Plan

export const Plan: typeof $Enums.Plan

export type Icon = $Enums.Icon

export const Icon: typeof $Enums.Icon

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subAccount`: Exposes CRUD operations for the **SubAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAccounts
    * const subAccounts = await prisma.subAccount.findMany()
    * ```
    */
  get subAccount(): Prisma.SubAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **Permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.PermissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pipeline`: Exposes CRUD operations for the **Pipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipeline.findMany()
    * ```
    */
  get pipeline(): Prisma.PipelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lane`: Exposes CRUD operations for the **Lane** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lanes
    * const lanes = await prisma.lane.findMany()
    * ```
    */
  get lane(): Prisma.LaneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trigger`: Exposes CRUD operations for the **Trigger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Triggers
    * const triggers = await prisma.trigger.findMany()
    * ```
    */
  get trigger(): Prisma.TriggerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automation`: Exposes CRUD operations for the **Automation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automations
    * const automations = await prisma.automation.findMany()
    * ```
    */
  get automation(): Prisma.AutomationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationInstance`: Exposes CRUD operations for the **AutomationInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationInstances
    * const automationInstances = await prisma.automationInstance.findMany()
    * ```
    */
  get automationInstance(): Prisma.AutomationInstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.funnel`: Exposes CRUD operations for the **Funnel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funnels
    * const funnels = await prisma.funnel.findMany()
    * ```
    */
  get funnel(): Prisma.FunnelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.className`: Exposes CRUD operations for the **ClassName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassNames
    * const classNames = await prisma.className.findMany()
    * ```
    */
  get className(): Prisma.ClassNameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.funnelPage`: Exposes CRUD operations for the **FunnelPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FunnelPages
    * const funnelPages = await prisma.funnelPage.findMany()
    * ```
    */
  get funnelPage(): Prisma.FunnelPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencySidebarOption`: Exposes CRUD operations for the **AgencySidebarOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencySidebarOptions
    * const agencySidebarOptions = await prisma.agencySidebarOption.findMany()
    * ```
    */
  get agencySidebarOption(): Prisma.AgencySidebarOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subAccountSidebarOption`: Exposes CRUD operations for the **SubAccountSidebarOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAccountSidebarOptions
    * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany()
    * ```
    */
  get subAccountSidebarOption(): Prisma.SubAccountSidebarOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addOns`: Exposes CRUD operations for the **AddOns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddOns
    * const addOns = await prisma.addOns.findMany()
    * ```
    */
  get addOns(): Prisma.AddOnsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Agency: 'Agency',
    SubAccount: 'SubAccount',
    Permissions: 'Permissions',
    Tag: 'Tag',
    Pipeline: 'Pipeline',
    Notification: 'Notification',
    Lane: 'Lane',
    Ticket: 'Ticket',
    Trigger: 'Trigger',
    Automation: 'Automation',
    AutomationInstance: 'AutomationInstance',
    Action: 'Action',
    Contact: 'Contact',
    Media: 'Media',
    Funnel: 'Funnel',
    ClassName: 'ClassName',
    FunnelPage: 'FunnelPage',
    AgencySidebarOption: 'AgencySidebarOption',
    SubAccountSidebarOption: 'SubAccountSidebarOption',
    Invitation: 'Invitation',
    Subscription: 'Subscription',
    AddOns: 'AddOns'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "agency" | "subAccount" | "permissions" | "tag" | "pipeline" | "notification" | "lane" | "ticket" | "trigger" | "automation" | "automationInstance" | "action" | "contact" | "media" | "funnel" | "className" | "funnelPage" | "agencySidebarOption" | "subAccountSidebarOption" | "invitation" | "subscription" | "addOns"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      SubAccount: {
        payload: Prisma.$SubAccountPayload<ExtArgs>
        fields: Prisma.SubAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          findFirst: {
            args: Prisma.SubAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          findMany: {
            args: Prisma.SubAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          create: {
            args: Prisma.SubAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          createMany: {
            args: Prisma.SubAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          delete: {
            args: Prisma.SubAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          update: {
            args: Prisma.SubAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          deleteMany: {
            args: Prisma.SubAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          upsert: {
            args: Prisma.SubAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          aggregate: {
            args: Prisma.SubAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubAccount>
          }
          groupBy: {
            args: Prisma.SubAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SubAccountCountAggregateOutputType> | number
          }
        }
      }
      Permissions: {
        payload: Prisma.$PermissionsPayload<ExtArgs>
        fields: Prisma.PermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findFirst: {
            args: Prisma.PermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findMany: {
            args: Prisma.PermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          create: {
            args: Prisma.PermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          createMany: {
            args: Prisma.PermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          delete: {
            args: Prisma.PermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          update: {
            args: Prisma.PermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          deleteMany: {
            args: Prisma.PermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          upsert: {
            args: Prisma.PermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.PermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Pipeline: {
        payload: Prisma.$PipelinePayload<ExtArgs>
        fields: Prisma.PipelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findFirst: {
            args: Prisma.PipelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findMany: {
            args: Prisma.PipelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          create: {
            args: Prisma.PipelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          createMany: {
            args: Prisma.PipelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          delete: {
            args: Prisma.PipelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          update: {
            args: Prisma.PipelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          deleteMany: {
            args: Prisma.PipelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PipelineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          upsert: {
            args: Prisma.PipelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          aggregate: {
            args: Prisma.PipelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipeline>
          }
          groupBy: {
            args: Prisma.PipelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Lane: {
        payload: Prisma.$LanePayload<ExtArgs>
        fields: Prisma.LaneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          findFirst: {
            args: Prisma.LaneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          findMany: {
            args: Prisma.LaneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          create: {
            args: Prisma.LaneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          createMany: {
            args: Prisma.LaneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          delete: {
            args: Prisma.LaneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          update: {
            args: Prisma.LaneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          deleteMany: {
            args: Prisma.LaneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          upsert: {
            args: Prisma.LaneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          aggregate: {
            args: Prisma.LaneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLane>
          }
          groupBy: {
            args: Prisma.LaneGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaneGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaneCountArgs<ExtArgs>
            result: $Utils.Optional<LaneCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      Trigger: {
        payload: Prisma.$TriggerPayload<ExtArgs>
        fields: Prisma.TriggerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TriggerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TriggerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          findFirst: {
            args: Prisma.TriggerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TriggerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          findMany: {
            args: Prisma.TriggerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>[]
          }
          create: {
            args: Prisma.TriggerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          createMany: {
            args: Prisma.TriggerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TriggerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>[]
          }
          delete: {
            args: Prisma.TriggerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          update: {
            args: Prisma.TriggerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          deleteMany: {
            args: Prisma.TriggerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TriggerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TriggerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>[]
          }
          upsert: {
            args: Prisma.TriggerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          aggregate: {
            args: Prisma.TriggerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrigger>
          }
          groupBy: {
            args: Prisma.TriggerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TriggerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TriggerCountArgs<ExtArgs>
            result: $Utils.Optional<TriggerCountAggregateOutputType> | number
          }
        }
      }
      Automation: {
        payload: Prisma.$AutomationPayload<ExtArgs>
        fields: Prisma.AutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findFirst: {
            args: Prisma.AutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findMany: {
            args: Prisma.AutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          create: {
            args: Prisma.AutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          createMany: {
            args: Prisma.AutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          delete: {
            args: Prisma.AutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          update: {
            args: Prisma.AutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          deleteMany: {
            args: Prisma.AutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          upsert: {
            args: Prisma.AutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          aggregate: {
            args: Prisma.AutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomation>
          }
          groupBy: {
            args: Prisma.AutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationCountAggregateOutputType> | number
          }
        }
      }
      AutomationInstance: {
        payload: Prisma.$AutomationInstancePayload<ExtArgs>
        fields: Prisma.AutomationInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          findFirst: {
            args: Prisma.AutomationInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          findMany: {
            args: Prisma.AutomationInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>[]
          }
          create: {
            args: Prisma.AutomationInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          createMany: {
            args: Prisma.AutomationInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationInstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>[]
          }
          delete: {
            args: Prisma.AutomationInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          update: {
            args: Prisma.AutomationInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          deleteMany: {
            args: Prisma.AutomationInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationInstanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>[]
          }
          upsert: {
            args: Prisma.AutomationInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          aggregate: {
            args: Prisma.AutomationInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationInstance>
          }
          groupBy: {
            args: Prisma.AutomationInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationInstanceCountAggregateOutputType> | number
          }
        }
      }
      Action: {
        payload: Prisma.$ActionPayload<ExtArgs>
        fields: Prisma.ActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findFirst: {
            args: Prisma.ActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findMany: {
            args: Prisma.ActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          create: {
            args: Prisma.ActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          createMany: {
            args: Prisma.ActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          delete: {
            args: Prisma.ActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          update: {
            args: Prisma.ActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          upsert: {
            args: Prisma.ActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          aggregate: {
            args: Prisma.ActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction>
          }
          groupBy: {
            args: Prisma.ActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Funnel: {
        payload: Prisma.$FunnelPayload<ExtArgs>
        fields: Prisma.FunnelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunnelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunnelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          findFirst: {
            args: Prisma.FunnelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunnelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          findMany: {
            args: Prisma.FunnelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>[]
          }
          create: {
            args: Prisma.FunnelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          createMany: {
            args: Prisma.FunnelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FunnelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>[]
          }
          delete: {
            args: Prisma.FunnelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          update: {
            args: Prisma.FunnelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          deleteMany: {
            args: Prisma.FunnelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunnelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FunnelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>[]
          }
          upsert: {
            args: Prisma.FunnelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          aggregate: {
            args: Prisma.FunnelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunnel>
          }
          groupBy: {
            args: Prisma.FunnelGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunnelGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunnelCountArgs<ExtArgs>
            result: $Utils.Optional<FunnelCountAggregateOutputType> | number
          }
        }
      }
      ClassName: {
        payload: Prisma.$ClassNamePayload<ExtArgs>
        fields: Prisma.ClassNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassNameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassNameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          findFirst: {
            args: Prisma.ClassNameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassNameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          findMany: {
            args: Prisma.ClassNameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>[]
          }
          create: {
            args: Prisma.ClassNameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          createMany: {
            args: Prisma.ClassNameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassNameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>[]
          }
          delete: {
            args: Prisma.ClassNameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          update: {
            args: Prisma.ClassNameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          deleteMany: {
            args: Prisma.ClassNameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassNameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassNameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>[]
          }
          upsert: {
            args: Prisma.ClassNameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          aggregate: {
            args: Prisma.ClassNameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassName>
          }
          groupBy: {
            args: Prisma.ClassNameGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassNameGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassNameCountArgs<ExtArgs>
            result: $Utils.Optional<ClassNameCountAggregateOutputType> | number
          }
        }
      }
      FunnelPage: {
        payload: Prisma.$FunnelPagePayload<ExtArgs>
        fields: Prisma.FunnelPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunnelPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunnelPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>
          }
          findFirst: {
            args: Prisma.FunnelPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunnelPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>
          }
          findMany: {
            args: Prisma.FunnelPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>[]
          }
          create: {
            args: Prisma.FunnelPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>
          }
          createMany: {
            args: Prisma.FunnelPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FunnelPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>[]
          }
          delete: {
            args: Prisma.FunnelPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>
          }
          update: {
            args: Prisma.FunnelPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>
          }
          deleteMany: {
            args: Prisma.FunnelPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunnelPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FunnelPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>[]
          }
          upsert: {
            args: Prisma.FunnelPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagePayload>
          }
          aggregate: {
            args: Prisma.FunnelPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunnelPage>
          }
          groupBy: {
            args: Prisma.FunnelPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunnelPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunnelPageCountArgs<ExtArgs>
            result: $Utils.Optional<FunnelPageCountAggregateOutputType> | number
          }
        }
      }
      AgencySidebarOption: {
        payload: Prisma.$AgencySidebarOptionPayload<ExtArgs>
        fields: Prisma.AgencySidebarOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencySidebarOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          findFirst: {
            args: Prisma.AgencySidebarOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          findMany: {
            args: Prisma.AgencySidebarOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>[]
          }
          create: {
            args: Prisma.AgencySidebarOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          createMany: {
            args: Prisma.AgencySidebarOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencySidebarOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>[]
          }
          delete: {
            args: Prisma.AgencySidebarOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          update: {
            args: Prisma.AgencySidebarOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          deleteMany: {
            args: Prisma.AgencySidebarOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencySidebarOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencySidebarOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>[]
          }
          upsert: {
            args: Prisma.AgencySidebarOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          aggregate: {
            args: Prisma.AgencySidebarOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencySidebarOption>
          }
          groupBy: {
            args: Prisma.AgencySidebarOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencySidebarOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencySidebarOptionCountArgs<ExtArgs>
            result: $Utils.Optional<AgencySidebarOptionCountAggregateOutputType> | number
          }
        }
      }
      SubAccountSidebarOption: {
        payload: Prisma.$SubAccountSidebarOptionPayload<ExtArgs>
        fields: Prisma.SubAccountSidebarOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubAccountSidebarOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          findFirst: {
            args: Prisma.SubAccountSidebarOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          findMany: {
            args: Prisma.SubAccountSidebarOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>[]
          }
          create: {
            args: Prisma.SubAccountSidebarOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          createMany: {
            args: Prisma.SubAccountSidebarOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubAccountSidebarOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>[]
          }
          delete: {
            args: Prisma.SubAccountSidebarOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          update: {
            args: Prisma.SubAccountSidebarOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          deleteMany: {
            args: Prisma.SubAccountSidebarOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubAccountSidebarOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubAccountSidebarOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>[]
          }
          upsert: {
            args: Prisma.SubAccountSidebarOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          aggregate: {
            args: Prisma.SubAccountSidebarOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubAccountSidebarOption>
          }
          groupBy: {
            args: Prisma.SubAccountSidebarOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubAccountSidebarOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubAccountSidebarOptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubAccountSidebarOptionCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      AddOns: {
        payload: Prisma.$AddOnsPayload<ExtArgs>
        fields: Prisma.AddOnsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddOnsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddOnsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          findFirst: {
            args: Prisma.AddOnsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddOnsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          findMany: {
            args: Prisma.AddOnsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>[]
          }
          create: {
            args: Prisma.AddOnsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          createMany: {
            args: Prisma.AddOnsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddOnsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>[]
          }
          delete: {
            args: Prisma.AddOnsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          update: {
            args: Prisma.AddOnsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          deleteMany: {
            args: Prisma.AddOnsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddOnsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddOnsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>[]
          }
          upsert: {
            args: Prisma.AddOnsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          aggregate: {
            args: Prisma.AddOnsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddOns>
          }
          groupBy: {
            args: Prisma.AddOnsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddOnsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddOnsCountArgs<ExtArgs>
            result: $Utils.Optional<AddOnsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    agency?: AgencyOmit
    subAccount?: SubAccountOmit
    permissions?: PermissionsOmit
    tag?: TagOmit
    pipeline?: PipelineOmit
    notification?: NotificationOmit
    lane?: LaneOmit
    ticket?: TicketOmit
    trigger?: TriggerOmit
    automation?: AutomationOmit
    automationInstance?: AutomationInstanceOmit
    action?: ActionOmit
    contact?: ContactOmit
    media?: MediaOmit
    funnel?: FunnelOmit
    className?: ClassNameOmit
    funnelPage?: FunnelPageOmit
    agencySidebarOption?: AgencySidebarOptionOmit
    subAccountSidebarOption?: SubAccountSidebarOptionOmit
    invitation?: InvitationOmit
    subscription?: SubscriptionOmit
    addOns?: AddOnsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    permissions: number
    tickets: number
    notification: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | UserCountOutputTypeCountPermissionsArgs
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    users: number
    subAccounts: number
    sidebarOptions: number
    invitations: number
    notifications: number
    addOns: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AgencyCountOutputTypeCountUsersArgs
    subAccounts?: boolean | AgencyCountOutputTypeCountSubAccountsArgs
    sidebarOptions?: boolean | AgencyCountOutputTypeCountSidebarOptionsArgs
    invitations?: boolean | AgencyCountOutputTypeCountInvitationsArgs
    notifications?: boolean | AgencyCountOutputTypeCountNotificationsArgs
    addOns?: boolean | AgencyCountOutputTypeCountAddOnsArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountSubAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountSidebarOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencySidebarOptionWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnsWhereInput
  }


  /**
   * Count Type SubAccountCountOutputType
   */

  export type SubAccountCountOutputType = {
    sidebarOptions: number
    permissions: number
    funnels: number
    media: number
    contacts: number
    triggers: number
    automations: number
    pipelines: number
    tags: number
    notifications: number
  }

  export type SubAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sidebarOptions?: boolean | SubAccountCountOutputTypeCountSidebarOptionsArgs
    permissions?: boolean | SubAccountCountOutputTypeCountPermissionsArgs
    funnels?: boolean | SubAccountCountOutputTypeCountFunnelsArgs
    media?: boolean | SubAccountCountOutputTypeCountMediaArgs
    contacts?: boolean | SubAccountCountOutputTypeCountContactsArgs
    triggers?: boolean | SubAccountCountOutputTypeCountTriggersArgs
    automations?: boolean | SubAccountCountOutputTypeCountAutomationsArgs
    pipelines?: boolean | SubAccountCountOutputTypeCountPipelinesArgs
    tags?: boolean | SubAccountCountOutputTypeCountTagsArgs
    notifications?: boolean | SubAccountCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountCountOutputType
     */
    select?: SubAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountSidebarOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountSidebarOptionWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountFunnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountTriggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    tickets: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | TagCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type PipelineCountOutputType
   */

  export type PipelineCountOutputType = {
    lanes: number
  }

  export type PipelineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lanes?: boolean | PipelineCountOutputTypeCountLanesArgs
  }

  // Custom InputTypes
  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineCountOutputType
     */
    select?: PipelineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountLanesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaneWhereInput
  }


  /**
   * Count Type LaneCountOutputType
   */

  export type LaneCountOutputType = {
    tickets: number
  }

  export type LaneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | LaneCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * LaneCountOutputType without action
   */
  export type LaneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaneCountOutputType
     */
    select?: LaneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaneCountOutputType without action
   */
  export type LaneCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    tags: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | TicketCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type TriggerCountOutputType
   */

  export type TriggerCountOutputType = {
    automations: number
  }

  export type TriggerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automations?: boolean | TriggerCountOutputTypeCountAutomationsArgs
  }

  // Custom InputTypes
  /**
   * TriggerCountOutputType without action
   */
  export type TriggerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerCountOutputType
     */
    select?: TriggerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TriggerCountOutputType without action
   */
  export type TriggerCountOutputTypeCountAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
  }


  /**
   * Count Type AutomationCountOutputType
   */

  export type AutomationCountOutputType = {
    actions: number
    automationInstances: number
  }

  export type AutomationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | AutomationCountOutputTypeCountActionsArgs
    automationInstances?: boolean | AutomationCountOutputTypeCountAutomationInstancesArgs
  }

  // Custom InputTypes
  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationCountOutputType
     */
    select?: AutomationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountAutomationInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationInstanceWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    tickets: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | ContactCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type FunnelCountOutputType
   */

  export type FunnelCountOutputType = {
    funnelPages: number
    className: number
  }

  export type FunnelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnelPages?: boolean | FunnelCountOutputTypeCountFunnelPagesArgs
    className?: boolean | FunnelCountOutputTypeCountClassNameArgs
  }

  // Custom InputTypes
  /**
   * FunnelCountOutputType without action
   */
  export type FunnelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelCountOutputType
     */
    select?: FunnelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FunnelCountOutputType without action
   */
  export type FunnelCountOutputTypeCountFunnelPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelPageWhereInput
  }

  /**
   * FunnelCountOutputType without action
   */
  export type FunnelCountOutputTypeCountClassNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    avatarUrl: string | null
    email: string | null
    role: $Enums.Role | null
    agencyId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    avatarUrl: string | null
    email: string | null
    role: $Enums.Role | null
    agencyId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    avatarUrl: number
    email: number
    role: number
    agencyId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    avatarUrl?: true
    email?: true
    role?: true
    agencyId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    avatarUrl?: true
    email?: true
    role?: true
    agencyId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    avatarUrl?: true
    email?: true
    role?: true
    agencyId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    avatarUrl: string
    email: string
    role: $Enums.Role
    agencyId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    role?: boolean
    agencyId?: boolean
    agency?: boolean | User$agencyArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    role?: boolean
    agencyId?: boolean
    agency?: boolean | User$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    role?: boolean
    agencyId?: boolean
    agency?: boolean | User$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    role?: boolean
    agencyId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "avatarUrl" | "email" | "role" | "agencyId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | User$agencyArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | User$agencyArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | User$agencyArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs> | null
      permissions: Prisma.$PermissionsPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      avatarUrl: string
      email: string
      role: $Enums.Role
      agencyId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends User$agencyArgs<ExtArgs> = {}>(args?: Subset<T, User$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    permissions<T extends User$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends User$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification<T extends User$notificationArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly agencyId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.agency
   */
  export type User$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * User.permissions
   */
  export type User$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    cursor?: PermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * User.tickets
   */
  export type User$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.notification
   */
  export type User$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyAvgAggregateOutputType = {
    goal: number | null
  }

  export type AgencySumAggregateOutputType = {
    goal: number | null
  }

  export type AgencyMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    connectAccountId: string | null
    customerId: string | null
    name: string | null
    agencyLogo: string | null
    companyEmail: string | null
    companyPhone: string | null
    whiteLabel: boolean | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    goal: number | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    connectAccountId: string | null
    customerId: string | null
    name: string | null
    agencyLogo: string | null
    companyEmail: string | null
    companyPhone: string | null
    whiteLabel: boolean | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    goal: number | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    connectAccountId: number
    customerId: number
    name: number
    agencyLogo: number
    companyEmail: number
    companyPhone: number
    whiteLabel: number
    address: number
    city: number
    zipCode: number
    state: number
    country: number
    goal: number
    _all: number
  }


  export type AgencyAvgAggregateInputType = {
    goal?: true
  }

  export type AgencySumAggregateInputType = {
    goal?: true
  }

  export type AgencyMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _avg?: AgencyAvgAggregateInputType
    _sum?: AgencySumAggregateInputType
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    connectAccountId: string | null
    customerId: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
    users?: boolean | Agency$usersArgs<ExtArgs>
    subAccounts?: boolean | Agency$subAccountsArgs<ExtArgs>
    sidebarOptions?: boolean | Agency$sidebarOptionsArgs<ExtArgs>
    invitations?: boolean | Agency$invitationsArgs<ExtArgs>
    notifications?: boolean | Agency$notificationsArgs<ExtArgs>
    subscriptions?: boolean | Agency$subscriptionsArgs<ExtArgs>
    addOns?: boolean | Agency$addOnsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
  }

  export type AgencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "connectAccountId" | "customerId" | "name" | "agencyLogo" | "companyEmail" | "companyPhone" | "whiteLabel" | "address" | "city" | "zipCode" | "state" | "country" | "goal", ExtArgs["result"]["agency"]>
  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Agency$usersArgs<ExtArgs>
    subAccounts?: boolean | Agency$subAccountsArgs<ExtArgs>
    sidebarOptions?: boolean | Agency$sidebarOptionsArgs<ExtArgs>
    invitations?: boolean | Agency$invitationsArgs<ExtArgs>
    notifications?: boolean | Agency$notificationsArgs<ExtArgs>
    subscriptions?: boolean | Agency$subscriptionsArgs<ExtArgs>
    addOns?: boolean | Agency$addOnsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      subAccounts: Prisma.$SubAccountPayload<ExtArgs>[]
      sidebarOptions: Prisma.$AgencySidebarOptionPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs> | null
      addOns: Prisma.$AddOnsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      connectAccountId: string | null
      customerId: string
      name: string
      agencyLogo: string
      companyEmail: string
      companyPhone: string
      whiteLabel: boolean
      address: string
      city: string
      zipCode: string
      state: string
      country: string
      goal: number
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyFindUniqueArgs>(args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyFindFirstArgs>(args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyFindManyArgs>(args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
     */
    create<T extends AgencyCreateArgs>(args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyCreateManyArgs>(args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agencies and returns the data saved in the database.
     * @param {AgencyCreateManyAndReturnArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
     */
    delete<T extends AgencyDeleteArgs>(args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyUpdateArgs>(args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDeleteManyArgs>(args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyUpdateManyArgs>(args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies and returns the data updated in the database.
     * @param {AgencyUpdateManyAndReturnArgs} args - Arguments to update many Agencies.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
     */
    upsert<T extends AgencyUpsertArgs>(args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Agency$usersArgs<ExtArgs> = {}>(args?: Subset<T, Agency$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subAccounts<T extends Agency$subAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$subAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sidebarOptions<T extends Agency$sidebarOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$sidebarOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Agency$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Agency$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Agency$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$subscriptionsArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    addOns<T extends Agency$addOnsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$addOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agency model
   */
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'String'>
    readonly createdAt: FieldRef<"Agency", 'DateTime'>
    readonly updatedAt: FieldRef<"Agency", 'DateTime'>
    readonly connectAccountId: FieldRef<"Agency", 'String'>
    readonly customerId: FieldRef<"Agency", 'String'>
    readonly name: FieldRef<"Agency", 'String'>
    readonly agencyLogo: FieldRef<"Agency", 'String'>
    readonly companyEmail: FieldRef<"Agency", 'String'>
    readonly companyPhone: FieldRef<"Agency", 'String'>
    readonly whiteLabel: FieldRef<"Agency", 'Boolean'>
    readonly address: FieldRef<"Agency", 'String'>
    readonly city: FieldRef<"Agency", 'String'>
    readonly zipCode: FieldRef<"Agency", 'String'>
    readonly state: FieldRef<"Agency", 'String'>
    readonly country: FieldRef<"Agency", 'String'>
    readonly goal: FieldRef<"Agency", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency createManyAndReturn
   */
  export type AgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency updateManyAndReturn
   */
  export type AgencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to delete.
     */
    limit?: number
  }

  /**
   * Agency.users
   */
  export type Agency$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Agency.subAccounts
   */
  export type Agency$subAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    cursor?: SubAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * Agency.sidebarOptions
   */
  export type Agency$sidebarOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    where?: AgencySidebarOptionWhereInput
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    cursor?: AgencySidebarOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * Agency.invitations
   */
  export type Agency$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Agency.notifications
   */
  export type Agency$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Agency.subscriptions
   */
  export type Agency$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Agency.addOns
   */
  export type Agency$addOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    where?: AddOnsWhereInput
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    cursor?: AddOnsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model SubAccount
   */

  export type AggregateSubAccount = {
    _count: SubAccountCountAggregateOutputType | null
    _avg: SubAccountAvgAggregateOutputType | null
    _sum: SubAccountSumAggregateOutputType | null
    _min: SubAccountMinAggregateOutputType | null
    _max: SubAccountMaxAggregateOutputType | null
  }

  export type SubAccountAvgAggregateOutputType = {
    goal: number | null
  }

  export type SubAccountSumAggregateOutputType = {
    goal: number | null
  }

  export type SubAccountMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    connectAccountId: string | null
    name: string | null
    subAccountLogo: string | null
    companyEmail: string | null
    companyPhone: string | null
    goal: number | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    agencyId: string | null
  }

  export type SubAccountMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    connectAccountId: string | null
    name: string | null
    subAccountLogo: string | null
    companyEmail: string | null
    companyPhone: string | null
    goal: number | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    agencyId: string | null
  }

  export type SubAccountCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    connectAccountId: number
    name: number
    subAccountLogo: number
    companyEmail: number
    companyPhone: number
    goal: number
    address: number
    city: number
    zipCode: number
    state: number
    country: number
    agencyId: number
    _all: number
  }


  export type SubAccountAvgAggregateInputType = {
    goal?: true
  }

  export type SubAccountSumAggregateInputType = {
    goal?: true
  }

  export type SubAccountMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    connectAccountId?: true
    name?: true
    subAccountLogo?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
  }

  export type SubAccountMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    connectAccountId?: true
    name?: true
    subAccountLogo?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
  }

  export type SubAccountCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    connectAccountId?: true
    name?: true
    subAccountLogo?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
    _all?: true
  }

  export type SubAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccount to aggregate.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAccounts
    **/
    _count?: true | SubAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubAccountMaxAggregateInputType
  }

  export type GetSubAccountAggregateType<T extends SubAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSubAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubAccount[P]>
      : GetScalarType<T[P], AggregateSubAccount[P]>
  }




  export type SubAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountWhereInput
    orderBy?: SubAccountOrderByWithAggregationInput | SubAccountOrderByWithAggregationInput[]
    by: SubAccountScalarFieldEnum[] | SubAccountScalarFieldEnum
    having?: SubAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubAccountCountAggregateInputType | true
    _avg?: SubAccountAvgAggregateInputType
    _sum?: SubAccountSumAggregateInputType
    _min?: SubAccountMinAggregateInputType
    _max?: SubAccountMaxAggregateInputType
  }

  export type SubAccountGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    connectAccountId: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    _count: SubAccountCountAggregateOutputType | null
    _avg: SubAccountAvgAggregateOutputType | null
    _sum: SubAccountSumAggregateOutputType | null
    _min: SubAccountMinAggregateOutputType | null
    _max: SubAccountMaxAggregateOutputType | null
  }

  type GetSubAccountGroupByPayload<T extends SubAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SubAccountGroupByOutputType[P]>
        }
      >
    >


  export type SubAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAccountLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    sidebarOptions?: boolean | SubAccount$sidebarOptionsArgs<ExtArgs>
    permissions?: boolean | SubAccount$permissionsArgs<ExtArgs>
    funnels?: boolean | SubAccount$funnelsArgs<ExtArgs>
    media?: boolean | SubAccount$mediaArgs<ExtArgs>
    contacts?: boolean | SubAccount$contactsArgs<ExtArgs>
    triggers?: boolean | SubAccount$triggersArgs<ExtArgs>
    automations?: boolean | SubAccount$automationsArgs<ExtArgs>
    pipelines?: boolean | SubAccount$pipelinesArgs<ExtArgs>
    tags?: boolean | SubAccount$tagsArgs<ExtArgs>
    notifications?: boolean | SubAccount$notificationsArgs<ExtArgs>
    _count?: boolean | SubAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>

  export type SubAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAccountLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>

  export type SubAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAccountLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>

  export type SubAccountSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAccountLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
  }

  export type SubAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "connectAccountId" | "name" | "subAccountLogo" | "companyEmail" | "companyPhone" | "goal" | "address" | "city" | "zipCode" | "state" | "country" | "agencyId", ExtArgs["result"]["subAccount"]>
  export type SubAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    sidebarOptions?: boolean | SubAccount$sidebarOptionsArgs<ExtArgs>
    permissions?: boolean | SubAccount$permissionsArgs<ExtArgs>
    funnels?: boolean | SubAccount$funnelsArgs<ExtArgs>
    media?: boolean | SubAccount$mediaArgs<ExtArgs>
    contacts?: boolean | SubAccount$contactsArgs<ExtArgs>
    triggers?: boolean | SubAccount$triggersArgs<ExtArgs>
    automations?: boolean | SubAccount$automationsArgs<ExtArgs>
    pipelines?: boolean | SubAccount$pipelinesArgs<ExtArgs>
    tags?: boolean | SubAccount$tagsArgs<ExtArgs>
    notifications?: boolean | SubAccount$notificationsArgs<ExtArgs>
    _count?: boolean | SubAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type SubAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $SubAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubAccount"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
      sidebarOptions: Prisma.$SubAccountSidebarOptionPayload<ExtArgs>[]
      permissions: Prisma.$PermissionsPayload<ExtArgs>[]
      funnels: Prisma.$FunnelPayload<ExtArgs>[]
      media: Prisma.$MediaPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      triggers: Prisma.$TriggerPayload<ExtArgs>[]
      automations: Prisma.$AutomationPayload<ExtArgs>[]
      pipelines: Prisma.$PipelinePayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      connectAccountId: string | null
      name: string
      subAccountLogo: string
      companyEmail: string
      companyPhone: string
      goal: number
      address: string
      city: string
      zipCode: string
      state: string
      country: string
      agencyId: string
    }, ExtArgs["result"]["subAccount"]>
    composites: {}
  }

  type SubAccountGetPayload<S extends boolean | null | undefined | SubAccountDefaultArgs> = $Result.GetResult<Prisma.$SubAccountPayload, S>

  type SubAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubAccountCountAggregateInputType | true
    }

  export interface SubAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubAccount'], meta: { name: 'SubAccount' } }
    /**
     * Find zero or one SubAccount that matches the filter.
     * @param {SubAccountFindUniqueArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubAccountFindUniqueArgs>(args: SelectSubset<T, SubAccountFindUniqueArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubAccountFindUniqueOrThrowArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SubAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindFirstArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubAccountFindFirstArgs>(args?: SelectSubset<T, SubAccountFindFirstArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindFirstOrThrowArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SubAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAccounts
     * const subAccounts = await prisma.subAccount.findMany()
     * 
     * // Get first 10 SubAccounts
     * const subAccounts = await prisma.subAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubAccountFindManyArgs>(args?: SelectSubset<T, SubAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubAccount.
     * @param {SubAccountCreateArgs} args - Arguments to create a SubAccount.
     * @example
     * // Create one SubAccount
     * const SubAccount = await prisma.subAccount.create({
     *   data: {
     *     // ... data to create a SubAccount
     *   }
     * })
     * 
     */
    create<T extends SubAccountCreateArgs>(args: SelectSubset<T, SubAccountCreateArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubAccounts.
     * @param {SubAccountCreateManyArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccount = await prisma.subAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubAccountCreateManyArgs>(args?: SelectSubset<T, SubAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubAccounts and returns the data saved in the database.
     * @param {SubAccountCreateManyAndReturnArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccount = await prisma.subAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubAccounts and only return the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SubAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubAccount.
     * @param {SubAccountDeleteArgs} args - Arguments to delete one SubAccount.
     * @example
     * // Delete one SubAccount
     * const SubAccount = await prisma.subAccount.delete({
     *   where: {
     *     // ... filter to delete one SubAccount
     *   }
     * })
     * 
     */
    delete<T extends SubAccountDeleteArgs>(args: SelectSubset<T, SubAccountDeleteArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubAccount.
     * @param {SubAccountUpdateArgs} args - Arguments to update one SubAccount.
     * @example
     * // Update one SubAccount
     * const subAccount = await prisma.subAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubAccountUpdateArgs>(args: SelectSubset<T, SubAccountUpdateArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubAccounts.
     * @param {SubAccountDeleteManyArgs} args - Arguments to filter SubAccounts to delete.
     * @example
     * // Delete a few SubAccounts
     * const { count } = await prisma.subAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubAccountDeleteManyArgs>(args?: SelectSubset<T, SubAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAccounts
     * const subAccount = await prisma.subAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubAccountUpdateManyArgs>(args: SelectSubset<T, SubAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccounts and returns the data updated in the database.
     * @param {SubAccountUpdateManyAndReturnArgs} args - Arguments to update many SubAccounts.
     * @example
     * // Update many SubAccounts
     * const subAccount = await prisma.subAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubAccounts and only return the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SubAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubAccount.
     * @param {SubAccountUpsertArgs} args - Arguments to update or create a SubAccount.
     * @example
     * // Update or create a SubAccount
     * const subAccount = await prisma.subAccount.upsert({
     *   create: {
     *     // ... data to create a SubAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubAccount we want to update
     *   }
     * })
     */
    upsert<T extends SubAccountUpsertArgs>(args: SelectSubset<T, SubAccountUpsertArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountCountArgs} args - Arguments to filter SubAccounts to count.
     * @example
     * // Count the number of SubAccounts
     * const count = await prisma.subAccount.count({
     *   where: {
     *     // ... the filter for the SubAccounts we want to count
     *   }
     * })
    **/
    count<T extends SubAccountCountArgs>(
      args?: Subset<T, SubAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAccountAggregateArgs>(args: Subset<T, SubAccountAggregateArgs>): Prisma.PrismaPromise<GetSubAccountAggregateType<T>>

    /**
     * Group by SubAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubAccountGroupByArgs['orderBy'] }
        : { orderBy?: SubAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubAccount model
   */
  readonly fields: SubAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sidebarOptions<T extends SubAccount$sidebarOptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$sidebarOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends SubAccount$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    funnels<T extends SubAccount$funnelsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$funnelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    media<T extends SubAccount$mediaArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends SubAccount$contactsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    triggers<T extends SubAccount$triggersArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$triggersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    automations<T extends SubAccount$automationsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$automationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pipelines<T extends SubAccount$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$pipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends SubAccount$tagsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends SubAccount$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubAccount model
   */
  interface SubAccountFieldRefs {
    readonly id: FieldRef<"SubAccount", 'String'>
    readonly createdAt: FieldRef<"SubAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SubAccount", 'DateTime'>
    readonly connectAccountId: FieldRef<"SubAccount", 'String'>
    readonly name: FieldRef<"SubAccount", 'String'>
    readonly subAccountLogo: FieldRef<"SubAccount", 'String'>
    readonly companyEmail: FieldRef<"SubAccount", 'String'>
    readonly companyPhone: FieldRef<"SubAccount", 'String'>
    readonly goal: FieldRef<"SubAccount", 'Int'>
    readonly address: FieldRef<"SubAccount", 'String'>
    readonly city: FieldRef<"SubAccount", 'String'>
    readonly zipCode: FieldRef<"SubAccount", 'String'>
    readonly state: FieldRef<"SubAccount", 'String'>
    readonly country: FieldRef<"SubAccount", 'String'>
    readonly agencyId: FieldRef<"SubAccount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubAccount findUnique
   */
  export type SubAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount findUniqueOrThrow
   */
  export type SubAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount findFirst
   */
  export type SubAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount findFirstOrThrow
   */
  export type SubAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount findMany
   */
  export type SubAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount create
   */
  export type SubAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SubAccount.
     */
    data: XOR<SubAccountCreateInput, SubAccountUncheckedCreateInput>
  }

  /**
   * SubAccount createMany
   */
  export type SubAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountCreateManyInput | SubAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubAccount createManyAndReturn
   */
  export type SubAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountCreateManyInput | SubAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccount update
   */
  export type SubAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SubAccount.
     */
    data: XOR<SubAccountUpdateInput, SubAccountUncheckedUpdateInput>
    /**
     * Choose, which SubAccount to update.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount updateMany
   */
  export type SubAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubAccounts.
     */
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyInput>
    /**
     * Filter which SubAccounts to update
     */
    where?: SubAccountWhereInput
    /**
     * Limit how many SubAccounts to update.
     */
    limit?: number
  }

  /**
   * SubAccount updateManyAndReturn
   */
  export type SubAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * The data used to update SubAccounts.
     */
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyInput>
    /**
     * Filter which SubAccounts to update
     */
    where?: SubAccountWhereInput
    /**
     * Limit how many SubAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccount upsert
   */
  export type SubAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SubAccount to update in case it exists.
     */
    where: SubAccountWhereUniqueInput
    /**
     * In case the SubAccount found by the `where` argument doesn't exist, create a new SubAccount with this data.
     */
    create: XOR<SubAccountCreateInput, SubAccountUncheckedCreateInput>
    /**
     * In case the SubAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubAccountUpdateInput, SubAccountUncheckedUpdateInput>
  }

  /**
   * SubAccount delete
   */
  export type SubAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter which SubAccount to delete.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount deleteMany
   */
  export type SubAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccounts to delete
     */
    where?: SubAccountWhereInput
    /**
     * Limit how many SubAccounts to delete.
     */
    limit?: number
  }

  /**
   * SubAccount.sidebarOptions
   */
  export type SubAccount$sidebarOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    where?: SubAccountSidebarOptionWhereInput
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccount.permissions
   */
  export type SubAccount$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    cursor?: PermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * SubAccount.funnels
   */
  export type SubAccount$funnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    where?: FunnelWhereInput
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    cursor?: FunnelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunnelScalarFieldEnum | FunnelScalarFieldEnum[]
  }

  /**
   * SubAccount.media
   */
  export type SubAccount$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * SubAccount.contacts
   */
  export type SubAccount$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * SubAccount.triggers
   */
  export type SubAccount$triggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    where?: TriggerWhereInput
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    cursor?: TriggerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }

  /**
   * SubAccount.automations
   */
  export type SubAccount$automationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    cursor?: AutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * SubAccount.pipelines
   */
  export type SubAccount$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    cursor?: PipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * SubAccount.tags
   */
  export type SubAccount$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * SubAccount.notifications
   */
  export type SubAccount$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * SubAccount without action
   */
  export type SubAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
  }


  /**
   * Model Permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: string | null
    email: string | null
    subAccountId: string | null
    access: boolean | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: string | null
    email: string | null
    subAccountId: string | null
    access: boolean | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    email: number
    subAccountId: number
    access: number
    _all: number
  }


  export type PermissionsMinAggregateInputType = {
    id?: true
    email?: true
    subAccountId?: true
    access?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    email?: true
    subAccountId?: true
    access?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    email?: true
    subAccountId?: true
    access?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to aggregate.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type PermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithAggregationInput | PermissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: PermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: string
    email: string
    subAccountId: string
    access: boolean
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends PermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type PermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    subAccountId?: boolean
    access?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    subAccountId?: boolean
    access?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    subAccountId?: boolean
    access?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectScalar = {
    id?: boolean
    email?: boolean
    subAccountId?: boolean
    access?: boolean
  }

  export type PermissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "subAccountId" | "access", ExtArgs["result"]["permissions"]>
  export type PermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type PermissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type PermissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $PermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permissions"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subAccount: Prisma.$SubAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      subAccountId: string
      access: boolean
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type PermissionsGetPayload<S extends boolean | null | undefined | PermissionsDefaultArgs> = $Result.GetResult<Prisma.$PermissionsPayload, S>

  type PermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface PermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permissions'], meta: { name: 'Permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {PermissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionsFindUniqueArgs>(args: SelectSubset<T, PermissionsFindUniqueArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionsFindFirstArgs>(args?: SelectSubset<T, PermissionsFindFirstArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionsFindManyArgs>(args?: SelectSubset<T, PermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {PermissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends PermissionsCreateArgs>(args: SelectSubset<T, PermissionsCreateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionsCreateManyArgs>(args?: SelectSubset<T, PermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionsCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permissions.
     * @param {PermissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends PermissionsDeleteArgs>(args: SelectSubset<T, PermissionsDeleteArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {PermissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionsUpdateArgs>(args: SelectSubset<T, PermissionsUpdateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionsDeleteManyArgs>(args?: SelectSubset<T, PermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionsUpdateManyArgs>(args: SelectSubset<T, PermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionsUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permissions.
     * @param {PermissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends PermissionsUpsertArgs>(args: SelectSubset<T, PermissionsUpsertArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionsCountArgs>(
      args?: Subset<T, PermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionsGroupByArgs['orderBy'] }
        : { orderBy?: PermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permissions model
   */
  readonly fields: PermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permissions model
   */
  interface PermissionsFieldRefs {
    readonly id: FieldRef<"Permissions", 'String'>
    readonly email: FieldRef<"Permissions", 'String'>
    readonly subAccountId: FieldRef<"Permissions", 'String'>
    readonly access: FieldRef<"Permissions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Permissions findUnique
   */
  export type PermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findUniqueOrThrow
   */
  export type PermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findFirst
   */
  export type PermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findFirstOrThrow
   */
  export type PermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findMany
   */
  export type PermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions create
   */
  export type PermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Permissions.
     */
    data: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
  }

  /**
   * Permissions createMany
   */
  export type PermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionsCreateManyInput | PermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permissions createManyAndReturn
   */
  export type PermissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionsCreateManyInput | PermissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permissions update
   */
  export type PermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Permissions.
     */
    data: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
    /**
     * Choose, which Permissions to update.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions updateMany
   */
  export type PermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permissions updateManyAndReturn
   */
  export type PermissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permissions upsert
   */
  export type PermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Permissions to update in case it exists.
     */
    where: PermissionsWhereUniqueInput
    /**
     * In case the Permissions found by the `where` argument doesn't exist, create a new Permissions with this data.
     */
    create: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
    /**
     * In case the Permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
  }

  /**
   * Permissions delete
   */
  export type PermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter which Permissions to delete.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions deleteMany
   */
  export type PermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permissions without action
   */
  export type PermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    color: string | null
    subAccountId: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    color: string | null
    subAccountId: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    color: number
    subAccountId: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    color?: true
    subAccountId?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    color?: true
    subAccountId?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    color?: true
    subAccountId?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    color: string
    subAccountId: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    color?: boolean
    subAccountId?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    tickets?: boolean | Tag$ticketsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    color?: boolean
    subAccountId?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    color?: boolean
    subAccountId?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    color?: boolean
    subAccountId?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "color" | "subAccountId", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    tickets?: boolean | Tag$ticketsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      subAccount: Prisma.$SubAccountPayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      color: string
      subAccountId: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tickets<T extends Tag$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly subAccountId: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.tickets
   */
  export type Tag$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Pipeline
   */

  export type AggregatePipeline = {
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  export type PipelineMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    subAccountId: string | null
  }

  export type PipelineMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    subAccountId: string | null
  }

  export type PipelineCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    subAccountId: number
    _all: number
  }


  export type PipelineMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    subAccountId?: true
  }

  export type PipelineMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    subAccountId?: true
  }

  export type PipelineCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    subAccountId?: true
    _all?: true
  }

  export type PipelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipeline to aggregate.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pipelines
    **/
    _count?: true | PipelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineMaxAggregateInputType
  }

  export type GetPipelineAggregateType<T extends PipelineAggregateArgs> = {
        [P in keyof T & keyof AggregatePipeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipeline[P]>
      : GetScalarType<T[P], AggregatePipeline[P]>
  }




  export type PipelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithAggregationInput | PipelineOrderByWithAggregationInput[]
    by: PipelineScalarFieldEnum[] | PipelineScalarFieldEnum
    having?: PipelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineCountAggregateInputType | true
    _min?: PipelineMinAggregateInputType
    _max?: PipelineMaxAggregateInputType
  }

  export type PipelineGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    subAccountId: string
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  type GetPipelineGroupByPayload<T extends PipelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineGroupByOutputType[P]>
        }
      >
    >


  export type PipelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    subAccountId?: boolean
    lanes?: boolean | Pipeline$lanesArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    _count?: boolean | PipelineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    subAccountId?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    subAccountId?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    subAccountId?: boolean
  }

  export type PipelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "subAccountId", ExtArgs["result"]["pipeline"]>
  export type PipelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lanes?: boolean | Pipeline$lanesArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    _count?: boolean | PipelineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PipelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type PipelineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $PipelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pipeline"
    objects: {
      lanes: Prisma.$LanePayload<ExtArgs>[]
      subAccount: Prisma.$SubAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      subAccountId: string
    }, ExtArgs["result"]["pipeline"]>
    composites: {}
  }

  type PipelineGetPayload<S extends boolean | null | undefined | PipelineDefaultArgs> = $Result.GetResult<Prisma.$PipelinePayload, S>

  type PipelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PipelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PipelineCountAggregateInputType | true
    }

  export interface PipelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pipeline'], meta: { name: 'Pipeline' } }
    /**
     * Find zero or one Pipeline that matches the filter.
     * @param {PipelineFindUniqueArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineFindUniqueArgs>(args: SelectSubset<T, PipelineFindUniqueArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pipeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PipelineFindUniqueOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineFindFirstArgs>(args?: SelectSubset<T, PipelineFindFirstArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pipelines
     * const pipelines = await prisma.pipeline.findMany()
     * 
     * // Get first 10 Pipelines
     * const pipelines = await prisma.pipeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineFindManyArgs>(args?: SelectSubset<T, PipelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pipeline.
     * @param {PipelineCreateArgs} args - Arguments to create a Pipeline.
     * @example
     * // Create one Pipeline
     * const Pipeline = await prisma.pipeline.create({
     *   data: {
     *     // ... data to create a Pipeline
     *   }
     * })
     * 
     */
    create<T extends PipelineCreateArgs>(args: SelectSubset<T, PipelineCreateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pipelines.
     * @param {PipelineCreateManyArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineCreateManyArgs>(args?: SelectSubset<T, PipelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pipelines and returns the data saved in the database.
     * @param {PipelineCreateManyAndReturnArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pipelines and only return the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelineCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pipeline.
     * @param {PipelineDeleteArgs} args - Arguments to delete one Pipeline.
     * @example
     * // Delete one Pipeline
     * const Pipeline = await prisma.pipeline.delete({
     *   where: {
     *     // ... filter to delete one Pipeline
     *   }
     * })
     * 
     */
    delete<T extends PipelineDeleteArgs>(args: SelectSubset<T, PipelineDeleteArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pipeline.
     * @param {PipelineUpdateArgs} args - Arguments to update one Pipeline.
     * @example
     * // Update one Pipeline
     * const pipeline = await prisma.pipeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineUpdateArgs>(args: SelectSubset<T, PipelineUpdateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pipelines.
     * @param {PipelineDeleteManyArgs} args - Arguments to filter Pipelines to delete.
     * @example
     * // Delete a few Pipelines
     * const { count } = await prisma.pipeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineDeleteManyArgs>(args?: SelectSubset<T, PipelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineUpdateManyArgs>(args: SelectSubset<T, PipelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines and returns the data updated in the database.
     * @param {PipelineUpdateManyAndReturnArgs} args - Arguments to update many Pipelines.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pipelines and only return the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PipelineUpdateManyAndReturnArgs>(args: SelectSubset<T, PipelineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pipeline.
     * @param {PipelineUpsertArgs} args - Arguments to update or create a Pipeline.
     * @example
     * // Update or create a Pipeline
     * const pipeline = await prisma.pipeline.upsert({
     *   create: {
     *     // ... data to create a Pipeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pipeline we want to update
     *   }
     * })
     */
    upsert<T extends PipelineUpsertArgs>(args: SelectSubset<T, PipelineUpsertArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineCountArgs} args - Arguments to filter Pipelines to count.
     * @example
     * // Count the number of Pipelines
     * const count = await prisma.pipeline.count({
     *   where: {
     *     // ... the filter for the Pipelines we want to count
     *   }
     * })
    **/
    count<T extends PipelineCountArgs>(
      args?: Subset<T, PipelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineAggregateArgs>(args: Subset<T, PipelineAggregateArgs>): Prisma.PrismaPromise<GetPipelineAggregateType<T>>

    /**
     * Group by Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineGroupByArgs['orderBy'] }
        : { orderBy?: PipelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pipeline model
   */
  readonly fields: PipelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pipeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lanes<T extends Pipeline$lanesArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$lanesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pipeline model
   */
  interface PipelineFieldRefs {
    readonly id: FieldRef<"Pipeline", 'String'>
    readonly createdAt: FieldRef<"Pipeline", 'DateTime'>
    readonly updatedAt: FieldRef<"Pipeline", 'DateTime'>
    readonly name: FieldRef<"Pipeline", 'String'>
    readonly subAccountId: FieldRef<"Pipeline", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pipeline findUnique
   */
  export type PipelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findUniqueOrThrow
   */
  export type PipelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findFirst
   */
  export type PipelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findFirstOrThrow
   */
  export type PipelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findMany
   */
  export type PipelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline create
   */
  export type PipelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to create a Pipeline.
     */
    data: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
  }

  /**
   * Pipeline createMany
   */
  export type PipelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pipeline createManyAndReturn
   */
  export type PipelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipeline update
   */
  export type PipelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to update a Pipeline.
     */
    data: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
    /**
     * Choose, which Pipeline to update.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline updateMany
   */
  export type PipelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
  }

  /**
   * Pipeline updateManyAndReturn
   */
  export type PipelineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipeline upsert
   */
  export type PipelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The filter to search for the Pipeline to update in case it exists.
     */
    where: PipelineWhereUniqueInput
    /**
     * In case the Pipeline found by the `where` argument doesn't exist, create a new Pipeline with this data.
     */
    create: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
    /**
     * In case the Pipeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
  }

  /**
   * Pipeline delete
   */
  export type PipelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter which Pipeline to delete.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline deleteMany
   */
  export type PipelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to delete
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to delete.
     */
    limit?: number
  }

  /**
   * Pipeline.lanes
   */
  export type Pipeline$lanesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    where?: LaneWhereInput
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    cursor?: LaneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Pipeline without action
   */
  export type PipelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    notification: string | null
    agencyId: string | null
    subAccountId: string | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    notification: string | null
    agencyId: string | null
    subAccountId: string | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    notification: number
    agencyId: number
    subAccountId: number
    userId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    notification: string
    agencyId: string
    subAccountId: string | null
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    subAccount?: boolean | Notification$subAccountArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    subAccount?: boolean | Notification$subAccountArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    subAccount?: boolean | Notification$subAccountArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "notification" | "agencyId" | "subAccountId" | "userId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    subAccount?: boolean | Notification$subAccountArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    subAccount?: boolean | Notification$subAccountArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
    subAccount?: boolean | Notification$subAccountArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs>
      subAccount: Prisma.$SubAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      notification: string
      agencyId: string
      subAccountId: string | null
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subAccount<T extends Notification$subAccountArgs<ExtArgs> = {}>(args?: Subset<T, Notification$subAccountArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly notification: FieldRef<"Notification", 'String'>
    readonly agencyId: FieldRef<"Notification", 'String'>
    readonly subAccountId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.subAccount
   */
  export type Notification$subAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Lane
   */

  export type AggregateLane = {
    _count: LaneCountAggregateOutputType | null
    _avg: LaneAvgAggregateOutputType | null
    _sum: LaneSumAggregateOutputType | null
    _min: LaneMinAggregateOutputType | null
    _max: LaneMaxAggregateOutputType | null
  }

  export type LaneAvgAggregateOutputType = {
    order: number | null
  }

  export type LaneSumAggregateOutputType = {
    order: number | null
  }

  export type LaneMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    pipelineId: string | null
    order: number | null
    color: string | null
  }

  export type LaneMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    pipelineId: string | null
    order: number | null
    color: string | null
  }

  export type LaneCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    pipelineId: number
    order: number
    color: number
    _all: number
  }


  export type LaneAvgAggregateInputType = {
    order?: true
  }

  export type LaneSumAggregateInputType = {
    order?: true
  }

  export type LaneMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    pipelineId?: true
    order?: true
    color?: true
  }

  export type LaneMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    pipelineId?: true
    order?: true
    color?: true
  }

  export type LaneCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    pipelineId?: true
    order?: true
    color?: true
    _all?: true
  }

  export type LaneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lane to aggregate.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lanes
    **/
    _count?: true | LaneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaneMaxAggregateInputType
  }

  export type GetLaneAggregateType<T extends LaneAggregateArgs> = {
        [P in keyof T & keyof AggregateLane]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLane[P]>
      : GetScalarType<T[P], AggregateLane[P]>
  }




  export type LaneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaneWhereInput
    orderBy?: LaneOrderByWithAggregationInput | LaneOrderByWithAggregationInput[]
    by: LaneScalarFieldEnum[] | LaneScalarFieldEnum
    having?: LaneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaneCountAggregateInputType | true
    _avg?: LaneAvgAggregateInputType
    _sum?: LaneSumAggregateInputType
    _min?: LaneMinAggregateInputType
    _max?: LaneMaxAggregateInputType
  }

  export type LaneGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    pipelineId: string
    order: number
    color: string
    _count: LaneCountAggregateOutputType | null
    _avg: LaneAvgAggregateOutputType | null
    _sum: LaneSumAggregateOutputType | null
    _min: LaneMinAggregateOutputType | null
    _max: LaneMaxAggregateOutputType | null
  }

  type GetLaneGroupByPayload<T extends LaneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaneGroupByOutputType[P]>
            : GetScalarType<T[P], LaneGroupByOutputType[P]>
        }
      >
    >


  export type LaneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    pipelineId?: boolean
    order?: boolean
    color?: boolean
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    tickets?: boolean | Lane$ticketsArgs<ExtArgs>
    _count?: boolean | LaneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    pipelineId?: boolean
    order?: boolean
    color?: boolean
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    pipelineId?: boolean
    order?: boolean
    color?: boolean
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    pipelineId?: boolean
    order?: boolean
    color?: boolean
  }

  export type LaneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "pipelineId" | "order" | "color", ExtArgs["result"]["lane"]>
  export type LaneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    tickets?: boolean | Lane$ticketsArgs<ExtArgs>
    _count?: boolean | LaneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LaneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
  }
  export type LaneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
  }

  export type $LanePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lane"
    objects: {
      pipeline: Prisma.$PipelinePayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      pipelineId: string
      order: number
      color: string
    }, ExtArgs["result"]["lane"]>
    composites: {}
  }

  type LaneGetPayload<S extends boolean | null | undefined | LaneDefaultArgs> = $Result.GetResult<Prisma.$LanePayload, S>

  type LaneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaneCountAggregateInputType | true
    }

  export interface LaneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lane'], meta: { name: 'Lane' } }
    /**
     * Find zero or one Lane that matches the filter.
     * @param {LaneFindUniqueArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaneFindUniqueArgs>(args: SelectSubset<T, LaneFindUniqueArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lane that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaneFindUniqueOrThrowArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaneFindUniqueOrThrowArgs>(args: SelectSubset<T, LaneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lane that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindFirstArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaneFindFirstArgs>(args?: SelectSubset<T, LaneFindFirstArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lane that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindFirstOrThrowArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaneFindFirstOrThrowArgs>(args?: SelectSubset<T, LaneFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lanes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lanes
     * const lanes = await prisma.lane.findMany()
     * 
     * // Get first 10 Lanes
     * const lanes = await prisma.lane.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laneWithIdOnly = await prisma.lane.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaneFindManyArgs>(args?: SelectSubset<T, LaneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lane.
     * @param {LaneCreateArgs} args - Arguments to create a Lane.
     * @example
     * // Create one Lane
     * const Lane = await prisma.lane.create({
     *   data: {
     *     // ... data to create a Lane
     *   }
     * })
     * 
     */
    create<T extends LaneCreateArgs>(args: SelectSubset<T, LaneCreateArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lanes.
     * @param {LaneCreateManyArgs} args - Arguments to create many Lanes.
     * @example
     * // Create many Lanes
     * const lane = await prisma.lane.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaneCreateManyArgs>(args?: SelectSubset<T, LaneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lanes and returns the data saved in the database.
     * @param {LaneCreateManyAndReturnArgs} args - Arguments to create many Lanes.
     * @example
     * // Create many Lanes
     * const lane = await prisma.lane.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lanes and only return the `id`
     * const laneWithIdOnly = await prisma.lane.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaneCreateManyAndReturnArgs>(args?: SelectSubset<T, LaneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lane.
     * @param {LaneDeleteArgs} args - Arguments to delete one Lane.
     * @example
     * // Delete one Lane
     * const Lane = await prisma.lane.delete({
     *   where: {
     *     // ... filter to delete one Lane
     *   }
     * })
     * 
     */
    delete<T extends LaneDeleteArgs>(args: SelectSubset<T, LaneDeleteArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lane.
     * @param {LaneUpdateArgs} args - Arguments to update one Lane.
     * @example
     * // Update one Lane
     * const lane = await prisma.lane.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaneUpdateArgs>(args: SelectSubset<T, LaneUpdateArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lanes.
     * @param {LaneDeleteManyArgs} args - Arguments to filter Lanes to delete.
     * @example
     * // Delete a few Lanes
     * const { count } = await prisma.lane.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaneDeleteManyArgs>(args?: SelectSubset<T, LaneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lanes
     * const lane = await prisma.lane.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaneUpdateManyArgs>(args: SelectSubset<T, LaneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lanes and returns the data updated in the database.
     * @param {LaneUpdateManyAndReturnArgs} args - Arguments to update many Lanes.
     * @example
     * // Update many Lanes
     * const lane = await prisma.lane.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lanes and only return the `id`
     * const laneWithIdOnly = await prisma.lane.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaneUpdateManyAndReturnArgs>(args: SelectSubset<T, LaneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lane.
     * @param {LaneUpsertArgs} args - Arguments to update or create a Lane.
     * @example
     * // Update or create a Lane
     * const lane = await prisma.lane.upsert({
     *   create: {
     *     // ... data to create a Lane
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lane we want to update
     *   }
     * })
     */
    upsert<T extends LaneUpsertArgs>(args: SelectSubset<T, LaneUpsertArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneCountArgs} args - Arguments to filter Lanes to count.
     * @example
     * // Count the number of Lanes
     * const count = await prisma.lane.count({
     *   where: {
     *     // ... the filter for the Lanes we want to count
     *   }
     * })
    **/
    count<T extends LaneCountArgs>(
      args?: Subset<T, LaneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaneAggregateArgs>(args: Subset<T, LaneAggregateArgs>): Prisma.PrismaPromise<GetLaneAggregateType<T>>

    /**
     * Group by Lane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaneGroupByArgs['orderBy'] }
        : { orderBy?: LaneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lane model
   */
  readonly fields: LaneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lane.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pipeline<T extends PipelineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PipelineDefaultArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tickets<T extends Lane$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Lane$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lane model
   */
  interface LaneFieldRefs {
    readonly id: FieldRef<"Lane", 'String'>
    readonly createdAt: FieldRef<"Lane", 'DateTime'>
    readonly updatedAt: FieldRef<"Lane", 'DateTime'>
    readonly name: FieldRef<"Lane", 'String'>
    readonly pipelineId: FieldRef<"Lane", 'String'>
    readonly order: FieldRef<"Lane", 'Int'>
    readonly color: FieldRef<"Lane", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lane findUnique
   */
  export type LaneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane findUniqueOrThrow
   */
  export type LaneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane findFirst
   */
  export type LaneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lanes.
     */
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane findFirstOrThrow
   */
  export type LaneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lanes.
     */
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane findMany
   */
  export type LaneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lanes to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane create
   */
  export type LaneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The data needed to create a Lane.
     */
    data: XOR<LaneCreateInput, LaneUncheckedCreateInput>
  }

  /**
   * Lane createMany
   */
  export type LaneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lanes.
     */
    data: LaneCreateManyInput | LaneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lane createManyAndReturn
   */
  export type LaneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * The data used to create many Lanes.
     */
    data: LaneCreateManyInput | LaneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lane update
   */
  export type LaneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The data needed to update a Lane.
     */
    data: XOR<LaneUpdateInput, LaneUncheckedUpdateInput>
    /**
     * Choose, which Lane to update.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane updateMany
   */
  export type LaneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lanes.
     */
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyInput>
    /**
     * Filter which Lanes to update
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to update.
     */
    limit?: number
  }

  /**
   * Lane updateManyAndReturn
   */
  export type LaneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * The data used to update Lanes.
     */
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyInput>
    /**
     * Filter which Lanes to update
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lane upsert
   */
  export type LaneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The filter to search for the Lane to update in case it exists.
     */
    where: LaneWhereUniqueInput
    /**
     * In case the Lane found by the `where` argument doesn't exist, create a new Lane with this data.
     */
    create: XOR<LaneCreateInput, LaneUncheckedCreateInput>
    /**
     * In case the Lane was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaneUpdateInput, LaneUncheckedUpdateInput>
  }

  /**
   * Lane delete
   */
  export type LaneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter which Lane to delete.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane deleteMany
   */
  export type LaneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lanes to delete
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to delete.
     */
    limit?: number
  }

  /**
   * Lane.tickets
   */
  export type Lane$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Lane without action
   */
  export type LaneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    order: number | null
    value: Decimal | null
  }

  export type TicketSumAggregateOutputType = {
    order: number | null
    value: Decimal | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    laneId: string | null
    order: number | null
    value: Decimal | null
    description: string | null
    customerId: string | null
    assignedUserId: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    laneId: string | null
    order: number | null
    value: Decimal | null
    description: string | null
    customerId: string | null
    assignedUserId: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    laneId: number
    order: number
    value: number
    description: number
    customerId: number
    assignedUserId: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    order?: true
    value?: true
  }

  export type TicketSumAggregateInputType = {
    order?: true
    value?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    laneId?: true
    order?: true
    value?: true
    description?: true
    customerId?: true
    assignedUserId?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    laneId?: true
    order?: true
    value?: true
    description?: true
    customerId?: true
    assignedUserId?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    laneId?: true
    order?: true
    value?: true
    description?: true
    customerId?: true
    assignedUserId?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    laneId: string
    order: number
    value: Decimal | null
    description: string | null
    customerId: string | null
    assignedUserId: string | null
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    laneId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    customerId?: boolean
    assignedUserId?: boolean
    lane?: boolean | LaneDefaultArgs<ExtArgs>
    customer?: boolean | Ticket$customerArgs<ExtArgs>
    tags?: boolean | Ticket$tagsArgs<ExtArgs>
    assigned?: boolean | Ticket$assignedArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    laneId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    customerId?: boolean
    assignedUserId?: boolean
    lane?: boolean | LaneDefaultArgs<ExtArgs>
    customer?: boolean | Ticket$customerArgs<ExtArgs>
    assigned?: boolean | Ticket$assignedArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    laneId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    customerId?: boolean
    assignedUserId?: boolean
    lane?: boolean | LaneDefaultArgs<ExtArgs>
    customer?: boolean | Ticket$customerArgs<ExtArgs>
    assigned?: boolean | Ticket$assignedArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    laneId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    customerId?: boolean
    assignedUserId?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "laneId" | "order" | "value" | "description" | "customerId" | "assignedUserId", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lane?: boolean | LaneDefaultArgs<ExtArgs>
    customer?: boolean | Ticket$customerArgs<ExtArgs>
    tags?: boolean | Ticket$tagsArgs<ExtArgs>
    assigned?: boolean | Ticket$assignedArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lane?: boolean | LaneDefaultArgs<ExtArgs>
    customer?: boolean | Ticket$customerArgs<ExtArgs>
    assigned?: boolean | Ticket$assignedArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lane?: boolean | LaneDefaultArgs<ExtArgs>
    customer?: boolean | Ticket$customerArgs<ExtArgs>
    assigned?: boolean | Ticket$assignedArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      lane: Prisma.$LanePayload<ExtArgs>
      customer: Prisma.$ContactPayload<ExtArgs> | null
      tags: Prisma.$TagPayload<ExtArgs>[]
      assigned: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      laneId: string
      order: number
      value: Prisma.Decimal | null
      description: string | null
      customerId: string | null
      assignedUserId: string | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lane<T extends LaneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaneDefaultArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Ticket$customerArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$customerArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tags<T extends Ticket$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assigned<T extends Ticket$assignedArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$assignedArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly name: FieldRef<"Ticket", 'String'>
    readonly laneId: FieldRef<"Ticket", 'String'>
    readonly order: FieldRef<"Ticket", 'Int'>
    readonly value: FieldRef<"Ticket", 'Decimal'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly customerId: FieldRef<"Ticket", 'String'>
    readonly assignedUserId: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.customer
   */
  export type Ticket$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Ticket.tags
   */
  export type Ticket$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Ticket.assigned
   */
  export type Ticket$assignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model Trigger
   */

  export type AggregateTrigger = {
    _count: TriggerCountAggregateOutputType | null
    _min: TriggerMinAggregateOutputType | null
    _max: TriggerMaxAggregateOutputType | null
  }

  export type TriggerMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    subAccountId: string | null
    type: $Enums.TriggerTypes | null
  }

  export type TriggerMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    subAccountId: string | null
    type: $Enums.TriggerTypes | null
  }

  export type TriggerCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    subAccountId: number
    type: number
    _all: number
  }


  export type TriggerMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    subAccountId?: true
    type?: true
  }

  export type TriggerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    subAccountId?: true
    type?: true
  }

  export type TriggerCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    subAccountId?: true
    type?: true
    _all?: true
  }

  export type TriggerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trigger to aggregate.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Triggers
    **/
    _count?: true | TriggerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriggerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriggerMaxAggregateInputType
  }

  export type GetTriggerAggregateType<T extends TriggerAggregateArgs> = {
        [P in keyof T & keyof AggregateTrigger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrigger[P]>
      : GetScalarType<T[P], AggregateTrigger[P]>
  }




  export type TriggerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerWhereInput
    orderBy?: TriggerOrderByWithAggregationInput | TriggerOrderByWithAggregationInput[]
    by: TriggerScalarFieldEnum[] | TriggerScalarFieldEnum
    having?: TriggerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriggerCountAggregateInputType | true
    _min?: TriggerMinAggregateInputType
    _max?: TriggerMaxAggregateInputType
  }

  export type TriggerGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    subAccountId: string
    type: $Enums.TriggerTypes
    _count: TriggerCountAggregateOutputType | null
    _min: TriggerMinAggregateOutputType | null
    _max: TriggerMaxAggregateOutputType | null
  }

  type GetTriggerGroupByPayload<T extends TriggerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TriggerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriggerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriggerGroupByOutputType[P]>
            : GetScalarType<T[P], TriggerGroupByOutputType[P]>
        }
      >
    >


  export type TriggerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    subAccountId?: boolean
    type?: boolean
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    automations?: boolean | Trigger$automationsArgs<ExtArgs>
    _count?: boolean | TriggerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trigger"]>

  export type TriggerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    subAccountId?: boolean
    type?: boolean
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trigger"]>

  export type TriggerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    subAccountId?: boolean
    type?: boolean
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trigger"]>

  export type TriggerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    subAccountId?: boolean
    type?: boolean
  }

  export type TriggerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "subAccountId" | "type", ExtArgs["result"]["trigger"]>
  export type TriggerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    automations?: boolean | Trigger$automationsArgs<ExtArgs>
    _count?: boolean | TriggerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TriggerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type TriggerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $TriggerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trigger"
    objects: {
      subaccount: Prisma.$SubAccountPayload<ExtArgs>
      automations: Prisma.$AutomationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      subAccountId: string
      type: $Enums.TriggerTypes
    }, ExtArgs["result"]["trigger"]>
    composites: {}
  }

  type TriggerGetPayload<S extends boolean | null | undefined | TriggerDefaultArgs> = $Result.GetResult<Prisma.$TriggerPayload, S>

  type TriggerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TriggerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TriggerCountAggregateInputType | true
    }

  export interface TriggerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trigger'], meta: { name: 'Trigger' } }
    /**
     * Find zero or one Trigger that matches the filter.
     * @param {TriggerFindUniqueArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TriggerFindUniqueArgs>(args: SelectSubset<T, TriggerFindUniqueArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trigger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TriggerFindUniqueOrThrowArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TriggerFindUniqueOrThrowArgs>(args: SelectSubset<T, TriggerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trigger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindFirstArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TriggerFindFirstArgs>(args?: SelectSubset<T, TriggerFindFirstArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trigger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindFirstOrThrowArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TriggerFindFirstOrThrowArgs>(args?: SelectSubset<T, TriggerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Triggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Triggers
     * const triggers = await prisma.trigger.findMany()
     * 
     * // Get first 10 Triggers
     * const triggers = await prisma.trigger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triggerWithIdOnly = await prisma.trigger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TriggerFindManyArgs>(args?: SelectSubset<T, TriggerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trigger.
     * @param {TriggerCreateArgs} args - Arguments to create a Trigger.
     * @example
     * // Create one Trigger
     * const Trigger = await prisma.trigger.create({
     *   data: {
     *     // ... data to create a Trigger
     *   }
     * })
     * 
     */
    create<T extends TriggerCreateArgs>(args: SelectSubset<T, TriggerCreateArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Triggers.
     * @param {TriggerCreateManyArgs} args - Arguments to create many Triggers.
     * @example
     * // Create many Triggers
     * const trigger = await prisma.trigger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TriggerCreateManyArgs>(args?: SelectSubset<T, TriggerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Triggers and returns the data saved in the database.
     * @param {TriggerCreateManyAndReturnArgs} args - Arguments to create many Triggers.
     * @example
     * // Create many Triggers
     * const trigger = await prisma.trigger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Triggers and only return the `id`
     * const triggerWithIdOnly = await prisma.trigger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TriggerCreateManyAndReturnArgs>(args?: SelectSubset<T, TriggerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trigger.
     * @param {TriggerDeleteArgs} args - Arguments to delete one Trigger.
     * @example
     * // Delete one Trigger
     * const Trigger = await prisma.trigger.delete({
     *   where: {
     *     // ... filter to delete one Trigger
     *   }
     * })
     * 
     */
    delete<T extends TriggerDeleteArgs>(args: SelectSubset<T, TriggerDeleteArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trigger.
     * @param {TriggerUpdateArgs} args - Arguments to update one Trigger.
     * @example
     * // Update one Trigger
     * const trigger = await prisma.trigger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TriggerUpdateArgs>(args: SelectSubset<T, TriggerUpdateArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Triggers.
     * @param {TriggerDeleteManyArgs} args - Arguments to filter Triggers to delete.
     * @example
     * // Delete a few Triggers
     * const { count } = await prisma.trigger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TriggerDeleteManyArgs>(args?: SelectSubset<T, TriggerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Triggers
     * const trigger = await prisma.trigger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TriggerUpdateManyArgs>(args: SelectSubset<T, TriggerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Triggers and returns the data updated in the database.
     * @param {TriggerUpdateManyAndReturnArgs} args - Arguments to update many Triggers.
     * @example
     * // Update many Triggers
     * const trigger = await prisma.trigger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Triggers and only return the `id`
     * const triggerWithIdOnly = await prisma.trigger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TriggerUpdateManyAndReturnArgs>(args: SelectSubset<T, TriggerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trigger.
     * @param {TriggerUpsertArgs} args - Arguments to update or create a Trigger.
     * @example
     * // Update or create a Trigger
     * const trigger = await prisma.trigger.upsert({
     *   create: {
     *     // ... data to create a Trigger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trigger we want to update
     *   }
     * })
     */
    upsert<T extends TriggerUpsertArgs>(args: SelectSubset<T, TriggerUpsertArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerCountArgs} args - Arguments to filter Triggers to count.
     * @example
     * // Count the number of Triggers
     * const count = await prisma.trigger.count({
     *   where: {
     *     // ... the filter for the Triggers we want to count
     *   }
     * })
    **/
    count<T extends TriggerCountArgs>(
      args?: Subset<T, TriggerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriggerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriggerAggregateArgs>(args: Subset<T, TriggerAggregateArgs>): Prisma.PrismaPromise<GetTriggerAggregateType<T>>

    /**
     * Group by Trigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriggerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriggerGroupByArgs['orderBy'] }
        : { orderBy?: TriggerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriggerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriggerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trigger model
   */
  readonly fields: TriggerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trigger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TriggerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subaccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    automations<T extends Trigger$automationsArgs<ExtArgs> = {}>(args?: Subset<T, Trigger$automationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trigger model
   */
  interface TriggerFieldRefs {
    readonly id: FieldRef<"Trigger", 'String'>
    readonly createdAt: FieldRef<"Trigger", 'DateTime'>
    readonly updatedAt: FieldRef<"Trigger", 'DateTime'>
    readonly name: FieldRef<"Trigger", 'String'>
    readonly subAccountId: FieldRef<"Trigger", 'String'>
    readonly type: FieldRef<"Trigger", 'TriggerTypes'>
  }
    

  // Custom InputTypes
  /**
   * Trigger findUnique
   */
  export type TriggerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where: TriggerWhereUniqueInput
  }

  /**
   * Trigger findUniqueOrThrow
   */
  export type TriggerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where: TriggerWhereUniqueInput
  }

  /**
   * Trigger findFirst
   */
  export type TriggerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Triggers.
     */
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }

  /**
   * Trigger findFirstOrThrow
   */
  export type TriggerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Triggers.
     */
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }

  /**
   * Trigger findMany
   */
  export type TriggerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Triggers to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }

  /**
   * Trigger create
   */
  export type TriggerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The data needed to create a Trigger.
     */
    data: XOR<TriggerCreateInput, TriggerUncheckedCreateInput>
  }

  /**
   * Trigger createMany
   */
  export type TriggerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Triggers.
     */
    data: TriggerCreateManyInput | TriggerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trigger createManyAndReturn
   */
  export type TriggerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * The data used to create many Triggers.
     */
    data: TriggerCreateManyInput | TriggerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trigger update
   */
  export type TriggerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The data needed to update a Trigger.
     */
    data: XOR<TriggerUpdateInput, TriggerUncheckedUpdateInput>
    /**
     * Choose, which Trigger to update.
     */
    where: TriggerWhereUniqueInput
  }

  /**
   * Trigger updateMany
   */
  export type TriggerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Triggers.
     */
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyInput>
    /**
     * Filter which Triggers to update
     */
    where?: TriggerWhereInput
    /**
     * Limit how many Triggers to update.
     */
    limit?: number
  }

  /**
   * Trigger updateManyAndReturn
   */
  export type TriggerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * The data used to update Triggers.
     */
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyInput>
    /**
     * Filter which Triggers to update
     */
    where?: TriggerWhereInput
    /**
     * Limit how many Triggers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trigger upsert
   */
  export type TriggerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The filter to search for the Trigger to update in case it exists.
     */
    where: TriggerWhereUniqueInput
    /**
     * In case the Trigger found by the `where` argument doesn't exist, create a new Trigger with this data.
     */
    create: XOR<TriggerCreateInput, TriggerUncheckedCreateInput>
    /**
     * In case the Trigger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriggerUpdateInput, TriggerUncheckedUpdateInput>
  }

  /**
   * Trigger delete
   */
  export type TriggerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter which Trigger to delete.
     */
    where: TriggerWhereUniqueInput
  }

  /**
   * Trigger deleteMany
   */
  export type TriggerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Triggers to delete
     */
    where?: TriggerWhereInput
    /**
     * Limit how many Triggers to delete.
     */
    limit?: number
  }

  /**
   * Trigger.automations
   */
  export type Trigger$automationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    cursor?: AutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Trigger without action
   */
  export type TriggerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
  }


  /**
   * Model Automation
   */

  export type AggregateAutomation = {
    _count: AutomationCountAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  export type AutomationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    triggerId: string | null
    published: boolean | null
    subAccountId: string | null
  }

  export type AutomationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    triggerId: string | null
    published: boolean | null
    subAccountId: string | null
  }

  export type AutomationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    triggerId: number
    published: number
    subAccountId: number
    _all: number
  }


  export type AutomationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    triggerId?: true
    published?: true
    subAccountId?: true
  }

  export type AutomationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    triggerId?: true
    published?: true
    subAccountId?: true
  }

  export type AutomationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    triggerId?: true
    published?: true
    subAccountId?: true
    _all?: true
  }

  export type AutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automation to aggregate.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Automations
    **/
    _count?: true | AutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationMaxAggregateInputType
  }

  export type GetAutomationAggregateType<T extends AutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomation[P]>
      : GetScalarType<T[P], AggregateAutomation[P]>
  }




  export type AutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithAggregationInput | AutomationOrderByWithAggregationInput[]
    by: AutomationScalarFieldEnum[] | AutomationScalarFieldEnum
    having?: AutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationCountAggregateInputType | true
    _min?: AutomationMinAggregateInputType
    _max?: AutomationMaxAggregateInputType
  }

  export type AutomationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    triggerId: string | null
    published: boolean
    subAccountId: string
    _count: AutomationCountAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  type GetAutomationGroupByPayload<T extends AutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationGroupByOutputType[P]>
        }
      >
    >


  export type AutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
    trigger?: boolean | Automation$triggerArgs<ExtArgs>
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    actions?: boolean | Automation$actionsArgs<ExtArgs>
    automationInstances?: boolean | Automation$automationInstancesArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
    trigger?: boolean | Automation$triggerArgs<ExtArgs>
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
    trigger?: boolean | Automation$triggerArgs<ExtArgs>
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
  }

  export type AutomationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "triggerId" | "published" | "subAccountId", ExtArgs["result"]["automation"]>
  export type AutomationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trigger?: boolean | Automation$triggerArgs<ExtArgs>
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    actions?: boolean | Automation$actionsArgs<ExtArgs>
    automationInstances?: boolean | Automation$automationInstancesArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trigger?: boolean | Automation$triggerArgs<ExtArgs>
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type AutomationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trigger?: boolean | Automation$triggerArgs<ExtArgs>
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $AutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Automation"
    objects: {
      trigger: Prisma.$TriggerPayload<ExtArgs> | null
      subaccount: Prisma.$SubAccountPayload<ExtArgs>
      actions: Prisma.$ActionPayload<ExtArgs>[]
      automationInstances: Prisma.$AutomationInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      triggerId: string | null
      published: boolean
      subAccountId: string
    }, ExtArgs["result"]["automation"]>
    composites: {}
  }

  type AutomationGetPayload<S extends boolean | null | undefined | AutomationDefaultArgs> = $Result.GetResult<Prisma.$AutomationPayload, S>

  type AutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationCountAggregateInputType | true
    }

  export interface AutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Automation'], meta: { name: 'Automation' } }
    /**
     * Find zero or one Automation that matches the filter.
     * @param {AutomationFindUniqueArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationFindUniqueArgs>(args: SelectSubset<T, AutomationFindUniqueArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Automation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationFindUniqueOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Automation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationFindFirstArgs>(args?: SelectSubset<T, AutomationFindFirstArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Automation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automations
     * const automations = await prisma.automation.findMany()
     * 
     * // Get first 10 Automations
     * const automations = await prisma.automation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationWithIdOnly = await prisma.automation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationFindManyArgs>(args?: SelectSubset<T, AutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Automation.
     * @param {AutomationCreateArgs} args - Arguments to create a Automation.
     * @example
     * // Create one Automation
     * const Automation = await prisma.automation.create({
     *   data: {
     *     // ... data to create a Automation
     *   }
     * })
     * 
     */
    create<T extends AutomationCreateArgs>(args: SelectSubset<T, AutomationCreateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Automations.
     * @param {AutomationCreateManyArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationCreateManyArgs>(args?: SelectSubset<T, AutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Automations and returns the data saved in the database.
     * @param {AutomationCreateManyAndReturnArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Automations and only return the `id`
     * const automationWithIdOnly = await prisma.automation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Automation.
     * @param {AutomationDeleteArgs} args - Arguments to delete one Automation.
     * @example
     * // Delete one Automation
     * const Automation = await prisma.automation.delete({
     *   where: {
     *     // ... filter to delete one Automation
     *   }
     * })
     * 
     */
    delete<T extends AutomationDeleteArgs>(args: SelectSubset<T, AutomationDeleteArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Automation.
     * @param {AutomationUpdateArgs} args - Arguments to update one Automation.
     * @example
     * // Update one Automation
     * const automation = await prisma.automation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationUpdateArgs>(args: SelectSubset<T, AutomationUpdateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Automations.
     * @param {AutomationDeleteManyArgs} args - Arguments to filter Automations to delete.
     * @example
     * // Delete a few Automations
     * const { count } = await prisma.automation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationDeleteManyArgs>(args?: SelectSubset<T, AutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationUpdateManyArgs>(args: SelectSubset<T, AutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations and returns the data updated in the database.
     * @param {AutomationUpdateManyAndReturnArgs} args - Arguments to update many Automations.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Automations and only return the `id`
     * const automationWithIdOnly = await prisma.automation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Automation.
     * @param {AutomationUpsertArgs} args - Arguments to update or create a Automation.
     * @example
     * // Update or create a Automation
     * const automation = await prisma.automation.upsert({
     *   create: {
     *     // ... data to create a Automation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automation we want to update
     *   }
     * })
     */
    upsert<T extends AutomationUpsertArgs>(args: SelectSubset<T, AutomationUpsertArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationCountArgs} args - Arguments to filter Automations to count.
     * @example
     * // Count the number of Automations
     * const count = await prisma.automation.count({
     *   where: {
     *     // ... the filter for the Automations we want to count
     *   }
     * })
    **/
    count<T extends AutomationCountArgs>(
      args?: Subset<T, AutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationAggregateArgs>(args: Subset<T, AutomationAggregateArgs>): Prisma.PrismaPromise<GetAutomationAggregateType<T>>

    /**
     * Group by Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationGroupByArgs['orderBy'] }
        : { orderBy?: AutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Automation model
   */
  readonly fields: AutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Automation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trigger<T extends Automation$triggerArgs<ExtArgs> = {}>(args?: Subset<T, Automation$triggerArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subaccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actions<T extends Automation$actionsArgs<ExtArgs> = {}>(args?: Subset<T, Automation$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    automationInstances<T extends Automation$automationInstancesArgs<ExtArgs> = {}>(args?: Subset<T, Automation$automationInstancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Automation model
   */
  interface AutomationFieldRefs {
    readonly id: FieldRef<"Automation", 'String'>
    readonly createdAt: FieldRef<"Automation", 'DateTime'>
    readonly updatedAt: FieldRef<"Automation", 'DateTime'>
    readonly name: FieldRef<"Automation", 'String'>
    readonly triggerId: FieldRef<"Automation", 'String'>
    readonly published: FieldRef<"Automation", 'Boolean'>
    readonly subAccountId: FieldRef<"Automation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Automation findUnique
   */
  export type AutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findUniqueOrThrow
   */
  export type AutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findFirst
   */
  export type AutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findFirstOrThrow
   */
  export type AutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findMany
   */
  export type AutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation create
   */
  export type AutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to create a Automation.
     */
    data: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
  }

  /**
   * Automation createMany
   */
  export type AutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Automation createManyAndReturn
   */
  export type AutomationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Automation update
   */
  export type AutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to update a Automation.
     */
    data: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
    /**
     * Choose, which Automation to update.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation updateMany
   */
  export type AutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
    /**
     * Limit how many Automations to update.
     */
    limit?: number
  }

  /**
   * Automation updateManyAndReturn
   */
  export type AutomationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
    /**
     * Limit how many Automations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Automation upsert
   */
  export type AutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The filter to search for the Automation to update in case it exists.
     */
    where: AutomationWhereUniqueInput
    /**
     * In case the Automation found by the `where` argument doesn't exist, create a new Automation with this data.
     */
    create: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
    /**
     * In case the Automation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
  }

  /**
   * Automation delete
   */
  export type AutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter which Automation to delete.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation deleteMany
   */
  export type AutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to delete
     */
    where?: AutomationWhereInput
    /**
     * Limit how many Automations to delete.
     */
    limit?: number
  }

  /**
   * Automation.trigger
   */
  export type Automation$triggerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    where?: TriggerWhereInput
  }

  /**
   * Automation.actions
   */
  export type Automation$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    cursor?: ActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Automation.automationInstances
   */
  export type Automation$automationInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    where?: AutomationInstanceWhereInput
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    cursor?: AutomationInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * Automation without action
   */
  export type AutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
  }


  /**
   * Model AutomationInstance
   */

  export type AggregateAutomationInstance = {
    _count: AutomationInstanceCountAggregateOutputType | null
    _min: AutomationInstanceMinAggregateOutputType | null
    _max: AutomationInstanceMaxAggregateOutputType | null
  }

  export type AutomationInstanceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    automationId: string | null
    active: boolean | null
  }

  export type AutomationInstanceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    automationId: string | null
    active: boolean | null
  }

  export type AutomationInstanceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    automationId: number
    active: number
    _all: number
  }


  export type AutomationInstanceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
  }

  export type AutomationInstanceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
  }

  export type AutomationInstanceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
    _all?: true
  }

  export type AutomationInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationInstance to aggregate.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationInstances
    **/
    _count?: true | AutomationInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationInstanceMaxAggregateInputType
  }

  export type GetAutomationInstanceAggregateType<T extends AutomationInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationInstance[P]>
      : GetScalarType<T[P], AggregateAutomationInstance[P]>
  }




  export type AutomationInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationInstanceWhereInput
    orderBy?: AutomationInstanceOrderByWithAggregationInput | AutomationInstanceOrderByWithAggregationInput[]
    by: AutomationInstanceScalarFieldEnum[] | AutomationInstanceScalarFieldEnum
    having?: AutomationInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationInstanceCountAggregateInputType | true
    _min?: AutomationInstanceMinAggregateInputType
    _max?: AutomationInstanceMaxAggregateInputType
  }

  export type AutomationInstanceGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    automationId: string
    active: boolean
    _count: AutomationInstanceCountAggregateOutputType | null
    _min: AutomationInstanceMinAggregateOutputType | null
    _max: AutomationInstanceMaxAggregateOutputType | null
  }

  type GetAutomationInstanceGroupByPayload<T extends AutomationInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationInstanceGroupByOutputType[P]>
        }
      >
    >


  export type AutomationInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationInstance"]>

  export type AutomationInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationInstance"]>

  export type AutomationInstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationInstance"]>

  export type AutomationInstanceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
  }

  export type AutomationInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "automationId" | "active", ExtArgs["result"]["automationInstance"]>
  export type AutomationInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }
  export type AutomationInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }
  export type AutomationInstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }

  export type $AutomationInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationInstance"
    objects: {
      automation: Prisma.$AutomationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      automationId: string
      active: boolean
    }, ExtArgs["result"]["automationInstance"]>
    composites: {}
  }

  type AutomationInstanceGetPayload<S extends boolean | null | undefined | AutomationInstanceDefaultArgs> = $Result.GetResult<Prisma.$AutomationInstancePayload, S>

  type AutomationInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationInstanceCountAggregateInputType | true
    }

  export interface AutomationInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationInstance'], meta: { name: 'AutomationInstance' } }
    /**
     * Find zero or one AutomationInstance that matches the filter.
     * @param {AutomationInstanceFindUniqueArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationInstanceFindUniqueArgs>(args: SelectSubset<T, AutomationInstanceFindUniqueArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationInstanceFindUniqueOrThrowArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindFirstArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationInstanceFindFirstArgs>(args?: SelectSubset<T, AutomationInstanceFindFirstArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindFirstOrThrowArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationInstances
     * const automationInstances = await prisma.automationInstance.findMany()
     * 
     * // Get first 10 AutomationInstances
     * const automationInstances = await prisma.automationInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationInstanceWithIdOnly = await prisma.automationInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationInstanceFindManyArgs>(args?: SelectSubset<T, AutomationInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationInstance.
     * @param {AutomationInstanceCreateArgs} args - Arguments to create a AutomationInstance.
     * @example
     * // Create one AutomationInstance
     * const AutomationInstance = await prisma.automationInstance.create({
     *   data: {
     *     // ... data to create a AutomationInstance
     *   }
     * })
     * 
     */
    create<T extends AutomationInstanceCreateArgs>(args: SelectSubset<T, AutomationInstanceCreateArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationInstances.
     * @param {AutomationInstanceCreateManyArgs} args - Arguments to create many AutomationInstances.
     * @example
     * // Create many AutomationInstances
     * const automationInstance = await prisma.automationInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationInstanceCreateManyArgs>(args?: SelectSubset<T, AutomationInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationInstances and returns the data saved in the database.
     * @param {AutomationInstanceCreateManyAndReturnArgs} args - Arguments to create many AutomationInstances.
     * @example
     * // Create many AutomationInstances
     * const automationInstance = await prisma.automationInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationInstances and only return the `id`
     * const automationInstanceWithIdOnly = await prisma.automationInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationInstance.
     * @param {AutomationInstanceDeleteArgs} args - Arguments to delete one AutomationInstance.
     * @example
     * // Delete one AutomationInstance
     * const AutomationInstance = await prisma.automationInstance.delete({
     *   where: {
     *     // ... filter to delete one AutomationInstance
     *   }
     * })
     * 
     */
    delete<T extends AutomationInstanceDeleteArgs>(args: SelectSubset<T, AutomationInstanceDeleteArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationInstance.
     * @param {AutomationInstanceUpdateArgs} args - Arguments to update one AutomationInstance.
     * @example
     * // Update one AutomationInstance
     * const automationInstance = await prisma.automationInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationInstanceUpdateArgs>(args: SelectSubset<T, AutomationInstanceUpdateArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationInstances.
     * @param {AutomationInstanceDeleteManyArgs} args - Arguments to filter AutomationInstances to delete.
     * @example
     * // Delete a few AutomationInstances
     * const { count } = await prisma.automationInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationInstanceDeleteManyArgs>(args?: SelectSubset<T, AutomationInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationInstances
     * const automationInstance = await prisma.automationInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationInstanceUpdateManyArgs>(args: SelectSubset<T, AutomationInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationInstances and returns the data updated in the database.
     * @param {AutomationInstanceUpdateManyAndReturnArgs} args - Arguments to update many AutomationInstances.
     * @example
     * // Update many AutomationInstances
     * const automationInstance = await prisma.automationInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationInstances and only return the `id`
     * const automationInstanceWithIdOnly = await prisma.automationInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationInstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationInstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationInstance.
     * @param {AutomationInstanceUpsertArgs} args - Arguments to update or create a AutomationInstance.
     * @example
     * // Update or create a AutomationInstance
     * const automationInstance = await prisma.automationInstance.upsert({
     *   create: {
     *     // ... data to create a AutomationInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationInstance we want to update
     *   }
     * })
     */
    upsert<T extends AutomationInstanceUpsertArgs>(args: SelectSubset<T, AutomationInstanceUpsertArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceCountArgs} args - Arguments to filter AutomationInstances to count.
     * @example
     * // Count the number of AutomationInstances
     * const count = await prisma.automationInstance.count({
     *   where: {
     *     // ... the filter for the AutomationInstances we want to count
     *   }
     * })
    **/
    count<T extends AutomationInstanceCountArgs>(
      args?: Subset<T, AutomationInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationInstanceAggregateArgs>(args: Subset<T, AutomationInstanceAggregateArgs>): Prisma.PrismaPromise<GetAutomationInstanceAggregateType<T>>

    /**
     * Group by AutomationInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationInstanceGroupByArgs['orderBy'] }
        : { orderBy?: AutomationInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationInstance model
   */
  readonly fields: AutomationInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationInstance model
   */
  interface AutomationInstanceFieldRefs {
    readonly id: FieldRef<"AutomationInstance", 'String'>
    readonly createdAt: FieldRef<"AutomationInstance", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationInstance", 'DateTime'>
    readonly automationId: FieldRef<"AutomationInstance", 'String'>
    readonly active: FieldRef<"AutomationInstance", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AutomationInstance findUnique
   */
  export type AutomationInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance findUniqueOrThrow
   */
  export type AutomationInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance findFirst
   */
  export type AutomationInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationInstances.
     */
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance findFirstOrThrow
   */
  export type AutomationInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationInstances.
     */
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance findMany
   */
  export type AutomationInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstances to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance create
   */
  export type AutomationInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationInstance.
     */
    data: XOR<AutomationInstanceCreateInput, AutomationInstanceUncheckedCreateInput>
  }

  /**
   * AutomationInstance createMany
   */
  export type AutomationInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationInstances.
     */
    data: AutomationInstanceCreateManyInput | AutomationInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationInstance createManyAndReturn
   */
  export type AutomationInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationInstances.
     */
    data: AutomationInstanceCreateManyInput | AutomationInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationInstance update
   */
  export type AutomationInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationInstance.
     */
    data: XOR<AutomationInstanceUpdateInput, AutomationInstanceUncheckedUpdateInput>
    /**
     * Choose, which AutomationInstance to update.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance updateMany
   */
  export type AutomationInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationInstances.
     */
    data: XOR<AutomationInstanceUpdateManyMutationInput, AutomationInstanceUncheckedUpdateManyInput>
    /**
     * Filter which AutomationInstances to update
     */
    where?: AutomationInstanceWhereInput
    /**
     * Limit how many AutomationInstances to update.
     */
    limit?: number
  }

  /**
   * AutomationInstance updateManyAndReturn
   */
  export type AutomationInstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * The data used to update AutomationInstances.
     */
    data: XOR<AutomationInstanceUpdateManyMutationInput, AutomationInstanceUncheckedUpdateManyInput>
    /**
     * Filter which AutomationInstances to update
     */
    where?: AutomationInstanceWhereInput
    /**
     * Limit how many AutomationInstances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationInstance upsert
   */
  export type AutomationInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationInstance to update in case it exists.
     */
    where: AutomationInstanceWhereUniqueInput
    /**
     * In case the AutomationInstance found by the `where` argument doesn't exist, create a new AutomationInstance with this data.
     */
    create: XOR<AutomationInstanceCreateInput, AutomationInstanceUncheckedCreateInput>
    /**
     * In case the AutomationInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationInstanceUpdateInput, AutomationInstanceUncheckedUpdateInput>
  }

  /**
   * AutomationInstance delete
   */
  export type AutomationInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter which AutomationInstance to delete.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance deleteMany
   */
  export type AutomationInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationInstances to delete
     */
    where?: AutomationInstanceWhereInput
    /**
     * Limit how many AutomationInstances to delete.
     */
    limit?: number
  }

  /**
   * AutomationInstance without action
   */
  export type AutomationInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */

  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    order: number | null
  }

  export type ActionSumAggregateOutputType = {
    order: number | null
  }

  export type ActionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    order: number | null
    automationId: string | null
    laneId: string | null
    type: $Enums.ActionType | null
  }

  export type ActionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    order: number | null
    automationId: string | null
    laneId: string | null
    type: $Enums.ActionType | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    order: number
    automationId: number
    laneId: number
    type: number
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    order?: true
  }

  export type ActionSumAggregateInputType = {
    order?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    order?: true
    automationId?: true
    laneId?: true
    type?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    order?: true
    automationId?: true
    laneId?: true
    type?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    order?: true
    automationId?: true
    laneId?: true
    type?: true
    _all?: true
  }

  export type ActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action to aggregate.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithAggregationInput | ActionOrderByWithAggregationInput[]
    by: ActionScalarFieldEnum[] | ActionScalarFieldEnum
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _avg?: ActionAvgAggregateInputType
    _sum?: ActionSumAggregateInputType
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }

  export type ActionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    order: number
    automationId: string
    laneId: string
    type: $Enums.ActionType
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    order?: boolean
    automationId?: boolean
    laneId?: boolean
    type?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    order?: boolean
    automationId?: boolean
    laneId?: boolean
    type?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    order?: boolean
    automationId?: boolean
    laneId?: boolean
    type?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    order?: boolean
    automationId?: boolean
    laneId?: boolean
    type?: boolean
  }

  export type ActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "order" | "automationId" | "laneId" | "type", ExtArgs["result"]["action"]>
  export type ActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }
  export type ActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }
  export type ActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }

  export type $ActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action"
    objects: {
      automation: Prisma.$AutomationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      order: number
      automationId: string
      laneId: string
      type: $Enums.ActionType
    }, ExtArgs["result"]["action"]>
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>

  type ActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionCountAggregateInputType | true
    }

  export interface ActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action'], meta: { name: 'Action' } }
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionFindUniqueArgs>(args: SelectSubset<T, ActionFindUniqueArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Action that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionFindFirstArgs>(args?: SelectSubset<T, ActionFindFirstArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionFindManyArgs>(args?: SelectSubset<T, ActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
     */
    create<T extends ActionCreateArgs>(args: SelectSubset<T, ActionCreateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Actions.
     * @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionCreateManyArgs>(args?: SelectSubset<T, ActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actions and returns the data saved in the database.
     * @param {ActionCreateManyAndReturnArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
     */
    delete<T extends ActionDeleteArgs>(args: SelectSubset<T, ActionDeleteArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionUpdateArgs>(args: SelectSubset<T, ActionUpdateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDeleteManyArgs>(args?: SelectSubset<T, ActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionUpdateManyArgs>(args: SelectSubset<T, ActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions and returns the data updated in the database.
     * @param {ActionUpdateManyAndReturnArgs} args - Arguments to update many Actions.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
     */
    upsert<T extends ActionUpsertArgs>(args: SelectSubset<T, ActionUpsertArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Prisma.PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action model
   */
  readonly fields: ActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action model
   */
  interface ActionFieldRefs {
    readonly id: FieldRef<"Action", 'String'>
    readonly createdAt: FieldRef<"Action", 'DateTime'>
    readonly updatedAt: FieldRef<"Action", 'DateTime'>
    readonly name: FieldRef<"Action", 'String'>
    readonly order: FieldRef<"Action", 'Int'>
    readonly automationId: FieldRef<"Action", 'String'>
    readonly laneId: FieldRef<"Action", 'String'>
    readonly type: FieldRef<"Action", 'ActionType'>
  }
    

  // Custom InputTypes
  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findMany
   */
  export type ActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action create
   */
  export type ActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to create a Action.
     */
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }

  /**
   * Action createMany
   */
  export type ActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action createManyAndReturn
   */
  export type ActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Action update
   */
  export type ActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to update a Action.
     */
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action updateManyAndReturn
   */
  export type ActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Action upsert
   */
  export type ActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The filter to search for the Action to update in case it exists.
     */
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     */
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }

  /**
   * Action delete
   */
  export type ActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter which Action to delete.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to delete.
     */
    limit?: number
  }

  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    email: string | null
    subAccountId: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    email: string | null
    subAccountId: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    email: number
    subAccountId: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    subAccountId?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    subAccountId?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    subAccountId?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    email: string
    subAccountId: string
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    subAccountId?: boolean
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    tickets?: boolean | Contact$ticketsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    subAccountId?: boolean
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    subAccountId?: boolean
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    subAccountId?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "email" | "subAccountId", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    tickets?: boolean | Contact$ticketsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      subaccount: Prisma.$SubAccountPayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      email: string
      subAccountId: string
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subaccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tickets<T extends Contact$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly subAccountId: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.tickets
   */
  export type Contact$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: string | null
    name: string | null
    link: string | null
    subAccountId: string | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: string | null
    name: string | null
    link: string | null
    subAccountId: string | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    type: number
    name: number
    link: number
    subAccountId: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    type: string | null
    name: string
    link: string
    subAccountId: string
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "type" | "name" | "link" | "subAccountId", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      subAccount: Prisma.$SubAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      type: string | null
      name: string
      link: string
      subAccountId: string
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
    readonly type: FieldRef<"Media", 'String'>
    readonly name: FieldRef<"Media", 'String'>
    readonly link: FieldRef<"Media", 'String'>
    readonly subAccountId: FieldRef<"Media", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Funnel
   */

  export type AggregateFunnel = {
    _count: FunnelCountAggregateOutputType | null
    _min: FunnelMinAggregateOutputType | null
    _max: FunnelMaxAggregateOutputType | null
  }

  export type FunnelMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    published: boolean | null
    subDomainName: string | null
    favicon: string | null
    subAccountId: string | null
    liveProducts: string | null
  }

  export type FunnelMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    published: boolean | null
    subDomainName: string | null
    favicon: string | null
    subAccountId: string | null
    liveProducts: string | null
  }

  export type FunnelCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    published: number
    subDomainName: number
    favicon: number
    subAccountId: number
    liveProducts: number
    _all: number
  }


  export type FunnelMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
  }

  export type FunnelMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
  }

  export type FunnelCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
    _all?: true
  }

  export type FunnelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funnel to aggregate.
     */
    where?: FunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Funnels
    **/
    _count?: true | FunnelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunnelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunnelMaxAggregateInputType
  }

  export type GetFunnelAggregateType<T extends FunnelAggregateArgs> = {
        [P in keyof T & keyof AggregateFunnel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunnel[P]>
      : GetScalarType<T[P], AggregateFunnel[P]>
  }




  export type FunnelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelWhereInput
    orderBy?: FunnelOrderByWithAggregationInput | FunnelOrderByWithAggregationInput[]
    by: FunnelScalarFieldEnum[] | FunnelScalarFieldEnum
    having?: FunnelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunnelCountAggregateInputType | true
    _min?: FunnelMinAggregateInputType
    _max?: FunnelMaxAggregateInputType
  }

  export type FunnelGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    published: boolean
    subDomainName: string | null
    favicon: string | null
    subAccountId: string
    liveProducts: string | null
    _count: FunnelCountAggregateOutputType | null
    _min: FunnelMinAggregateOutputType | null
    _max: FunnelMaxAggregateOutputType | null
  }

  type GetFunnelGroupByPayload<T extends FunnelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunnelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunnelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunnelGroupByOutputType[P]>
            : GetScalarType<T[P], FunnelGroupByOutputType[P]>
        }
      >
    >


  export type FunnelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    funnelPages?: boolean | Funnel$funnelPagesArgs<ExtArgs>
    className?: boolean | Funnel$classNameArgs<ExtArgs>
    _count?: boolean | FunnelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnel"]>

  export type FunnelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnel"]>

  export type FunnelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnel"]>

  export type FunnelSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
  }

  export type FunnelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "description" | "published" | "subDomainName" | "favicon" | "subAccountId" | "liveProducts", ExtArgs["result"]["funnel"]>
  export type FunnelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    funnelPages?: boolean | Funnel$funnelPagesArgs<ExtArgs>
    className?: boolean | Funnel$classNameArgs<ExtArgs>
    _count?: boolean | FunnelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FunnelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }
  export type FunnelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $FunnelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Funnel"
    objects: {
      subAccount: Prisma.$SubAccountPayload<ExtArgs>
      funnelPages: Prisma.$FunnelPagePayload<ExtArgs>[]
      className: Prisma.$ClassNamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      published: boolean
      subDomainName: string | null
      favicon: string | null
      subAccountId: string
      liveProducts: string | null
    }, ExtArgs["result"]["funnel"]>
    composites: {}
  }

  type FunnelGetPayload<S extends boolean | null | undefined | FunnelDefaultArgs> = $Result.GetResult<Prisma.$FunnelPayload, S>

  type FunnelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FunnelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FunnelCountAggregateInputType | true
    }

  export interface FunnelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Funnel'], meta: { name: 'Funnel' } }
    /**
     * Find zero or one Funnel that matches the filter.
     * @param {FunnelFindUniqueArgs} args - Arguments to find a Funnel
     * @example
     * // Get one Funnel
     * const funnel = await prisma.funnel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunnelFindUniqueArgs>(args: SelectSubset<T, FunnelFindUniqueArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Funnel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FunnelFindUniqueOrThrowArgs} args - Arguments to find a Funnel
     * @example
     * // Get one Funnel
     * const funnel = await prisma.funnel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunnelFindUniqueOrThrowArgs>(args: SelectSubset<T, FunnelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Funnel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelFindFirstArgs} args - Arguments to find a Funnel
     * @example
     * // Get one Funnel
     * const funnel = await prisma.funnel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunnelFindFirstArgs>(args?: SelectSubset<T, FunnelFindFirstArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Funnel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelFindFirstOrThrowArgs} args - Arguments to find a Funnel
     * @example
     * // Get one Funnel
     * const funnel = await prisma.funnel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunnelFindFirstOrThrowArgs>(args?: SelectSubset<T, FunnelFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Funnels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funnels
     * const funnels = await prisma.funnel.findMany()
     * 
     * // Get first 10 Funnels
     * const funnels = await prisma.funnel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funnelWithIdOnly = await prisma.funnel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunnelFindManyArgs>(args?: SelectSubset<T, FunnelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Funnel.
     * @param {FunnelCreateArgs} args - Arguments to create a Funnel.
     * @example
     * // Create one Funnel
     * const Funnel = await prisma.funnel.create({
     *   data: {
     *     // ... data to create a Funnel
     *   }
     * })
     * 
     */
    create<T extends FunnelCreateArgs>(args: SelectSubset<T, FunnelCreateArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Funnels.
     * @param {FunnelCreateManyArgs} args - Arguments to create many Funnels.
     * @example
     * // Create many Funnels
     * const funnel = await prisma.funnel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunnelCreateManyArgs>(args?: SelectSubset<T, FunnelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Funnels and returns the data saved in the database.
     * @param {FunnelCreateManyAndReturnArgs} args - Arguments to create many Funnels.
     * @example
     * // Create many Funnels
     * const funnel = await prisma.funnel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Funnels and only return the `id`
     * const funnelWithIdOnly = await prisma.funnel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FunnelCreateManyAndReturnArgs>(args?: SelectSubset<T, FunnelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Funnel.
     * @param {FunnelDeleteArgs} args - Arguments to delete one Funnel.
     * @example
     * // Delete one Funnel
     * const Funnel = await prisma.funnel.delete({
     *   where: {
     *     // ... filter to delete one Funnel
     *   }
     * })
     * 
     */
    delete<T extends FunnelDeleteArgs>(args: SelectSubset<T, FunnelDeleteArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Funnel.
     * @param {FunnelUpdateArgs} args - Arguments to update one Funnel.
     * @example
     * // Update one Funnel
     * const funnel = await prisma.funnel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunnelUpdateArgs>(args: SelectSubset<T, FunnelUpdateArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Funnels.
     * @param {FunnelDeleteManyArgs} args - Arguments to filter Funnels to delete.
     * @example
     * // Delete a few Funnels
     * const { count } = await prisma.funnel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunnelDeleteManyArgs>(args?: SelectSubset<T, FunnelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funnels
     * const funnel = await prisma.funnel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunnelUpdateManyArgs>(args: SelectSubset<T, FunnelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funnels and returns the data updated in the database.
     * @param {FunnelUpdateManyAndReturnArgs} args - Arguments to update many Funnels.
     * @example
     * // Update many Funnels
     * const funnel = await prisma.funnel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Funnels and only return the `id`
     * const funnelWithIdOnly = await prisma.funnel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FunnelUpdateManyAndReturnArgs>(args: SelectSubset<T, FunnelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Funnel.
     * @param {FunnelUpsertArgs} args - Arguments to update or create a Funnel.
     * @example
     * // Update or create a Funnel
     * const funnel = await prisma.funnel.upsert({
     *   create: {
     *     // ... data to create a Funnel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Funnel we want to update
     *   }
     * })
     */
    upsert<T extends FunnelUpsertArgs>(args: SelectSubset<T, FunnelUpsertArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelCountArgs} args - Arguments to filter Funnels to count.
     * @example
     * // Count the number of Funnels
     * const count = await prisma.funnel.count({
     *   where: {
     *     // ... the filter for the Funnels we want to count
     *   }
     * })
    **/
    count<T extends FunnelCountArgs>(
      args?: Subset<T, FunnelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunnelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Funnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunnelAggregateArgs>(args: Subset<T, FunnelAggregateArgs>): Prisma.PrismaPromise<GetFunnelAggregateType<T>>

    /**
     * Group by Funnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunnelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunnelGroupByArgs['orderBy'] }
        : { orderBy?: FunnelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunnelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunnelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Funnel model
   */
  readonly fields: FunnelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Funnel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunnelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    funnelPages<T extends Funnel$funnelPagesArgs<ExtArgs> = {}>(args?: Subset<T, Funnel$funnelPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    className<T extends Funnel$classNameArgs<ExtArgs> = {}>(args?: Subset<T, Funnel$classNameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Funnel model
   */
  interface FunnelFieldRefs {
    readonly id: FieldRef<"Funnel", 'String'>
    readonly createdAt: FieldRef<"Funnel", 'DateTime'>
    readonly updatedAt: FieldRef<"Funnel", 'DateTime'>
    readonly name: FieldRef<"Funnel", 'String'>
    readonly description: FieldRef<"Funnel", 'String'>
    readonly published: FieldRef<"Funnel", 'Boolean'>
    readonly subDomainName: FieldRef<"Funnel", 'String'>
    readonly favicon: FieldRef<"Funnel", 'String'>
    readonly subAccountId: FieldRef<"Funnel", 'String'>
    readonly liveProducts: FieldRef<"Funnel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Funnel findUnique
   */
  export type FunnelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnel to fetch.
     */
    where: FunnelWhereUniqueInput
  }

  /**
   * Funnel findUniqueOrThrow
   */
  export type FunnelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnel to fetch.
     */
    where: FunnelWhereUniqueInput
  }

  /**
   * Funnel findFirst
   */
  export type FunnelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnel to fetch.
     */
    where?: FunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funnels.
     */
    cursor?: FunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funnels.
     */
    distinct?: FunnelScalarFieldEnum | FunnelScalarFieldEnum[]
  }

  /**
   * Funnel findFirstOrThrow
   */
  export type FunnelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnel to fetch.
     */
    where?: FunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funnels.
     */
    cursor?: FunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funnels.
     */
    distinct?: FunnelScalarFieldEnum | FunnelScalarFieldEnum[]
  }

  /**
   * Funnel findMany
   */
  export type FunnelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where?: FunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Funnels.
     */
    cursor?: FunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    distinct?: FunnelScalarFieldEnum | FunnelScalarFieldEnum[]
  }

  /**
   * Funnel create
   */
  export type FunnelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * The data needed to create a Funnel.
     */
    data: XOR<FunnelCreateInput, FunnelUncheckedCreateInput>
  }

  /**
   * Funnel createMany
   */
  export type FunnelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Funnels.
     */
    data: FunnelCreateManyInput | FunnelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Funnel createManyAndReturn
   */
  export type FunnelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * The data used to create many Funnels.
     */
    data: FunnelCreateManyInput | FunnelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Funnel update
   */
  export type FunnelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * The data needed to update a Funnel.
     */
    data: XOR<FunnelUpdateInput, FunnelUncheckedUpdateInput>
    /**
     * Choose, which Funnel to update.
     */
    where: FunnelWhereUniqueInput
  }

  /**
   * Funnel updateMany
   */
  export type FunnelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Funnels.
     */
    data: XOR<FunnelUpdateManyMutationInput, FunnelUncheckedUpdateManyInput>
    /**
     * Filter which Funnels to update
     */
    where?: FunnelWhereInput
    /**
     * Limit how many Funnels to update.
     */
    limit?: number
  }

  /**
   * Funnel updateManyAndReturn
   */
  export type FunnelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * The data used to update Funnels.
     */
    data: XOR<FunnelUpdateManyMutationInput, FunnelUncheckedUpdateManyInput>
    /**
     * Filter which Funnels to update
     */
    where?: FunnelWhereInput
    /**
     * Limit how many Funnels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Funnel upsert
   */
  export type FunnelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * The filter to search for the Funnel to update in case it exists.
     */
    where: FunnelWhereUniqueInput
    /**
     * In case the Funnel found by the `where` argument doesn't exist, create a new Funnel with this data.
     */
    create: XOR<FunnelCreateInput, FunnelUncheckedCreateInput>
    /**
     * In case the Funnel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunnelUpdateInput, FunnelUncheckedUpdateInput>
  }

  /**
   * Funnel delete
   */
  export type FunnelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter which Funnel to delete.
     */
    where: FunnelWhereUniqueInput
  }

  /**
   * Funnel deleteMany
   */
  export type FunnelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funnels to delete
     */
    where?: FunnelWhereInput
    /**
     * Limit how many Funnels to delete.
     */
    limit?: number
  }

  /**
   * Funnel.funnelPages
   */
  export type Funnel$funnelPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    where?: FunnelPageWhereInput
    orderBy?: FunnelPageOrderByWithRelationInput | FunnelPageOrderByWithRelationInput[]
    cursor?: FunnelPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunnelPageScalarFieldEnum | FunnelPageScalarFieldEnum[]
  }

  /**
   * Funnel.className
   */
  export type Funnel$classNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    cursor?: ClassNameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * Funnel without action
   */
  export type FunnelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnel
     */
    omit?: FunnelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
  }


  /**
   * Model ClassName
   */

  export type AggregateClassName = {
    _count: ClassNameCountAggregateOutputType | null
    _min: ClassNameMinAggregateOutputType | null
    _max: ClassNameMaxAggregateOutputType | null
  }

  export type ClassNameMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    color: string | null
    funnelId: string | null
    customData: string | null
  }

  export type ClassNameMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    color: string | null
    funnelId: string | null
    customData: string | null
  }

  export type ClassNameCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    color: number
    funnelId: number
    customData: number
    _all: number
  }


  export type ClassNameMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    color?: true
    funnelId?: true
    customData?: true
  }

  export type ClassNameMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    color?: true
    funnelId?: true
    customData?: true
  }

  export type ClassNameCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    color?: true
    funnelId?: true
    customData?: true
    _all?: true
  }

  export type ClassNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassName to aggregate.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassNames
    **/
    _count?: true | ClassNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassNameMaxAggregateInputType
  }

  export type GetClassNameAggregateType<T extends ClassNameAggregateArgs> = {
        [P in keyof T & keyof AggregateClassName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassName[P]>
      : GetScalarType<T[P], AggregateClassName[P]>
  }




  export type ClassNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithAggregationInput | ClassNameOrderByWithAggregationInput[]
    by: ClassNameScalarFieldEnum[] | ClassNameScalarFieldEnum
    having?: ClassNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassNameCountAggregateInputType | true
    _min?: ClassNameMinAggregateInputType
    _max?: ClassNameMaxAggregateInputType
  }

  export type ClassNameGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    color: string
    funnelId: string
    customData: string | null
    _count: ClassNameCountAggregateOutputType | null
    _min: ClassNameMinAggregateOutputType | null
    _max: ClassNameMaxAggregateOutputType | null
  }

  type GetClassNameGroupByPayload<T extends ClassNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassNameGroupByOutputType[P]>
            : GetScalarType<T[P], ClassNameGroupByOutputType[P]>
        }
      >
    >


  export type ClassNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    color?: boolean
    funnelId?: boolean
    customData?: boolean
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["className"]>

  export type ClassNameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    color?: boolean
    funnelId?: boolean
    customData?: boolean
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["className"]>

  export type ClassNameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    color?: boolean
    funnelId?: boolean
    customData?: boolean
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["className"]>

  export type ClassNameSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    color?: boolean
    funnelId?: boolean
    customData?: boolean
  }

  export type ClassNameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "color" | "funnelId" | "customData", ExtArgs["result"]["className"]>
  export type ClassNameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }
  export type ClassNameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }
  export type ClassNameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }

  export type $ClassNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassName"
    objects: {
      funnel: Prisma.$FunnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      color: string
      funnelId: string
      customData: string | null
    }, ExtArgs["result"]["className"]>
    composites: {}
  }

  type ClassNameGetPayload<S extends boolean | null | undefined | ClassNameDefaultArgs> = $Result.GetResult<Prisma.$ClassNamePayload, S>

  type ClassNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassNameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassNameCountAggregateInputType | true
    }

  export interface ClassNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassName'], meta: { name: 'ClassName' } }
    /**
     * Find zero or one ClassName that matches the filter.
     * @param {ClassNameFindUniqueArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassNameFindUniqueArgs>(args: SelectSubset<T, ClassNameFindUniqueArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassName that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassNameFindUniqueOrThrowArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassNameFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassNameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindFirstArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassNameFindFirstArgs>(args?: SelectSubset<T, ClassNameFindFirstArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindFirstOrThrowArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassNameFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassNameFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassNames
     * const classNames = await prisma.className.findMany()
     * 
     * // Get first 10 ClassNames
     * const classNames = await prisma.className.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classNameWithIdOnly = await prisma.className.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassNameFindManyArgs>(args?: SelectSubset<T, ClassNameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassName.
     * @param {ClassNameCreateArgs} args - Arguments to create a ClassName.
     * @example
     * // Create one ClassName
     * const ClassName = await prisma.className.create({
     *   data: {
     *     // ... data to create a ClassName
     *   }
     * })
     * 
     */
    create<T extends ClassNameCreateArgs>(args: SelectSubset<T, ClassNameCreateArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassNames.
     * @param {ClassNameCreateManyArgs} args - Arguments to create many ClassNames.
     * @example
     * // Create many ClassNames
     * const className = await prisma.className.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassNameCreateManyArgs>(args?: SelectSubset<T, ClassNameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassNames and returns the data saved in the database.
     * @param {ClassNameCreateManyAndReturnArgs} args - Arguments to create many ClassNames.
     * @example
     * // Create many ClassNames
     * const className = await prisma.className.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassNames and only return the `id`
     * const classNameWithIdOnly = await prisma.className.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassNameCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassNameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassName.
     * @param {ClassNameDeleteArgs} args - Arguments to delete one ClassName.
     * @example
     * // Delete one ClassName
     * const ClassName = await prisma.className.delete({
     *   where: {
     *     // ... filter to delete one ClassName
     *   }
     * })
     * 
     */
    delete<T extends ClassNameDeleteArgs>(args: SelectSubset<T, ClassNameDeleteArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassName.
     * @param {ClassNameUpdateArgs} args - Arguments to update one ClassName.
     * @example
     * // Update one ClassName
     * const className = await prisma.className.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassNameUpdateArgs>(args: SelectSubset<T, ClassNameUpdateArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassNames.
     * @param {ClassNameDeleteManyArgs} args - Arguments to filter ClassNames to delete.
     * @example
     * // Delete a few ClassNames
     * const { count } = await prisma.className.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassNameDeleteManyArgs>(args?: SelectSubset<T, ClassNameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassNames
     * const className = await prisma.className.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassNameUpdateManyArgs>(args: SelectSubset<T, ClassNameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassNames and returns the data updated in the database.
     * @param {ClassNameUpdateManyAndReturnArgs} args - Arguments to update many ClassNames.
     * @example
     * // Update many ClassNames
     * const className = await prisma.className.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassNames and only return the `id`
     * const classNameWithIdOnly = await prisma.className.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassNameUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassNameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassName.
     * @param {ClassNameUpsertArgs} args - Arguments to update or create a ClassName.
     * @example
     * // Update or create a ClassName
     * const className = await prisma.className.upsert({
     *   create: {
     *     // ... data to create a ClassName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassName we want to update
     *   }
     * })
     */
    upsert<T extends ClassNameUpsertArgs>(args: SelectSubset<T, ClassNameUpsertArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameCountArgs} args - Arguments to filter ClassNames to count.
     * @example
     * // Count the number of ClassNames
     * const count = await prisma.className.count({
     *   where: {
     *     // ... the filter for the ClassNames we want to count
     *   }
     * })
    **/
    count<T extends ClassNameCountArgs>(
      args?: Subset<T, ClassNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassNameAggregateArgs>(args: Subset<T, ClassNameAggregateArgs>): Prisma.PrismaPromise<GetClassNameAggregateType<T>>

    /**
     * Group by ClassName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassNameGroupByArgs['orderBy'] }
        : { orderBy?: ClassNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassName model
   */
  readonly fields: ClassNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    funnel<T extends FunnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FunnelDefaultArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassName model
   */
  interface ClassNameFieldRefs {
    readonly id: FieldRef<"ClassName", 'String'>
    readonly createdAt: FieldRef<"ClassName", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassName", 'DateTime'>
    readonly name: FieldRef<"ClassName", 'String'>
    readonly color: FieldRef<"ClassName", 'String'>
    readonly funnelId: FieldRef<"ClassName", 'String'>
    readonly customData: FieldRef<"ClassName", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassName findUnique
   */
  export type ClassNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName findUniqueOrThrow
   */
  export type ClassNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName findFirst
   */
  export type ClassNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassNames.
     */
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName findFirstOrThrow
   */
  export type ClassNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassNames.
     */
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName findMany
   */
  export type ClassNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassNames to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName create
   */
  export type ClassNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassName.
     */
    data: XOR<ClassNameCreateInput, ClassNameUncheckedCreateInput>
  }

  /**
   * ClassName createMany
   */
  export type ClassNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassNames.
     */
    data: ClassNameCreateManyInput | ClassNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassName createManyAndReturn
   */
  export type ClassNameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * The data used to create many ClassNames.
     */
    data: ClassNameCreateManyInput | ClassNameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassName update
   */
  export type ClassNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassName.
     */
    data: XOR<ClassNameUpdateInput, ClassNameUncheckedUpdateInput>
    /**
     * Choose, which ClassName to update.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName updateMany
   */
  export type ClassNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassNames.
     */
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyInput>
    /**
     * Filter which ClassNames to update
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to update.
     */
    limit?: number
  }

  /**
   * ClassName updateManyAndReturn
   */
  export type ClassNameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * The data used to update ClassNames.
     */
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyInput>
    /**
     * Filter which ClassNames to update
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassName upsert
   */
  export type ClassNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassName to update in case it exists.
     */
    where: ClassNameWhereUniqueInput
    /**
     * In case the ClassName found by the `where` argument doesn't exist, create a new ClassName with this data.
     */
    create: XOR<ClassNameCreateInput, ClassNameUncheckedCreateInput>
    /**
     * In case the ClassName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassNameUpdateInput, ClassNameUncheckedUpdateInput>
  }

  /**
   * ClassName delete
   */
  export type ClassNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter which ClassName to delete.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName deleteMany
   */
  export type ClassNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassNames to delete
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to delete.
     */
    limit?: number
  }

  /**
   * ClassName without action
   */
  export type ClassNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
  }


  /**
   * Model FunnelPage
   */

  export type AggregateFunnelPage = {
    _count: FunnelPageCountAggregateOutputType | null
    _avg: FunnelPageAvgAggregateOutputType | null
    _sum: FunnelPageSumAggregateOutputType | null
    _min: FunnelPageMinAggregateOutputType | null
    _max: FunnelPageMaxAggregateOutputType | null
  }

  export type FunnelPageAvgAggregateOutputType = {
    visits: number | null
    order: number | null
  }

  export type FunnelPageSumAggregateOutputType = {
    visits: number | null
    order: number | null
  }

  export type FunnelPageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    pathName: string | null
    visits: number | null
    content: string | null
    order: number | null
    previewImage: string | null
    funnelId: string | null
  }

  export type FunnelPageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    pathName: string | null
    visits: number | null
    content: string | null
    order: number | null
    previewImage: string | null
    funnelId: string | null
  }

  export type FunnelPageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    pathName: number
    visits: number
    content: number
    order: number
    previewImage: number
    funnelId: number
    _all: number
  }


  export type FunnelPageAvgAggregateInputType = {
    visits?: true
    order?: true
  }

  export type FunnelPageSumAggregateInputType = {
    visits?: true
    order?: true
  }

  export type FunnelPageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    pathName?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
  }

  export type FunnelPageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    pathName?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
  }

  export type FunnelPageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    pathName?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
    _all?: true
  }

  export type FunnelPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunnelPage to aggregate.
     */
    where?: FunnelPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelPages to fetch.
     */
    orderBy?: FunnelPageOrderByWithRelationInput | FunnelPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunnelPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FunnelPages
    **/
    _count?: true | FunnelPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FunnelPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FunnelPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunnelPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunnelPageMaxAggregateInputType
  }

  export type GetFunnelPageAggregateType<T extends FunnelPageAggregateArgs> = {
        [P in keyof T & keyof AggregateFunnelPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunnelPage[P]>
      : GetScalarType<T[P], AggregateFunnelPage[P]>
  }




  export type FunnelPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelPageWhereInput
    orderBy?: FunnelPageOrderByWithAggregationInput | FunnelPageOrderByWithAggregationInput[]
    by: FunnelPageScalarFieldEnum[] | FunnelPageScalarFieldEnum
    having?: FunnelPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunnelPageCountAggregateInputType | true
    _avg?: FunnelPageAvgAggregateInputType
    _sum?: FunnelPageSumAggregateInputType
    _min?: FunnelPageMinAggregateInputType
    _max?: FunnelPageMaxAggregateInputType
  }

  export type FunnelPageGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    pathName: string
    visits: number
    content: string | null
    order: number
    previewImage: string | null
    funnelId: string
    _count: FunnelPageCountAggregateOutputType | null
    _avg: FunnelPageAvgAggregateOutputType | null
    _sum: FunnelPageSumAggregateOutputType | null
    _min: FunnelPageMinAggregateOutputType | null
    _max: FunnelPageMaxAggregateOutputType | null
  }

  type GetFunnelPageGroupByPayload<T extends FunnelPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunnelPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunnelPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunnelPageGroupByOutputType[P]>
            : GetScalarType<T[P], FunnelPageGroupByOutputType[P]>
        }
      >
    >


  export type FunnelPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    pathName?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelPage"]>

  export type FunnelPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    pathName?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelPage"]>

  export type FunnelPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    pathName?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelPage"]>

  export type FunnelPageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    pathName?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
  }

  export type FunnelPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "pathName" | "visits" | "content" | "order" | "previewImage" | "funnelId", ExtArgs["result"]["funnelPage"]>
  export type FunnelPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }
  export type FunnelPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }
  export type FunnelPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }

  export type $FunnelPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FunnelPage"
    objects: {
      funnel: Prisma.$FunnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      pathName: string
      visits: number
      content: string | null
      order: number
      previewImage: string | null
      funnelId: string
    }, ExtArgs["result"]["funnelPage"]>
    composites: {}
  }

  type FunnelPageGetPayload<S extends boolean | null | undefined | FunnelPageDefaultArgs> = $Result.GetResult<Prisma.$FunnelPagePayload, S>

  type FunnelPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FunnelPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FunnelPageCountAggregateInputType | true
    }

  export interface FunnelPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FunnelPage'], meta: { name: 'FunnelPage' } }
    /**
     * Find zero or one FunnelPage that matches the filter.
     * @param {FunnelPageFindUniqueArgs} args - Arguments to find a FunnelPage
     * @example
     * // Get one FunnelPage
     * const funnelPage = await prisma.funnelPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunnelPageFindUniqueArgs>(args: SelectSubset<T, FunnelPageFindUniqueArgs<ExtArgs>>): Prisma__FunnelPageClient<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FunnelPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FunnelPageFindUniqueOrThrowArgs} args - Arguments to find a FunnelPage
     * @example
     * // Get one FunnelPage
     * const funnelPage = await prisma.funnelPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunnelPageFindUniqueOrThrowArgs>(args: SelectSubset<T, FunnelPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunnelPageClient<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunnelPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPageFindFirstArgs} args - Arguments to find a FunnelPage
     * @example
     * // Get one FunnelPage
     * const funnelPage = await prisma.funnelPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunnelPageFindFirstArgs>(args?: SelectSubset<T, FunnelPageFindFirstArgs<ExtArgs>>): Prisma__FunnelPageClient<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunnelPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPageFindFirstOrThrowArgs} args - Arguments to find a FunnelPage
     * @example
     * // Get one FunnelPage
     * const funnelPage = await prisma.funnelPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunnelPageFindFirstOrThrowArgs>(args?: SelectSubset<T, FunnelPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunnelPageClient<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FunnelPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FunnelPages
     * const funnelPages = await prisma.funnelPage.findMany()
     * 
     * // Get first 10 FunnelPages
     * const funnelPages = await prisma.funnelPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funnelPageWithIdOnly = await prisma.funnelPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunnelPageFindManyArgs>(args?: SelectSubset<T, FunnelPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FunnelPage.
     * @param {FunnelPageCreateArgs} args - Arguments to create a FunnelPage.
     * @example
     * // Create one FunnelPage
     * const FunnelPage = await prisma.funnelPage.create({
     *   data: {
     *     // ... data to create a FunnelPage
     *   }
     * })
     * 
     */
    create<T extends FunnelPageCreateArgs>(args: SelectSubset<T, FunnelPageCreateArgs<ExtArgs>>): Prisma__FunnelPageClient<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FunnelPages.
     * @param {FunnelPageCreateManyArgs} args - Arguments to create many FunnelPages.
     * @example
     * // Create many FunnelPages
     * const funnelPage = await prisma.funnelPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunnelPageCreateManyArgs>(args?: SelectSubset<T, FunnelPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FunnelPages and returns the data saved in the database.
     * @param {FunnelPageCreateManyAndReturnArgs} args - Arguments to create many FunnelPages.
     * @example
     * // Create many FunnelPages
     * const funnelPage = await prisma.funnelPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FunnelPages and only return the `id`
     * const funnelPageWithIdOnly = await prisma.funnelPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FunnelPageCreateManyAndReturnArgs>(args?: SelectSubset<T, FunnelPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FunnelPage.
     * @param {FunnelPageDeleteArgs} args - Arguments to delete one FunnelPage.
     * @example
     * // Delete one FunnelPage
     * const FunnelPage = await prisma.funnelPage.delete({
     *   where: {
     *     // ... filter to delete one FunnelPage
     *   }
     * })
     * 
     */
    delete<T extends FunnelPageDeleteArgs>(args: SelectSubset<T, FunnelPageDeleteArgs<ExtArgs>>): Prisma__FunnelPageClient<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FunnelPage.
     * @param {FunnelPageUpdateArgs} args - Arguments to update one FunnelPage.
     * @example
     * // Update one FunnelPage
     * const funnelPage = await prisma.funnelPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunnelPageUpdateArgs>(args: SelectSubset<T, FunnelPageUpdateArgs<ExtArgs>>): Prisma__FunnelPageClient<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FunnelPages.
     * @param {FunnelPageDeleteManyArgs} args - Arguments to filter FunnelPages to delete.
     * @example
     * // Delete a few FunnelPages
     * const { count } = await prisma.funnelPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunnelPageDeleteManyArgs>(args?: SelectSubset<T, FunnelPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunnelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FunnelPages
     * const funnelPage = await prisma.funnelPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunnelPageUpdateManyArgs>(args: SelectSubset<T, FunnelPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunnelPages and returns the data updated in the database.
     * @param {FunnelPageUpdateManyAndReturnArgs} args - Arguments to update many FunnelPages.
     * @example
     * // Update many FunnelPages
     * const funnelPage = await prisma.funnelPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FunnelPages and only return the `id`
     * const funnelPageWithIdOnly = await prisma.funnelPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FunnelPageUpdateManyAndReturnArgs>(args: SelectSubset<T, FunnelPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FunnelPage.
     * @param {FunnelPageUpsertArgs} args - Arguments to update or create a FunnelPage.
     * @example
     * // Update or create a FunnelPage
     * const funnelPage = await prisma.funnelPage.upsert({
     *   create: {
     *     // ... data to create a FunnelPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FunnelPage we want to update
     *   }
     * })
     */
    upsert<T extends FunnelPageUpsertArgs>(args: SelectSubset<T, FunnelPageUpsertArgs<ExtArgs>>): Prisma__FunnelPageClient<$Result.GetResult<Prisma.$FunnelPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FunnelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPageCountArgs} args - Arguments to filter FunnelPages to count.
     * @example
     * // Count the number of FunnelPages
     * const count = await prisma.funnelPage.count({
     *   where: {
     *     // ... the filter for the FunnelPages we want to count
     *   }
     * })
    **/
    count<T extends FunnelPageCountArgs>(
      args?: Subset<T, FunnelPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunnelPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FunnelPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunnelPageAggregateArgs>(args: Subset<T, FunnelPageAggregateArgs>): Prisma.PrismaPromise<GetFunnelPageAggregateType<T>>

    /**
     * Group by FunnelPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunnelPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunnelPageGroupByArgs['orderBy'] }
        : { orderBy?: FunnelPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunnelPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunnelPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FunnelPage model
   */
  readonly fields: FunnelPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FunnelPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunnelPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    funnel<T extends FunnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FunnelDefaultArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FunnelPage model
   */
  interface FunnelPageFieldRefs {
    readonly id: FieldRef<"FunnelPage", 'String'>
    readonly createdAt: FieldRef<"FunnelPage", 'DateTime'>
    readonly updatedAt: FieldRef<"FunnelPage", 'DateTime'>
    readonly name: FieldRef<"FunnelPage", 'String'>
    readonly pathName: FieldRef<"FunnelPage", 'String'>
    readonly visits: FieldRef<"FunnelPage", 'Int'>
    readonly content: FieldRef<"FunnelPage", 'String'>
    readonly order: FieldRef<"FunnelPage", 'Int'>
    readonly previewImage: FieldRef<"FunnelPage", 'String'>
    readonly funnelId: FieldRef<"FunnelPage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FunnelPage findUnique
   */
  export type FunnelPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPage to fetch.
     */
    where: FunnelPageWhereUniqueInput
  }

  /**
   * FunnelPage findUniqueOrThrow
   */
  export type FunnelPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPage to fetch.
     */
    where: FunnelPageWhereUniqueInput
  }

  /**
   * FunnelPage findFirst
   */
  export type FunnelPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPage to fetch.
     */
    where?: FunnelPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelPages to fetch.
     */
    orderBy?: FunnelPageOrderByWithRelationInput | FunnelPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunnelPages.
     */
    cursor?: FunnelPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunnelPages.
     */
    distinct?: FunnelPageScalarFieldEnum | FunnelPageScalarFieldEnum[]
  }

  /**
   * FunnelPage findFirstOrThrow
   */
  export type FunnelPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPage to fetch.
     */
    where?: FunnelPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelPages to fetch.
     */
    orderBy?: FunnelPageOrderByWithRelationInput | FunnelPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunnelPages.
     */
    cursor?: FunnelPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunnelPages.
     */
    distinct?: FunnelPageScalarFieldEnum | FunnelPageScalarFieldEnum[]
  }

  /**
   * FunnelPage findMany
   */
  export type FunnelPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPages to fetch.
     */
    where?: FunnelPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelPages to fetch.
     */
    orderBy?: FunnelPageOrderByWithRelationInput | FunnelPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FunnelPages.
     */
    cursor?: FunnelPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelPages.
     */
    skip?: number
    distinct?: FunnelPageScalarFieldEnum | FunnelPageScalarFieldEnum[]
  }

  /**
   * FunnelPage create
   */
  export type FunnelPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * The data needed to create a FunnelPage.
     */
    data: XOR<FunnelPageCreateInput, FunnelPageUncheckedCreateInput>
  }

  /**
   * FunnelPage createMany
   */
  export type FunnelPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FunnelPages.
     */
    data: FunnelPageCreateManyInput | FunnelPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FunnelPage createManyAndReturn
   */
  export type FunnelPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * The data used to create many FunnelPages.
     */
    data: FunnelPageCreateManyInput | FunnelPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FunnelPage update
   */
  export type FunnelPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * The data needed to update a FunnelPage.
     */
    data: XOR<FunnelPageUpdateInput, FunnelPageUncheckedUpdateInput>
    /**
     * Choose, which FunnelPage to update.
     */
    where: FunnelPageWhereUniqueInput
  }

  /**
   * FunnelPage updateMany
   */
  export type FunnelPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FunnelPages.
     */
    data: XOR<FunnelPageUpdateManyMutationInput, FunnelPageUncheckedUpdateManyInput>
    /**
     * Filter which FunnelPages to update
     */
    where?: FunnelPageWhereInput
    /**
     * Limit how many FunnelPages to update.
     */
    limit?: number
  }

  /**
   * FunnelPage updateManyAndReturn
   */
  export type FunnelPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * The data used to update FunnelPages.
     */
    data: XOR<FunnelPageUpdateManyMutationInput, FunnelPageUncheckedUpdateManyInput>
    /**
     * Filter which FunnelPages to update
     */
    where?: FunnelPageWhereInput
    /**
     * Limit how many FunnelPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FunnelPage upsert
   */
  export type FunnelPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * The filter to search for the FunnelPage to update in case it exists.
     */
    where: FunnelPageWhereUniqueInput
    /**
     * In case the FunnelPage found by the `where` argument doesn't exist, create a new FunnelPage with this data.
     */
    create: XOR<FunnelPageCreateInput, FunnelPageUncheckedCreateInput>
    /**
     * In case the FunnelPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunnelPageUpdateInput, FunnelPageUncheckedUpdateInput>
  }

  /**
   * FunnelPage delete
   */
  export type FunnelPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
    /**
     * Filter which FunnelPage to delete.
     */
    where: FunnelPageWhereUniqueInput
  }

  /**
   * FunnelPage deleteMany
   */
  export type FunnelPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunnelPages to delete
     */
    where?: FunnelPageWhereInput
    /**
     * Limit how many FunnelPages to delete.
     */
    limit?: number
  }

  /**
   * FunnelPage without action
   */
  export type FunnelPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPage
     */
    select?: FunnelPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPage
     */
    omit?: FunnelPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPageInclude<ExtArgs> | null
  }


  /**
   * Model AgencySidebarOption
   */

  export type AggregateAgencySidebarOption = {
    _count: AgencySidebarOptionCountAggregateOutputType | null
    _min: AgencySidebarOptionMinAggregateOutputType | null
    _max: AgencySidebarOptionMaxAggregateOutputType | null
  }

  export type AgencySidebarOptionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    agencyId: string | null
  }

  export type AgencySidebarOptionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    agencyId: string | null
  }

  export type AgencySidebarOptionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    link: number
    icon: number
    agencyId: number
    _all: number
  }


  export type AgencySidebarOptionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    link?: true
    icon?: true
    agencyId?: true
  }

  export type AgencySidebarOptionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    link?: true
    icon?: true
    agencyId?: true
  }

  export type AgencySidebarOptionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    link?: true
    icon?: true
    agencyId?: true
    _all?: true
  }

  export type AgencySidebarOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencySidebarOption to aggregate.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencySidebarOptions
    **/
    _count?: true | AgencySidebarOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencySidebarOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencySidebarOptionMaxAggregateInputType
  }

  export type GetAgencySidebarOptionAggregateType<T extends AgencySidebarOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencySidebarOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencySidebarOption[P]>
      : GetScalarType<T[P], AggregateAgencySidebarOption[P]>
  }




  export type AgencySidebarOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencySidebarOptionWhereInput
    orderBy?: AgencySidebarOptionOrderByWithAggregationInput | AgencySidebarOptionOrderByWithAggregationInput[]
    by: AgencySidebarOptionScalarFieldEnum[] | AgencySidebarOptionScalarFieldEnum
    having?: AgencySidebarOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencySidebarOptionCountAggregateInputType | true
    _min?: AgencySidebarOptionMinAggregateInputType
    _max?: AgencySidebarOptionMaxAggregateInputType
  }

  export type AgencySidebarOptionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    link: string
    icon: $Enums.Icon
    agencyId: string
    _count: AgencySidebarOptionCountAggregateOutputType | null
    _min: AgencySidebarOptionMinAggregateOutputType | null
    _max: AgencySidebarOptionMaxAggregateOutputType | null
  }

  type GetAgencySidebarOptionGroupByPayload<T extends AgencySidebarOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencySidebarOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencySidebarOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencySidebarOptionGroupByOutputType[P]>
            : GetScalarType<T[P], AgencySidebarOptionGroupByOutputType[P]>
        }
      >
    >


  export type AgencySidebarOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    agencyId?: boolean
    agency?: boolean | AgencySidebarOption$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["agencySidebarOption"]>

  export type AgencySidebarOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    agencyId?: boolean
    agency?: boolean | AgencySidebarOption$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["agencySidebarOption"]>

  export type AgencySidebarOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    agencyId?: boolean
    agency?: boolean | AgencySidebarOption$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["agencySidebarOption"]>

  export type AgencySidebarOptionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    agencyId?: boolean
  }

  export type AgencySidebarOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "link" | "icon" | "agencyId", ExtArgs["result"]["agencySidebarOption"]>
  export type AgencySidebarOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencySidebarOption$agencyArgs<ExtArgs>
  }
  export type AgencySidebarOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencySidebarOption$agencyArgs<ExtArgs>
  }
  export type AgencySidebarOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencySidebarOption$agencyArgs<ExtArgs>
  }

  export type $AgencySidebarOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencySidebarOption"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      link: string
      icon: $Enums.Icon
      agencyId: string
    }, ExtArgs["result"]["agencySidebarOption"]>
    composites: {}
  }

  type AgencySidebarOptionGetPayload<S extends boolean | null | undefined | AgencySidebarOptionDefaultArgs> = $Result.GetResult<Prisma.$AgencySidebarOptionPayload, S>

  type AgencySidebarOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencySidebarOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencySidebarOptionCountAggregateInputType | true
    }

  export interface AgencySidebarOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencySidebarOption'], meta: { name: 'AgencySidebarOption' } }
    /**
     * Find zero or one AgencySidebarOption that matches the filter.
     * @param {AgencySidebarOptionFindUniqueArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencySidebarOptionFindUniqueArgs>(args: SelectSubset<T, AgencySidebarOptionFindUniqueArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencySidebarOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencySidebarOptionFindUniqueOrThrowArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencySidebarOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencySidebarOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindFirstArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencySidebarOptionFindFirstArgs>(args?: SelectSubset<T, AgencySidebarOptionFindFirstArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencySidebarOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindFirstOrThrowArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencySidebarOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencySidebarOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencySidebarOptions
     * const agencySidebarOptions = await prisma.agencySidebarOption.findMany()
     * 
     * // Get first 10 AgencySidebarOptions
     * const agencySidebarOptions = await prisma.agencySidebarOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencySidebarOptionWithIdOnly = await prisma.agencySidebarOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencySidebarOptionFindManyArgs>(args?: SelectSubset<T, AgencySidebarOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencySidebarOption.
     * @param {AgencySidebarOptionCreateArgs} args - Arguments to create a AgencySidebarOption.
     * @example
     * // Create one AgencySidebarOption
     * const AgencySidebarOption = await prisma.agencySidebarOption.create({
     *   data: {
     *     // ... data to create a AgencySidebarOption
     *   }
     * })
     * 
     */
    create<T extends AgencySidebarOptionCreateArgs>(args: SelectSubset<T, AgencySidebarOptionCreateArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencySidebarOptions.
     * @param {AgencySidebarOptionCreateManyArgs} args - Arguments to create many AgencySidebarOptions.
     * @example
     * // Create many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencySidebarOptionCreateManyArgs>(args?: SelectSubset<T, AgencySidebarOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencySidebarOptions and returns the data saved in the database.
     * @param {AgencySidebarOptionCreateManyAndReturnArgs} args - Arguments to create many AgencySidebarOptions.
     * @example
     * // Create many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencySidebarOptions and only return the `id`
     * const agencySidebarOptionWithIdOnly = await prisma.agencySidebarOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencySidebarOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencySidebarOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencySidebarOption.
     * @param {AgencySidebarOptionDeleteArgs} args - Arguments to delete one AgencySidebarOption.
     * @example
     * // Delete one AgencySidebarOption
     * const AgencySidebarOption = await prisma.agencySidebarOption.delete({
     *   where: {
     *     // ... filter to delete one AgencySidebarOption
     *   }
     * })
     * 
     */
    delete<T extends AgencySidebarOptionDeleteArgs>(args: SelectSubset<T, AgencySidebarOptionDeleteArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencySidebarOption.
     * @param {AgencySidebarOptionUpdateArgs} args - Arguments to update one AgencySidebarOption.
     * @example
     * // Update one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencySidebarOptionUpdateArgs>(args: SelectSubset<T, AgencySidebarOptionUpdateArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencySidebarOptions.
     * @param {AgencySidebarOptionDeleteManyArgs} args - Arguments to filter AgencySidebarOptions to delete.
     * @example
     * // Delete a few AgencySidebarOptions
     * const { count } = await prisma.agencySidebarOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencySidebarOptionDeleteManyArgs>(args?: SelectSubset<T, AgencySidebarOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencySidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencySidebarOptionUpdateManyArgs>(args: SelectSubset<T, AgencySidebarOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencySidebarOptions and returns the data updated in the database.
     * @param {AgencySidebarOptionUpdateManyAndReturnArgs} args - Arguments to update many AgencySidebarOptions.
     * @example
     * // Update many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencySidebarOptions and only return the `id`
     * const agencySidebarOptionWithIdOnly = await prisma.agencySidebarOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencySidebarOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencySidebarOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencySidebarOption.
     * @param {AgencySidebarOptionUpsertArgs} args - Arguments to update or create a AgencySidebarOption.
     * @example
     * // Update or create a AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.upsert({
     *   create: {
     *     // ... data to create a AgencySidebarOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencySidebarOption we want to update
     *   }
     * })
     */
    upsert<T extends AgencySidebarOptionUpsertArgs>(args: SelectSubset<T, AgencySidebarOptionUpsertArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencySidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionCountArgs} args - Arguments to filter AgencySidebarOptions to count.
     * @example
     * // Count the number of AgencySidebarOptions
     * const count = await prisma.agencySidebarOption.count({
     *   where: {
     *     // ... the filter for the AgencySidebarOptions we want to count
     *   }
     * })
    **/
    count<T extends AgencySidebarOptionCountArgs>(
      args?: Subset<T, AgencySidebarOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencySidebarOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencySidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencySidebarOptionAggregateArgs>(args: Subset<T, AgencySidebarOptionAggregateArgs>): Prisma.PrismaPromise<GetAgencySidebarOptionAggregateType<T>>

    /**
     * Group by AgencySidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencySidebarOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencySidebarOptionGroupByArgs['orderBy'] }
        : { orderBy?: AgencySidebarOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencySidebarOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencySidebarOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencySidebarOption model
   */
  readonly fields: AgencySidebarOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencySidebarOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencySidebarOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencySidebarOption$agencyArgs<ExtArgs> = {}>(args?: Subset<T, AgencySidebarOption$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencySidebarOption model
   */
  interface AgencySidebarOptionFieldRefs {
    readonly id: FieldRef<"AgencySidebarOption", 'String'>
    readonly createdAt: FieldRef<"AgencySidebarOption", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencySidebarOption", 'DateTime'>
    readonly name: FieldRef<"AgencySidebarOption", 'String'>
    readonly link: FieldRef<"AgencySidebarOption", 'String'>
    readonly icon: FieldRef<"AgencySidebarOption", 'Icon'>
    readonly agencyId: FieldRef<"AgencySidebarOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgencySidebarOption findUnique
   */
  export type AgencySidebarOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption findUniqueOrThrow
   */
  export type AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption findFirst
   */
  export type AgencySidebarOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencySidebarOptions.
     */
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption findFirstOrThrow
   */
  export type AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencySidebarOptions.
     */
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption findMany
   */
  export type AgencySidebarOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOptions to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption create
   */
  export type AgencySidebarOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencySidebarOption.
     */
    data: XOR<AgencySidebarOptionCreateInput, AgencySidebarOptionUncheckedCreateInput>
  }

  /**
   * AgencySidebarOption createMany
   */
  export type AgencySidebarOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencySidebarOptions.
     */
    data: AgencySidebarOptionCreateManyInput | AgencySidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencySidebarOption createManyAndReturn
   */
  export type AgencySidebarOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * The data used to create many AgencySidebarOptions.
     */
    data: AgencySidebarOptionCreateManyInput | AgencySidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencySidebarOption update
   */
  export type AgencySidebarOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencySidebarOption.
     */
    data: XOR<AgencySidebarOptionUpdateInput, AgencySidebarOptionUncheckedUpdateInput>
    /**
     * Choose, which AgencySidebarOption to update.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption updateMany
   */
  export type AgencySidebarOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencySidebarOptions.
     */
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which AgencySidebarOptions to update
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * Limit how many AgencySidebarOptions to update.
     */
    limit?: number
  }

  /**
   * AgencySidebarOption updateManyAndReturn
   */
  export type AgencySidebarOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * The data used to update AgencySidebarOptions.
     */
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which AgencySidebarOptions to update
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * Limit how many AgencySidebarOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencySidebarOption upsert
   */
  export type AgencySidebarOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencySidebarOption to update in case it exists.
     */
    where: AgencySidebarOptionWhereUniqueInput
    /**
     * In case the AgencySidebarOption found by the `where` argument doesn't exist, create a new AgencySidebarOption with this data.
     */
    create: XOR<AgencySidebarOptionCreateInput, AgencySidebarOptionUncheckedCreateInput>
    /**
     * In case the AgencySidebarOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencySidebarOptionUpdateInput, AgencySidebarOptionUncheckedUpdateInput>
  }

  /**
   * AgencySidebarOption delete
   */
  export type AgencySidebarOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter which AgencySidebarOption to delete.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption deleteMany
   */
  export type AgencySidebarOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencySidebarOptions to delete
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * Limit how many AgencySidebarOptions to delete.
     */
    limit?: number
  }

  /**
   * AgencySidebarOption.agency
   */
  export type AgencySidebarOption$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * AgencySidebarOption without action
   */
  export type AgencySidebarOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
  }


  /**
   * Model SubAccountSidebarOption
   */

  export type AggregateSubAccountSidebarOption = {
    _count: SubAccountSidebarOptionCountAggregateOutputType | null
    _min: SubAccountSidebarOptionMinAggregateOutputType | null
    _max: SubAccountSidebarOptionMaxAggregateOutputType | null
  }

  export type SubAccountSidebarOptionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    link: string | null
    subAccountId: string | null
    icon: $Enums.Icon | null
  }

  export type SubAccountSidebarOptionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    link: string | null
    subAccountId: string | null
    icon: $Enums.Icon | null
  }

  export type SubAccountSidebarOptionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    link: number
    subAccountId: number
    icon: number
    _all: number
  }


  export type SubAccountSidebarOptionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    link?: true
    subAccountId?: true
    icon?: true
  }

  export type SubAccountSidebarOptionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    link?: true
    subAccountId?: true
    icon?: true
  }

  export type SubAccountSidebarOptionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    link?: true
    subAccountId?: true
    icon?: true
    _all?: true
  }

  export type SubAccountSidebarOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccountSidebarOption to aggregate.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAccountSidebarOptions
    **/
    _count?: true | SubAccountSidebarOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubAccountSidebarOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubAccountSidebarOptionMaxAggregateInputType
  }

  export type GetSubAccountSidebarOptionAggregateType<T extends SubAccountSidebarOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubAccountSidebarOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubAccountSidebarOption[P]>
      : GetScalarType<T[P], AggregateSubAccountSidebarOption[P]>
  }




  export type SubAccountSidebarOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountSidebarOptionWhereInput
    orderBy?: SubAccountSidebarOptionOrderByWithAggregationInput | SubAccountSidebarOptionOrderByWithAggregationInput[]
    by: SubAccountSidebarOptionScalarFieldEnum[] | SubAccountSidebarOptionScalarFieldEnum
    having?: SubAccountSidebarOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubAccountSidebarOptionCountAggregateInputType | true
    _min?: SubAccountSidebarOptionMinAggregateInputType
    _max?: SubAccountSidebarOptionMaxAggregateInputType
  }

  export type SubAccountSidebarOptionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    link: string
    subAccountId: string | null
    icon: $Enums.Icon
    _count: SubAccountSidebarOptionCountAggregateOutputType | null
    _min: SubAccountSidebarOptionMinAggregateOutputType | null
    _max: SubAccountSidebarOptionMaxAggregateOutputType | null
  }

  type GetSubAccountSidebarOptionGroupByPayload<T extends SubAccountSidebarOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubAccountSidebarOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubAccountSidebarOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubAccountSidebarOptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubAccountSidebarOptionGroupByOutputType[P]>
        }
      >
    >


  export type SubAccountSidebarOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    icon?: boolean
    subAccount?: boolean | SubAccountSidebarOption$subAccountArgs<ExtArgs>
  }, ExtArgs["result"]["subAccountSidebarOption"]>

  export type SubAccountSidebarOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    icon?: boolean
    subAccount?: boolean | SubAccountSidebarOption$subAccountArgs<ExtArgs>
  }, ExtArgs["result"]["subAccountSidebarOption"]>

  export type SubAccountSidebarOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    icon?: boolean
    subAccount?: boolean | SubAccountSidebarOption$subAccountArgs<ExtArgs>
  }, ExtArgs["result"]["subAccountSidebarOption"]>

  export type SubAccountSidebarOptionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    icon?: boolean
  }

  export type SubAccountSidebarOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "link" | "subAccountId" | "icon", ExtArgs["result"]["subAccountSidebarOption"]>
  export type SubAccountSidebarOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountSidebarOption$subAccountArgs<ExtArgs>
  }
  export type SubAccountSidebarOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountSidebarOption$subAccountArgs<ExtArgs>
  }
  export type SubAccountSidebarOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccount?: boolean | SubAccountSidebarOption$subAccountArgs<ExtArgs>
  }

  export type $SubAccountSidebarOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubAccountSidebarOption"
    objects: {
      subAccount: Prisma.$SubAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      link: string
      subAccountId: string | null
      icon: $Enums.Icon
    }, ExtArgs["result"]["subAccountSidebarOption"]>
    composites: {}
  }

  type SubAccountSidebarOptionGetPayload<S extends boolean | null | undefined | SubAccountSidebarOptionDefaultArgs> = $Result.GetResult<Prisma.$SubAccountSidebarOptionPayload, S>

  type SubAccountSidebarOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubAccountSidebarOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubAccountSidebarOptionCountAggregateInputType | true
    }

  export interface SubAccountSidebarOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubAccountSidebarOption'], meta: { name: 'SubAccountSidebarOption' } }
    /**
     * Find zero or one SubAccountSidebarOption that matches the filter.
     * @param {SubAccountSidebarOptionFindUniqueArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubAccountSidebarOptionFindUniqueArgs>(args: SelectSubset<T, SubAccountSidebarOptionFindUniqueArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubAccountSidebarOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubAccountSidebarOptionFindUniqueOrThrowArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubAccountSidebarOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccountSidebarOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindFirstArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubAccountSidebarOptionFindFirstArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindFirstArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccountSidebarOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindFirstOrThrowArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubAccountSidebarOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubAccountSidebarOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAccountSidebarOptions
     * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany()
     * 
     * // Get first 10 SubAccountSidebarOptions
     * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subAccountSidebarOptionWithIdOnly = await prisma.subAccountSidebarOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubAccountSidebarOptionFindManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionCreateArgs} args - Arguments to create a SubAccountSidebarOption.
     * @example
     * // Create one SubAccountSidebarOption
     * const SubAccountSidebarOption = await prisma.subAccountSidebarOption.create({
     *   data: {
     *     // ... data to create a SubAccountSidebarOption
     *   }
     * })
     * 
     */
    create<T extends SubAccountSidebarOptionCreateArgs>(args: SelectSubset<T, SubAccountSidebarOptionCreateArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubAccountSidebarOptions.
     * @param {SubAccountSidebarOptionCreateManyArgs} args - Arguments to create many SubAccountSidebarOptions.
     * @example
     * // Create many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubAccountSidebarOptionCreateManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubAccountSidebarOptions and returns the data saved in the database.
     * @param {SubAccountSidebarOptionCreateManyAndReturnArgs} args - Arguments to create many SubAccountSidebarOptions.
     * @example
     * // Create many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubAccountSidebarOptions and only return the `id`
     * const subAccountSidebarOptionWithIdOnly = await prisma.subAccountSidebarOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubAccountSidebarOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubAccountSidebarOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionDeleteArgs} args - Arguments to delete one SubAccountSidebarOption.
     * @example
     * // Delete one SubAccountSidebarOption
     * const SubAccountSidebarOption = await prisma.subAccountSidebarOption.delete({
     *   where: {
     *     // ... filter to delete one SubAccountSidebarOption
     *   }
     * })
     * 
     */
    delete<T extends SubAccountSidebarOptionDeleteArgs>(args: SelectSubset<T, SubAccountSidebarOptionDeleteArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionUpdateArgs} args - Arguments to update one SubAccountSidebarOption.
     * @example
     * // Update one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubAccountSidebarOptionUpdateArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpdateArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubAccountSidebarOptions.
     * @param {SubAccountSidebarOptionDeleteManyArgs} args - Arguments to filter SubAccountSidebarOptions to delete.
     * @example
     * // Delete a few SubAccountSidebarOptions
     * const { count } = await prisma.subAccountSidebarOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubAccountSidebarOptionDeleteManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccountSidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubAccountSidebarOptionUpdateManyArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccountSidebarOptions and returns the data updated in the database.
     * @param {SubAccountSidebarOptionUpdateManyAndReturnArgs} args - Arguments to update many SubAccountSidebarOptions.
     * @example
     * // Update many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubAccountSidebarOptions and only return the `id`
     * const subAccountSidebarOptionWithIdOnly = await prisma.subAccountSidebarOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubAccountSidebarOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionUpsertArgs} args - Arguments to update or create a SubAccountSidebarOption.
     * @example
     * // Update or create a SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.upsert({
     *   create: {
     *     // ... data to create a SubAccountSidebarOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubAccountSidebarOption we want to update
     *   }
     * })
     */
    upsert<T extends SubAccountSidebarOptionUpsertArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpsertArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubAccountSidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionCountArgs} args - Arguments to filter SubAccountSidebarOptions to count.
     * @example
     * // Count the number of SubAccountSidebarOptions
     * const count = await prisma.subAccountSidebarOption.count({
     *   where: {
     *     // ... the filter for the SubAccountSidebarOptions we want to count
     *   }
     * })
    **/
    count<T extends SubAccountSidebarOptionCountArgs>(
      args?: Subset<T, SubAccountSidebarOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAccountSidebarOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubAccountSidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAccountSidebarOptionAggregateArgs>(args: Subset<T, SubAccountSidebarOptionAggregateArgs>): Prisma.PrismaPromise<GetSubAccountSidebarOptionAggregateType<T>>

    /**
     * Group by SubAccountSidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubAccountSidebarOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubAccountSidebarOptionGroupByArgs['orderBy'] }
        : { orderBy?: SubAccountSidebarOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubAccountSidebarOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubAccountSidebarOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubAccountSidebarOption model
   */
  readonly fields: SubAccountSidebarOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubAccountSidebarOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubAccountSidebarOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subAccount<T extends SubAccountSidebarOption$subAccountArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountSidebarOption$subAccountArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubAccountSidebarOption model
   */
  interface SubAccountSidebarOptionFieldRefs {
    readonly id: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly createdAt: FieldRef<"SubAccountSidebarOption", 'DateTime'>
    readonly updatedAt: FieldRef<"SubAccountSidebarOption", 'DateTime'>
    readonly name: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly link: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly subAccountId: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly icon: FieldRef<"SubAccountSidebarOption", 'Icon'>
  }
    

  // Custom InputTypes
  /**
   * SubAccountSidebarOption findUnique
   */
  export type SubAccountSidebarOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption findUniqueOrThrow
   */
  export type SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption findFirst
   */
  export type SubAccountSidebarOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccountSidebarOptions.
     */
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption findFirstOrThrow
   */
  export type SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccountSidebarOptions.
     */
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption findMany
   */
  export type SubAccountSidebarOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOptions to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption create
   */
  export type SubAccountSidebarOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a SubAccountSidebarOption.
     */
    data: XOR<SubAccountSidebarOptionCreateInput, SubAccountSidebarOptionUncheckedCreateInput>
  }

  /**
   * SubAccountSidebarOption createMany
   */
  export type SubAccountSidebarOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubAccountSidebarOptions.
     */
    data: SubAccountSidebarOptionCreateManyInput | SubAccountSidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubAccountSidebarOption createManyAndReturn
   */
  export type SubAccountSidebarOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * The data used to create many SubAccountSidebarOptions.
     */
    data: SubAccountSidebarOptionCreateManyInput | SubAccountSidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccountSidebarOption update
   */
  export type SubAccountSidebarOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a SubAccountSidebarOption.
     */
    data: XOR<SubAccountSidebarOptionUpdateInput, SubAccountSidebarOptionUncheckedUpdateInput>
    /**
     * Choose, which SubAccountSidebarOption to update.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption updateMany
   */
  export type SubAccountSidebarOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubAccountSidebarOptions.
     */
    data: XOR<SubAccountSidebarOptionUpdateManyMutationInput, SubAccountSidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which SubAccountSidebarOptions to update
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * Limit how many SubAccountSidebarOptions to update.
     */
    limit?: number
  }

  /**
   * SubAccountSidebarOption updateManyAndReturn
   */
  export type SubAccountSidebarOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * The data used to update SubAccountSidebarOptions.
     */
    data: XOR<SubAccountSidebarOptionUpdateManyMutationInput, SubAccountSidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which SubAccountSidebarOptions to update
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * Limit how many SubAccountSidebarOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccountSidebarOption upsert
   */
  export type SubAccountSidebarOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the SubAccountSidebarOption to update in case it exists.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
    /**
     * In case the SubAccountSidebarOption found by the `where` argument doesn't exist, create a new SubAccountSidebarOption with this data.
     */
    create: XOR<SubAccountSidebarOptionCreateInput, SubAccountSidebarOptionUncheckedCreateInput>
    /**
     * In case the SubAccountSidebarOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubAccountSidebarOptionUpdateInput, SubAccountSidebarOptionUncheckedUpdateInput>
  }

  /**
   * SubAccountSidebarOption delete
   */
  export type SubAccountSidebarOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter which SubAccountSidebarOption to delete.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption deleteMany
   */
  export type SubAccountSidebarOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccountSidebarOptions to delete
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * Limit how many SubAccountSidebarOptions to delete.
     */
    limit?: number
  }

  /**
   * SubAccountSidebarOption.subAccount
   */
  export type SubAccountSidebarOption$subAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
  }

  /**
   * SubAccountSidebarOption without action
   */
  export type SubAccountSidebarOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    agencyId: string | null
    status: $Enums.InvitationStatus | null
    role: $Enums.Role | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    agencyId: string | null
    status: $Enums.InvitationStatus | null
    role: $Enums.Role | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    email: number
    agencyId: number
    status: number
    role: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    email: string
    agencyId: string
    status: $Enums.InvitationStatus
    role: $Enums.Role
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "agencyId" | "status" | "role", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      agencyId: string
      status: $Enums.InvitationStatus
      role: $Enums.Role
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly agencyId: FieldRef<"Invitation", 'String'>
    readonly status: FieldRef<"Invitation", 'InvitationStatus'>
    readonly role: FieldRef<"Invitation", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    plan: $Enums.Plan | null
    price: string | null
    active: boolean | null
    priceId: string | null
    customerId: string | null
    currentPeriodEndDate: Date | null
    subscritiptionId: string | null
    agencyId: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    plan: $Enums.Plan | null
    price: string | null
    active: boolean | null
    priceId: string | null
    customerId: string | null
    currentPeriodEndDate: Date | null
    subscritiptionId: string | null
    agencyId: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    plan: number
    price: number
    active: number
    priceId: number
    customerId: number
    currentPeriodEndDate: number
    subscritiptionId: number
    agencyId: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscritiptionId?: true
    agencyId?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscritiptionId?: true
    agencyId?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscritiptionId?: true
    agencyId?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    plan: $Enums.Plan | null
    price: string | null
    active: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date
    subscritiptionId: string
    agencyId: string | null
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscritiptionId?: boolean
    agencyId?: boolean
    agency?: boolean | Subscription$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscritiptionId?: boolean
    agencyId?: boolean
    agency?: boolean | Subscription$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscritiptionId?: boolean
    agencyId?: boolean
    agency?: boolean | Subscription$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscritiptionId?: boolean
    agencyId?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "plan" | "price" | "active" | "priceId" | "customerId" | "currentPeriodEndDate" | "subscritiptionId" | "agencyId", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | Subscription$agencyArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | Subscription$agencyArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | Subscription$agencyArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      plan: $Enums.Plan | null
      price: string | null
      active: boolean
      priceId: string
      customerId: string
      currentPeriodEndDate: Date
      subscritiptionId: string
      agencyId: string | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends Subscription$agencyArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
    readonly plan: FieldRef<"Subscription", 'Plan'>
    readonly price: FieldRef<"Subscription", 'String'>
    readonly active: FieldRef<"Subscription", 'Boolean'>
    readonly priceId: FieldRef<"Subscription", 'String'>
    readonly customerId: FieldRef<"Subscription", 'String'>
    readonly currentPeriodEndDate: FieldRef<"Subscription", 'DateTime'>
    readonly subscritiptionId: FieldRef<"Subscription", 'String'>
    readonly agencyId: FieldRef<"Subscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.agency
   */
  export type Subscription$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model AddOns
   */

  export type AggregateAddOns = {
    _count: AddOnsCountAggregateOutputType | null
    _min: AddOnsMinAggregateOutputType | null
    _max: AddOnsMaxAggregateOutputType | null
  }

  export type AddOnsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    active: boolean | null
    priceId: string | null
    agencyId: string | null
  }

  export type AddOnsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    active: boolean | null
    priceId: string | null
    agencyId: string | null
  }

  export type AddOnsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    active: number
    priceId: number
    agencyId: number
    _all: number
  }


  export type AddOnsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
  }

  export type AddOnsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
  }

  export type AddOnsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
    _all?: true
  }

  export type AddOnsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOns to aggregate.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddOns
    **/
    _count?: true | AddOnsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddOnsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddOnsMaxAggregateInputType
  }

  export type GetAddOnsAggregateType<T extends AddOnsAggregateArgs> = {
        [P in keyof T & keyof AggregateAddOns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddOns[P]>
      : GetScalarType<T[P], AggregateAddOns[P]>
  }




  export type AddOnsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnsWhereInput
    orderBy?: AddOnsOrderByWithAggregationInput | AddOnsOrderByWithAggregationInput[]
    by: AddOnsScalarFieldEnum[] | AddOnsScalarFieldEnum
    having?: AddOnsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddOnsCountAggregateInputType | true
    _min?: AddOnsMinAggregateInputType
    _max?: AddOnsMaxAggregateInputType
  }

  export type AddOnsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    active: boolean
    priceId: string
    agencyId: string | null
    _count: AddOnsCountAggregateOutputType | null
    _min: AddOnsMinAggregateOutputType | null
    _max: AddOnsMaxAggregateOutputType | null
  }

  type GetAddOnsGroupByPayload<T extends AddOnsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddOnsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddOnsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddOnsGroupByOutputType[P]>
            : GetScalarType<T[P], AddOnsGroupByOutputType[P]>
        }
      >
    >


  export type AddOnsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
    agency?: boolean | AddOns$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["addOns"]>

  export type AddOnsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
    agency?: boolean | AddOns$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["addOns"]>

  export type AddOnsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
    agency?: boolean | AddOns$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["addOns"]>

  export type AddOnsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
  }

  export type AddOnsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "active" | "priceId" | "agencyId", ExtArgs["result"]["addOns"]>
  export type AddOnsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AddOns$agencyArgs<ExtArgs>
  }
  export type AddOnsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AddOns$agencyArgs<ExtArgs>
  }
  export type AddOnsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agency?: boolean | AddOns$agencyArgs<ExtArgs>
  }

  export type $AddOnsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddOns"
    objects: {
      agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      active: boolean
      priceId: string
      agencyId: string | null
    }, ExtArgs["result"]["addOns"]>
    composites: {}
  }

  type AddOnsGetPayload<S extends boolean | null | undefined | AddOnsDefaultArgs> = $Result.GetResult<Prisma.$AddOnsPayload, S>

  type AddOnsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddOnsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddOnsCountAggregateInputType | true
    }

  export interface AddOnsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddOns'], meta: { name: 'AddOns' } }
    /**
     * Find zero or one AddOns that matches the filter.
     * @param {AddOnsFindUniqueArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddOnsFindUniqueArgs>(args: SelectSubset<T, AddOnsFindUniqueArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddOns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddOnsFindUniqueOrThrowArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddOnsFindUniqueOrThrowArgs>(args: SelectSubset<T, AddOnsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindFirstArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddOnsFindFirstArgs>(args?: SelectSubset<T, AddOnsFindFirstArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddOns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindFirstOrThrowArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddOnsFindFirstOrThrowArgs>(args?: SelectSubset<T, AddOnsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddOns
     * const addOns = await prisma.addOns.findMany()
     * 
     * // Get first 10 AddOns
     * const addOns = await prisma.addOns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addOnsWithIdOnly = await prisma.addOns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddOnsFindManyArgs>(args?: SelectSubset<T, AddOnsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddOns.
     * @param {AddOnsCreateArgs} args - Arguments to create a AddOns.
     * @example
     * // Create one AddOns
     * const AddOns = await prisma.addOns.create({
     *   data: {
     *     // ... data to create a AddOns
     *   }
     * })
     * 
     */
    create<T extends AddOnsCreateArgs>(args: SelectSubset<T, AddOnsCreateArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddOns.
     * @param {AddOnsCreateManyArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOns = await prisma.addOns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddOnsCreateManyArgs>(args?: SelectSubset<T, AddOnsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddOns and returns the data saved in the database.
     * @param {AddOnsCreateManyAndReturnArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOns = await prisma.addOns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddOns and only return the `id`
     * const addOnsWithIdOnly = await prisma.addOns.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddOnsCreateManyAndReturnArgs>(args?: SelectSubset<T, AddOnsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AddOns.
     * @param {AddOnsDeleteArgs} args - Arguments to delete one AddOns.
     * @example
     * // Delete one AddOns
     * const AddOns = await prisma.addOns.delete({
     *   where: {
     *     // ... filter to delete one AddOns
     *   }
     * })
     * 
     */
    delete<T extends AddOnsDeleteArgs>(args: SelectSubset<T, AddOnsDeleteArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddOns.
     * @param {AddOnsUpdateArgs} args - Arguments to update one AddOns.
     * @example
     * // Update one AddOns
     * const addOns = await prisma.addOns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddOnsUpdateArgs>(args: SelectSubset<T, AddOnsUpdateArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddOns.
     * @param {AddOnsDeleteManyArgs} args - Arguments to filter AddOns to delete.
     * @example
     * // Delete a few AddOns
     * const { count } = await prisma.addOns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddOnsDeleteManyArgs>(args?: SelectSubset<T, AddOnsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddOns
     * const addOns = await prisma.addOns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddOnsUpdateManyArgs>(args: SelectSubset<T, AddOnsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOns and returns the data updated in the database.
     * @param {AddOnsUpdateManyAndReturnArgs} args - Arguments to update many AddOns.
     * @example
     * // Update many AddOns
     * const addOns = await prisma.addOns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AddOns and only return the `id`
     * const addOnsWithIdOnly = await prisma.addOns.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddOnsUpdateManyAndReturnArgs>(args: SelectSubset<T, AddOnsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AddOns.
     * @param {AddOnsUpsertArgs} args - Arguments to update or create a AddOns.
     * @example
     * // Update or create a AddOns
     * const addOns = await prisma.addOns.upsert({
     *   create: {
     *     // ... data to create a AddOns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddOns we want to update
     *   }
     * })
     */
    upsert<T extends AddOnsUpsertArgs>(args: SelectSubset<T, AddOnsUpsertArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsCountArgs} args - Arguments to filter AddOns to count.
     * @example
     * // Count the number of AddOns
     * const count = await prisma.addOns.count({
     *   where: {
     *     // ... the filter for the AddOns we want to count
     *   }
     * })
    **/
    count<T extends AddOnsCountArgs>(
      args?: Subset<T, AddOnsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddOnsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddOnsAggregateArgs>(args: Subset<T, AddOnsAggregateArgs>): Prisma.PrismaPromise<GetAddOnsAggregateType<T>>

    /**
     * Group by AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddOnsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddOnsGroupByArgs['orderBy'] }
        : { orderBy?: AddOnsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddOnsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddOnsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddOns model
   */
  readonly fields: AddOnsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddOns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddOnsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agency<T extends AddOns$agencyArgs<ExtArgs> = {}>(args?: Subset<T, AddOns$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddOns model
   */
  interface AddOnsFieldRefs {
    readonly id: FieldRef<"AddOns", 'String'>
    readonly createdAt: FieldRef<"AddOns", 'DateTime'>
    readonly updatedAt: FieldRef<"AddOns", 'DateTime'>
    readonly name: FieldRef<"AddOns", 'String'>
    readonly active: FieldRef<"AddOns", 'Boolean'>
    readonly priceId: FieldRef<"AddOns", 'String'>
    readonly agencyId: FieldRef<"AddOns", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddOns findUnique
   */
  export type AddOnsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns findUniqueOrThrow
   */
  export type AddOnsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns findFirst
   */
  export type AddOnsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns findFirstOrThrow
   */
  export type AddOnsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns findMany
   */
  export type AddOnsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns create
   */
  export type AddOnsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The data needed to create a AddOns.
     */
    data: XOR<AddOnsCreateInput, AddOnsUncheckedCreateInput>
  }

  /**
   * AddOns createMany
   */
  export type AddOnsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddOns.
     */
    data: AddOnsCreateManyInput | AddOnsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddOns createManyAndReturn
   */
  export type AddOnsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * The data used to create many AddOns.
     */
    data: AddOnsCreateManyInput | AddOnsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddOns update
   */
  export type AddOnsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The data needed to update a AddOns.
     */
    data: XOR<AddOnsUpdateInput, AddOnsUncheckedUpdateInput>
    /**
     * Choose, which AddOns to update.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns updateMany
   */
  export type AddOnsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddOns.
     */
    data: XOR<AddOnsUpdateManyMutationInput, AddOnsUncheckedUpdateManyInput>
    /**
     * Filter which AddOns to update
     */
    where?: AddOnsWhereInput
    /**
     * Limit how many AddOns to update.
     */
    limit?: number
  }

  /**
   * AddOns updateManyAndReturn
   */
  export type AddOnsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * The data used to update AddOns.
     */
    data: XOR<AddOnsUpdateManyMutationInput, AddOnsUncheckedUpdateManyInput>
    /**
     * Filter which AddOns to update
     */
    where?: AddOnsWhereInput
    /**
     * Limit how many AddOns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddOns upsert
   */
  export type AddOnsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The filter to search for the AddOns to update in case it exists.
     */
    where: AddOnsWhereUniqueInput
    /**
     * In case the AddOns found by the `where` argument doesn't exist, create a new AddOns with this data.
     */
    create: XOR<AddOnsCreateInput, AddOnsUncheckedCreateInput>
    /**
     * In case the AddOns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddOnsUpdateInput, AddOnsUncheckedUpdateInput>
  }

  /**
   * AddOns delete
   */
  export type AddOnsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter which AddOns to delete.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns deleteMany
   */
  export type AddOnsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOns to delete
     */
    where?: AddOnsWhereInput
    /**
     * Limit how many AddOns to delete.
     */
    limit?: number
  }

  /**
   * AddOns.agency
   */
  export type AddOns$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * AddOns without action
   */
  export type AddOnsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    avatarUrl: 'avatarUrl',
    email: 'email',
    role: 'role',
    agencyId: 'agencyId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    connectAccountId: 'connectAccountId',
    customerId: 'customerId',
    name: 'name',
    agencyLogo: 'agencyLogo',
    companyEmail: 'companyEmail',
    companyPhone: 'companyPhone',
    whiteLabel: 'whiteLabel',
    address: 'address',
    city: 'city',
    zipCode: 'zipCode',
    state: 'state',
    country: 'country',
    goal: 'goal'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const SubAccountScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    connectAccountId: 'connectAccountId',
    name: 'name',
    subAccountLogo: 'subAccountLogo',
    companyEmail: 'companyEmail',
    companyPhone: 'companyPhone',
    goal: 'goal',
    address: 'address',
    city: 'city',
    zipCode: 'zipCode',
    state: 'state',
    country: 'country',
    agencyId: 'agencyId'
  };

  export type SubAccountScalarFieldEnum = (typeof SubAccountScalarFieldEnum)[keyof typeof SubAccountScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    subAccountId: 'subAccountId',
    access: 'access'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    color: 'color',
    subAccountId: 'subAccountId'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const PipelineScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    subAccountId: 'subAccountId'
  };

  export type PipelineScalarFieldEnum = (typeof PipelineScalarFieldEnum)[keyof typeof PipelineScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    notification: 'notification',
    agencyId: 'agencyId',
    subAccountId: 'subAccountId',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const LaneScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    pipelineId: 'pipelineId',
    order: 'order',
    color: 'color'
  };

  export type LaneScalarFieldEnum = (typeof LaneScalarFieldEnum)[keyof typeof LaneScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    laneId: 'laneId',
    order: 'order',
    value: 'value',
    description: 'description',
    customerId: 'customerId',
    assignedUserId: 'assignedUserId'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TriggerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    subAccountId: 'subAccountId',
    type: 'type'
  };

  export type TriggerScalarFieldEnum = (typeof TriggerScalarFieldEnum)[keyof typeof TriggerScalarFieldEnum]


  export const AutomationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    triggerId: 'triggerId',
    published: 'published',
    subAccountId: 'subAccountId'
  };

  export type AutomationScalarFieldEnum = (typeof AutomationScalarFieldEnum)[keyof typeof AutomationScalarFieldEnum]


  export const AutomationInstanceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    automationId: 'automationId',
    active: 'active'
  };

  export type AutomationInstanceScalarFieldEnum = (typeof AutomationInstanceScalarFieldEnum)[keyof typeof AutomationInstanceScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    order: 'order',
    automationId: 'automationId',
    laneId: 'laneId',
    type: 'type'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    email: 'email',
    subAccountId: 'subAccountId'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    name: 'name',
    link: 'link',
    subAccountId: 'subAccountId'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const FunnelScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    published: 'published',
    subDomainName: 'subDomainName',
    favicon: 'favicon',
    subAccountId: 'subAccountId',
    liveProducts: 'liveProducts'
  };

  export type FunnelScalarFieldEnum = (typeof FunnelScalarFieldEnum)[keyof typeof FunnelScalarFieldEnum]


  export const ClassNameScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    color: 'color',
    funnelId: 'funnelId',
    customData: 'customData'
  };

  export type ClassNameScalarFieldEnum = (typeof ClassNameScalarFieldEnum)[keyof typeof ClassNameScalarFieldEnum]


  export const FunnelPageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    pathName: 'pathName',
    visits: 'visits',
    content: 'content',
    order: 'order',
    previewImage: 'previewImage',
    funnelId: 'funnelId'
  };

  export type FunnelPageScalarFieldEnum = (typeof FunnelPageScalarFieldEnum)[keyof typeof FunnelPageScalarFieldEnum]


  export const AgencySidebarOptionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    link: 'link',
    icon: 'icon',
    agencyId: 'agencyId'
  };

  export type AgencySidebarOptionScalarFieldEnum = (typeof AgencySidebarOptionScalarFieldEnum)[keyof typeof AgencySidebarOptionScalarFieldEnum]


  export const SubAccountSidebarOptionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    link: 'link',
    subAccountId: 'subAccountId',
    icon: 'icon'
  };

  export type SubAccountSidebarOptionScalarFieldEnum = (typeof SubAccountSidebarOptionScalarFieldEnum)[keyof typeof SubAccountSidebarOptionScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    agencyId: 'agencyId',
    status: 'status',
    role: 'role'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    plan: 'plan',
    price: 'price',
    active: 'active',
    priceId: 'priceId',
    customerId: 'customerId',
    currentPeriodEndDate: 'currentPeriodEndDate',
    subscritiptionId: 'subscritiptionId',
    agencyId: 'agencyId'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const AddOnsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    active: 'active',
    priceId: 'priceId',
    agencyId: 'agencyId'
  };

  export type AddOnsScalarFieldEnum = (typeof AddOnsScalarFieldEnum)[keyof typeof AddOnsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'TriggerTypes'
   */
  export type EnumTriggerTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerTypes'>
    


  /**
   * Reference to a field of type 'TriggerTypes[]'
   */
  export type ListEnumTriggerTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerTypes[]'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'ActionType[]'
   */
  export type ListEnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType[]'>
    


  /**
   * Reference to a field of type 'Icon'
   */
  export type EnumIconFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Icon'>
    


  /**
   * Reference to a field of type 'Icon[]'
   */
  export type ListEnumIconFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Icon[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'Plan'
   */
  export type EnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan'>
    


  /**
   * Reference to a field of type 'Plan[]'
   */
  export type ListEnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
    avatarUrl?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    agencyId?: StringNullableFilter<"User"> | string | null
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    permissions?: PermissionsListRelationFilter
    tickets?: TicketListRelationFilter
    notification?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    role?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    agency?: AgencyOrderByWithRelationInput
    permissions?: PermissionsOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    notification?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
    avatarUrl?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    agencyId?: StringNullableFilter<"User"> | string | null
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    permissions?: PermissionsListRelationFilter
    tickets?: TicketListRelationFilter
    notification?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    role?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    name?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    agencyId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: StringFilter<"Agency"> | string
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    connectAccountId?: StringNullableFilter<"Agency"> | string | null
    customerId?: StringFilter<"Agency"> | string
    name?: StringFilter<"Agency"> | string
    agencyLogo?: StringFilter<"Agency"> | string
    companyEmail?: StringFilter<"Agency"> | string
    companyPhone?: StringFilter<"Agency"> | string
    whiteLabel?: BoolFilter<"Agency"> | boolean
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    zipCode?: StringFilter<"Agency"> | string
    state?: StringFilter<"Agency"> | string
    country?: StringFilter<"Agency"> | string
    goal?: IntFilter<"Agency"> | number
    users?: UserListRelationFilter
    subAccounts?: SubAccountListRelationFilter
    sidebarOptions?: AgencySidebarOptionListRelationFilter
    invitations?: InvitationListRelationFilter
    notifications?: NotificationListRelationFilter
    subscriptions?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    addOns?: AddOnsListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    users?: UserOrderByRelationAggregateInput
    subAccounts?: SubAccountOrderByRelationAggregateInput
    sidebarOptions?: AgencySidebarOptionOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByWithRelationInput
    addOns?: AddOnsOrderByRelationAggregateInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    connectAccountId?: StringNullableFilter<"Agency"> | string | null
    customerId?: StringFilter<"Agency"> | string
    name?: StringFilter<"Agency"> | string
    agencyLogo?: StringFilter<"Agency"> | string
    companyEmail?: StringFilter<"Agency"> | string
    companyPhone?: StringFilter<"Agency"> | string
    whiteLabel?: BoolFilter<"Agency"> | boolean
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    zipCode?: StringFilter<"Agency"> | string
    state?: StringFilter<"Agency"> | string
    country?: StringFilter<"Agency"> | string
    goal?: IntFilter<"Agency"> | number
    users?: UserListRelationFilter
    subAccounts?: SubAccountListRelationFilter
    sidebarOptions?: AgencySidebarOptionListRelationFilter
    invitations?: InvitationListRelationFilter
    notifications?: NotificationListRelationFilter
    subscriptions?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    addOns?: AddOnsListRelationFilter
  }, "id">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _avg?: AgencyAvgOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
    _sum?: AgencySumOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agency"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    connectAccountId?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    customerId?: StringWithAggregatesFilter<"Agency"> | string
    name?: StringWithAggregatesFilter<"Agency"> | string
    agencyLogo?: StringWithAggregatesFilter<"Agency"> | string
    companyEmail?: StringWithAggregatesFilter<"Agency"> | string
    companyPhone?: StringWithAggregatesFilter<"Agency"> | string
    whiteLabel?: BoolWithAggregatesFilter<"Agency"> | boolean
    address?: StringWithAggregatesFilter<"Agency"> | string
    city?: StringWithAggregatesFilter<"Agency"> | string
    zipCode?: StringWithAggregatesFilter<"Agency"> | string
    state?: StringWithAggregatesFilter<"Agency"> | string
    country?: StringWithAggregatesFilter<"Agency"> | string
    goal?: IntWithAggregatesFilter<"Agency"> | number
  }

  export type SubAccountWhereInput = {
    AND?: SubAccountWhereInput | SubAccountWhereInput[]
    OR?: SubAccountWhereInput[]
    NOT?: SubAccountWhereInput | SubAccountWhereInput[]
    id?: StringFilter<"SubAccount"> | string
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    connectAccountId?: StringNullableFilter<"SubAccount"> | string | null
    name?: StringFilter<"SubAccount"> | string
    subAccountLogo?: StringFilter<"SubAccount"> | string
    companyEmail?: StringFilter<"SubAccount"> | string
    companyPhone?: StringFilter<"SubAccount"> | string
    goal?: IntFilter<"SubAccount"> | number
    address?: StringFilter<"SubAccount"> | string
    city?: StringFilter<"SubAccount"> | string
    zipCode?: StringFilter<"SubAccount"> | string
    state?: StringFilter<"SubAccount"> | string
    country?: StringFilter<"SubAccount"> | string
    agencyId?: StringFilter<"SubAccount"> | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    sidebarOptions?: SubAccountSidebarOptionListRelationFilter
    permissions?: PermissionsListRelationFilter
    funnels?: FunnelListRelationFilter
    media?: MediaListRelationFilter
    contacts?: ContactListRelationFilter
    triggers?: TriggerListRelationFilter
    automations?: AutomationListRelationFilter
    pipelines?: PipelineListRelationFilter
    tags?: TagListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type SubAccountOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
    agency?: AgencyOrderByWithRelationInput
    sidebarOptions?: SubAccountSidebarOptionOrderByRelationAggregateInput
    permissions?: PermissionsOrderByRelationAggregateInput
    funnels?: FunnelOrderByRelationAggregateInput
    media?: MediaOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    triggers?: TriggerOrderByRelationAggregateInput
    automations?: AutomationOrderByRelationAggregateInput
    pipelines?: PipelineOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type SubAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubAccountWhereInput | SubAccountWhereInput[]
    OR?: SubAccountWhereInput[]
    NOT?: SubAccountWhereInput | SubAccountWhereInput[]
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    connectAccountId?: StringNullableFilter<"SubAccount"> | string | null
    name?: StringFilter<"SubAccount"> | string
    subAccountLogo?: StringFilter<"SubAccount"> | string
    companyEmail?: StringFilter<"SubAccount"> | string
    companyPhone?: StringFilter<"SubAccount"> | string
    goal?: IntFilter<"SubAccount"> | number
    address?: StringFilter<"SubAccount"> | string
    city?: StringFilter<"SubAccount"> | string
    zipCode?: StringFilter<"SubAccount"> | string
    state?: StringFilter<"SubAccount"> | string
    country?: StringFilter<"SubAccount"> | string
    agencyId?: StringFilter<"SubAccount"> | string
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    sidebarOptions?: SubAccountSidebarOptionListRelationFilter
    permissions?: PermissionsListRelationFilter
    funnels?: FunnelListRelationFilter
    media?: MediaListRelationFilter
    contacts?: ContactListRelationFilter
    triggers?: TriggerListRelationFilter
    automations?: AutomationListRelationFilter
    pipelines?: PipelineListRelationFilter
    tags?: TagListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type SubAccountOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
    _count?: SubAccountCountOrderByAggregateInput
    _avg?: SubAccountAvgOrderByAggregateInput
    _max?: SubAccountMaxOrderByAggregateInput
    _min?: SubAccountMinOrderByAggregateInput
    _sum?: SubAccountSumOrderByAggregateInput
  }

  export type SubAccountScalarWhereWithAggregatesInput = {
    AND?: SubAccountScalarWhereWithAggregatesInput | SubAccountScalarWhereWithAggregatesInput[]
    OR?: SubAccountScalarWhereWithAggregatesInput[]
    NOT?: SubAccountScalarWhereWithAggregatesInput | SubAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubAccount"> | Date | string
    connectAccountId?: StringNullableWithAggregatesFilter<"SubAccount"> | string | null
    name?: StringWithAggregatesFilter<"SubAccount"> | string
    subAccountLogo?: StringWithAggregatesFilter<"SubAccount"> | string
    companyEmail?: StringWithAggregatesFilter<"SubAccount"> | string
    companyPhone?: StringWithAggregatesFilter<"SubAccount"> | string
    goal?: IntWithAggregatesFilter<"SubAccount"> | number
    address?: StringWithAggregatesFilter<"SubAccount"> | string
    city?: StringWithAggregatesFilter<"SubAccount"> | string
    zipCode?: StringWithAggregatesFilter<"SubAccount"> | string
    state?: StringWithAggregatesFilter<"SubAccount"> | string
    country?: StringWithAggregatesFilter<"SubAccount"> | string
    agencyId?: StringWithAggregatesFilter<"SubAccount"> | string
  }

  export type PermissionsWhereInput = {
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    id?: StringFilter<"Permissions"> | string
    email?: StringFilter<"Permissions"> | string
    subAccountId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }

  export type PermissionsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
    user?: UserOrderByWithRelationInput
    subAccount?: SubAccountOrderByWithRelationInput
  }

  export type PermissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    email?: StringFilter<"Permissions"> | string
    subAccountId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }, "id">

  export type PermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
    _count?: PermissionsCountOrderByAggregateInput
    _max?: PermissionsMaxOrderByAggregateInput
    _min?: PermissionsMinOrderByAggregateInput
  }

  export type PermissionsScalarWhereWithAggregatesInput = {
    AND?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    OR?: PermissionsScalarWhereWithAggregatesInput[]
    NOT?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permissions"> | string
    email?: StringWithAggregatesFilter<"Permissions"> | string
    subAccountId?: StringWithAggregatesFilter<"Permissions"> | string
    access?: BoolWithAggregatesFilter<"Permissions"> | boolean
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    subAccountId?: StringFilter<"Tag"> | string
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    tickets?: TicketListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    subAccountId?: SortOrder
    subAccount?: SubAccountOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    subAccountId?: StringFilter<"Tag"> | string
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    tickets?: TicketListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    subAccountId?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    subAccountId?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type PipelineWhereInput = {
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    name?: StringFilter<"Pipeline"> | string
    subAccountId?: StringFilter<"Pipeline"> | string
    lanes?: LaneListRelationFilter
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }

  export type PipelineOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
    lanes?: LaneOrderByRelationAggregateInput
    subAccount?: SubAccountOrderByWithRelationInput
  }

  export type PipelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    name?: StringFilter<"Pipeline"> | string
    subAccountId?: StringFilter<"Pipeline"> | string
    lanes?: LaneListRelationFilter
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }, "id">

  export type PipelineOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
    _count?: PipelineCountOrderByAggregateInput
    _max?: PipelineMaxOrderByAggregateInput
    _min?: PipelineMinOrderByAggregateInput
  }

  export type PipelineScalarWhereWithAggregatesInput = {
    AND?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    OR?: PipelineScalarWhereWithAggregatesInput[]
    NOT?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pipeline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
    name?: StringWithAggregatesFilter<"Pipeline"> | string
    subAccountId?: StringWithAggregatesFilter<"Pipeline"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    notification?: StringFilter<"Notification"> | string
    agencyId?: StringFilter<"Notification"> | string
    subAccountId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    subAccount?: XOR<SubAccountNullableScalarRelationFilter, SubAccountWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    subAccount?: SubAccountOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    notification?: StringFilter<"Notification"> | string
    agencyId?: StringFilter<"Notification"> | string
    subAccountId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    subAccount?: XOR<SubAccountNullableScalarRelationFilter, SubAccountWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    notification?: StringWithAggregatesFilter<"Notification"> | string
    agencyId?: StringWithAggregatesFilter<"Notification"> | string
    subAccountId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    userId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type LaneWhereInput = {
    AND?: LaneWhereInput | LaneWhereInput[]
    OR?: LaneWhereInput[]
    NOT?: LaneWhereInput | LaneWhereInput[]
    id?: StringFilter<"Lane"> | string
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    name?: StringFilter<"Lane"> | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
    color?: StringFilter<"Lane"> | string
    pipeline?: XOR<PipelineScalarRelationFilter, PipelineWhereInput>
    tickets?: TicketListRelationFilter
  }

  export type LaneOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    color?: SortOrder
    pipeline?: PipelineOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type LaneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaneWhereInput | LaneWhereInput[]
    OR?: LaneWhereInput[]
    NOT?: LaneWhereInput | LaneWhereInput[]
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    name?: StringFilter<"Lane"> | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
    color?: StringFilter<"Lane"> | string
    pipeline?: XOR<PipelineScalarRelationFilter, PipelineWhereInput>
    tickets?: TicketListRelationFilter
  }, "id">

  export type LaneOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    color?: SortOrder
    _count?: LaneCountOrderByAggregateInput
    _avg?: LaneAvgOrderByAggregateInput
    _max?: LaneMaxOrderByAggregateInput
    _min?: LaneMinOrderByAggregateInput
    _sum?: LaneSumOrderByAggregateInput
  }

  export type LaneScalarWhereWithAggregatesInput = {
    AND?: LaneScalarWhereWithAggregatesInput | LaneScalarWhereWithAggregatesInput[]
    OR?: LaneScalarWhereWithAggregatesInput[]
    NOT?: LaneScalarWhereWithAggregatesInput | LaneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lane"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Lane"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lane"> | Date | string
    name?: StringWithAggregatesFilter<"Lane"> | string
    pipelineId?: StringWithAggregatesFilter<"Lane"> | string
    order?: IntWithAggregatesFilter<"Lane"> | number
    color?: StringWithAggregatesFilter<"Lane"> | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    name?: StringFilter<"Ticket"> | string
    laneId?: StringFilter<"Ticket"> | string
    order?: IntFilter<"Ticket"> | number
    value?: DecimalNullableFilter<"Ticket"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Ticket"> | string | null
    customerId?: StringNullableFilter<"Ticket"> | string | null
    assignedUserId?: StringNullableFilter<"Ticket"> | string | null
    lane?: XOR<LaneScalarRelationFilter, LaneWhereInput>
    customer?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    tags?: TagListRelationFilter
    assigned?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    lane?: LaneOrderByWithRelationInput
    customer?: ContactOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    assigned?: UserOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    name?: StringFilter<"Ticket"> | string
    laneId?: StringFilter<"Ticket"> | string
    order?: IntFilter<"Ticket"> | number
    value?: DecimalNullableFilter<"Ticket"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Ticket"> | string | null
    customerId?: StringNullableFilter<"Ticket"> | string | null
    assignedUserId?: StringNullableFilter<"Ticket"> | string | null
    lane?: XOR<LaneScalarRelationFilter, LaneWhereInput>
    customer?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    tags?: TagListRelationFilter
    assigned?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    name?: StringWithAggregatesFilter<"Ticket"> | string
    laneId?: StringWithAggregatesFilter<"Ticket"> | string
    order?: IntWithAggregatesFilter<"Ticket"> | number
    value?: DecimalNullableWithAggregatesFilter<"Ticket"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    assignedUserId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
  }

  export type TriggerWhereInput = {
    AND?: TriggerWhereInput | TriggerWhereInput[]
    OR?: TriggerWhereInput[]
    NOT?: TriggerWhereInput | TriggerWhereInput[]
    id?: StringFilter<"Trigger"> | string
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    name?: StringFilter<"Trigger"> | string
    subAccountId?: StringFilter<"Trigger"> | string
    type?: EnumTriggerTypesFilter<"Trigger"> | $Enums.TriggerTypes
    subaccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    automations?: AutomationListRelationFilter
  }

  export type TriggerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
    type?: SortOrder
    subaccount?: SubAccountOrderByWithRelationInput
    automations?: AutomationOrderByRelationAggregateInput
  }

  export type TriggerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TriggerWhereInput | TriggerWhereInput[]
    OR?: TriggerWhereInput[]
    NOT?: TriggerWhereInput | TriggerWhereInput[]
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    name?: StringFilter<"Trigger"> | string
    subAccountId?: StringFilter<"Trigger"> | string
    type?: EnumTriggerTypesFilter<"Trigger"> | $Enums.TriggerTypes
    subaccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    automations?: AutomationListRelationFilter
  }, "id">

  export type TriggerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
    type?: SortOrder
    _count?: TriggerCountOrderByAggregateInput
    _max?: TriggerMaxOrderByAggregateInput
    _min?: TriggerMinOrderByAggregateInput
  }

  export type TriggerScalarWhereWithAggregatesInput = {
    AND?: TriggerScalarWhereWithAggregatesInput | TriggerScalarWhereWithAggregatesInput[]
    OR?: TriggerScalarWhereWithAggregatesInput[]
    NOT?: TriggerScalarWhereWithAggregatesInput | TriggerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trigger"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trigger"> | Date | string
    name?: StringWithAggregatesFilter<"Trigger"> | string
    subAccountId?: StringWithAggregatesFilter<"Trigger"> | string
    type?: EnumTriggerTypesWithAggregatesFilter<"Trigger"> | $Enums.TriggerTypes
  }

  export type AutomationWhereInput = {
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    id?: StringFilter<"Automation"> | string
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    name?: StringFilter<"Automation"> | string
    triggerId?: StringNullableFilter<"Automation"> | string | null
    published?: BoolFilter<"Automation"> | boolean
    subAccountId?: StringFilter<"Automation"> | string
    trigger?: XOR<TriggerNullableScalarRelationFilter, TriggerWhereInput> | null
    subaccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    actions?: ActionListRelationFilter
    automationInstances?: AutomationInstanceListRelationFilter
  }

  export type AutomationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    triggerId?: SortOrderInput | SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
    trigger?: TriggerOrderByWithRelationInput
    subaccount?: SubAccountOrderByWithRelationInput
    actions?: ActionOrderByRelationAggregateInput
    automationInstances?: AutomationInstanceOrderByRelationAggregateInput
  }

  export type AutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    name?: StringFilter<"Automation"> | string
    triggerId?: StringNullableFilter<"Automation"> | string | null
    published?: BoolFilter<"Automation"> | boolean
    subAccountId?: StringFilter<"Automation"> | string
    trigger?: XOR<TriggerNullableScalarRelationFilter, TriggerWhereInput> | null
    subaccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    actions?: ActionListRelationFilter
    automationInstances?: AutomationInstanceListRelationFilter
  }, "id">

  export type AutomationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    triggerId?: SortOrderInput | SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
    _count?: AutomationCountOrderByAggregateInput
    _max?: AutomationMaxOrderByAggregateInput
    _min?: AutomationMinOrderByAggregateInput
  }

  export type AutomationScalarWhereWithAggregatesInput = {
    AND?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    OR?: AutomationScalarWhereWithAggregatesInput[]
    NOT?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Automation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    name?: StringWithAggregatesFilter<"Automation"> | string
    triggerId?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    published?: BoolWithAggregatesFilter<"Automation"> | boolean
    subAccountId?: StringWithAggregatesFilter<"Automation"> | string
  }

  export type AutomationInstanceWhereInput = {
    AND?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    OR?: AutomationInstanceWhereInput[]
    NOT?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    id?: StringFilter<"AutomationInstance"> | string
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }

  export type AutomationInstanceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
    automation?: AutomationOrderByWithRelationInput
  }

  export type AutomationInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    OR?: AutomationInstanceWhereInput[]
    NOT?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }, "id">

  export type AutomationInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
    _count?: AutomationInstanceCountOrderByAggregateInput
    _max?: AutomationInstanceMaxOrderByAggregateInput
    _min?: AutomationInstanceMinOrderByAggregateInput
  }

  export type AutomationInstanceScalarWhereWithAggregatesInput = {
    AND?: AutomationInstanceScalarWhereWithAggregatesInput | AutomationInstanceScalarWhereWithAggregatesInput[]
    OR?: AutomationInstanceScalarWhereWithAggregatesInput[]
    NOT?: AutomationInstanceScalarWhereWithAggregatesInput | AutomationInstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationInstance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationInstance"> | Date | string
    automationId?: StringWithAggregatesFilter<"AutomationInstance"> | string
    active?: BoolWithAggregatesFilter<"AutomationInstance"> | boolean
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    id?: StringFilter<"Action"> | string
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    name?: StringFilter<"Action"> | string
    order?: IntFilter<"Action"> | number
    automationId?: StringFilter<"Action"> | string
    laneId?: StringFilter<"Action"> | string
    type?: EnumActionTypeFilter<"Action"> | $Enums.ActionType
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }

  export type ActionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    order?: SortOrder
    automationId?: SortOrder
    laneId?: SortOrder
    type?: SortOrder
    automation?: AutomationOrderByWithRelationInput
  }

  export type ActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    name?: StringFilter<"Action"> | string
    order?: IntFilter<"Action"> | number
    automationId?: StringFilter<"Action"> | string
    laneId?: StringFilter<"Action"> | string
    type?: EnumActionTypeFilter<"Action"> | $Enums.ActionType
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }, "id">

  export type ActionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    order?: SortOrder
    automationId?: SortOrder
    laneId?: SortOrder
    type?: SortOrder
    _count?: ActionCountOrderByAggregateInput
    _avg?: ActionAvgOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
    _sum?: ActionSumOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    OR?: ActionScalarWhereWithAggregatesInput[]
    NOT?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Action"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
    name?: StringWithAggregatesFilter<"Action"> | string
    order?: IntWithAggregatesFilter<"Action"> | number
    automationId?: StringWithAggregatesFilter<"Action"> | string
    laneId?: StringWithAggregatesFilter<"Action"> | string
    type?: EnumActionTypeWithAggregatesFilter<"Action"> | $Enums.ActionType
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    subAccountId?: StringFilter<"Contact"> | string
    subaccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    tickets?: TicketListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    subaccount?: SubAccountOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    subAccountId?: StringFilter<"Contact"> | string
    subaccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    tickets?: TicketListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    subAccountId?: StringWithAggregatesFilter<"Contact"> | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    link?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    subAccount?: SubAccountOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    link?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }, "id" | "link">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    type?: StringNullableWithAggregatesFilter<"Media"> | string | null
    name?: StringWithAggregatesFilter<"Media"> | string
    link?: StringWithAggregatesFilter<"Media"> | string
    subAccountId?: StringWithAggregatesFilter<"Media"> | string
  }

  export type FunnelWhereInput = {
    AND?: FunnelWhereInput | FunnelWhereInput[]
    OR?: FunnelWhereInput[]
    NOT?: FunnelWhereInput | FunnelWhereInput[]
    id?: StringFilter<"Funnel"> | string
    createdAt?: DateTimeFilter<"Funnel"> | Date | string
    updatedAt?: DateTimeFilter<"Funnel"> | Date | string
    name?: StringFilter<"Funnel"> | string
    description?: StringNullableFilter<"Funnel"> | string | null
    published?: BoolFilter<"Funnel"> | boolean
    subDomainName?: StringNullableFilter<"Funnel"> | string | null
    favicon?: StringNullableFilter<"Funnel"> | string | null
    subAccountId?: StringFilter<"Funnel"> | string
    liveProducts?: StringNullableFilter<"Funnel"> | string | null
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    funnelPages?: FunnelPageListRelationFilter
    className?: ClassNameListRelationFilter
  }

  export type FunnelOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    published?: SortOrder
    subDomainName?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrderInput | SortOrder
    subAccount?: SubAccountOrderByWithRelationInput
    funnelPages?: FunnelPageOrderByRelationAggregateInput
    className?: ClassNameOrderByRelationAggregateInput
  }

  export type FunnelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subDomainName?: string
    AND?: FunnelWhereInput | FunnelWhereInput[]
    OR?: FunnelWhereInput[]
    NOT?: FunnelWhereInput | FunnelWhereInput[]
    createdAt?: DateTimeFilter<"Funnel"> | Date | string
    updatedAt?: DateTimeFilter<"Funnel"> | Date | string
    name?: StringFilter<"Funnel"> | string
    description?: StringNullableFilter<"Funnel"> | string | null
    published?: BoolFilter<"Funnel"> | boolean
    favicon?: StringNullableFilter<"Funnel"> | string | null
    subAccountId?: StringFilter<"Funnel"> | string
    liveProducts?: StringNullableFilter<"Funnel"> | string | null
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    funnelPages?: FunnelPageListRelationFilter
    className?: ClassNameListRelationFilter
  }, "id" | "subDomainName">

  export type FunnelOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    published?: SortOrder
    subDomainName?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrderInput | SortOrder
    _count?: FunnelCountOrderByAggregateInput
    _max?: FunnelMaxOrderByAggregateInput
    _min?: FunnelMinOrderByAggregateInput
  }

  export type FunnelScalarWhereWithAggregatesInput = {
    AND?: FunnelScalarWhereWithAggregatesInput | FunnelScalarWhereWithAggregatesInput[]
    OR?: FunnelScalarWhereWithAggregatesInput[]
    NOT?: FunnelScalarWhereWithAggregatesInput | FunnelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Funnel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Funnel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Funnel"> | Date | string
    name?: StringWithAggregatesFilter<"Funnel"> | string
    description?: StringNullableWithAggregatesFilter<"Funnel"> | string | null
    published?: BoolWithAggregatesFilter<"Funnel"> | boolean
    subDomainName?: StringNullableWithAggregatesFilter<"Funnel"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"Funnel"> | string | null
    subAccountId?: StringWithAggregatesFilter<"Funnel"> | string
    liveProducts?: StringNullableWithAggregatesFilter<"Funnel"> | string | null
  }

  export type ClassNameWhereInput = {
    AND?: ClassNameWhereInput | ClassNameWhereInput[]
    OR?: ClassNameWhereInput[]
    NOT?: ClassNameWhereInput | ClassNameWhereInput[]
    id?: StringFilter<"ClassName"> | string
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    funnelId?: StringFilter<"ClassName"> | string
    customData?: StringNullableFilter<"ClassName"> | string | null
    funnel?: XOR<FunnelScalarRelationFilter, FunnelWhereInput>
  }

  export type ClassNameOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrderInput | SortOrder
    funnel?: FunnelOrderByWithRelationInput
  }

  export type ClassNameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassNameWhereInput | ClassNameWhereInput[]
    OR?: ClassNameWhereInput[]
    NOT?: ClassNameWhereInput | ClassNameWhereInput[]
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    funnelId?: StringFilter<"ClassName"> | string
    customData?: StringNullableFilter<"ClassName"> | string | null
    funnel?: XOR<FunnelScalarRelationFilter, FunnelWhereInput>
  }, "id">

  export type ClassNameOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrderInput | SortOrder
    _count?: ClassNameCountOrderByAggregateInput
    _max?: ClassNameMaxOrderByAggregateInput
    _min?: ClassNameMinOrderByAggregateInput
  }

  export type ClassNameScalarWhereWithAggregatesInput = {
    AND?: ClassNameScalarWhereWithAggregatesInput | ClassNameScalarWhereWithAggregatesInput[]
    OR?: ClassNameScalarWhereWithAggregatesInput[]
    NOT?: ClassNameScalarWhereWithAggregatesInput | ClassNameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassName"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassName"> | Date | string
    name?: StringWithAggregatesFilter<"ClassName"> | string
    color?: StringWithAggregatesFilter<"ClassName"> | string
    funnelId?: StringWithAggregatesFilter<"ClassName"> | string
    customData?: StringNullableWithAggregatesFilter<"ClassName"> | string | null
  }

  export type FunnelPageWhereInput = {
    AND?: FunnelPageWhereInput | FunnelPageWhereInput[]
    OR?: FunnelPageWhereInput[]
    NOT?: FunnelPageWhereInput | FunnelPageWhereInput[]
    id?: StringFilter<"FunnelPage"> | string
    createdAt?: DateTimeFilter<"FunnelPage"> | Date | string
    updatedAt?: DateTimeFilter<"FunnelPage"> | Date | string
    name?: StringFilter<"FunnelPage"> | string
    pathName?: StringFilter<"FunnelPage"> | string
    visits?: IntFilter<"FunnelPage"> | number
    content?: StringNullableFilter<"FunnelPage"> | string | null
    order?: IntFilter<"FunnelPage"> | number
    previewImage?: StringNullableFilter<"FunnelPage"> | string | null
    funnelId?: StringFilter<"FunnelPage"> | string
    funnel?: XOR<FunnelScalarRelationFilter, FunnelWhereInput>
  }

  export type FunnelPageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    visits?: SortOrder
    content?: SortOrderInput | SortOrder
    order?: SortOrder
    previewImage?: SortOrderInput | SortOrder
    funnelId?: SortOrder
    funnel?: FunnelOrderByWithRelationInput
  }

  export type FunnelPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FunnelPageWhereInput | FunnelPageWhereInput[]
    OR?: FunnelPageWhereInput[]
    NOT?: FunnelPageWhereInput | FunnelPageWhereInput[]
    createdAt?: DateTimeFilter<"FunnelPage"> | Date | string
    updatedAt?: DateTimeFilter<"FunnelPage"> | Date | string
    name?: StringFilter<"FunnelPage"> | string
    pathName?: StringFilter<"FunnelPage"> | string
    visits?: IntFilter<"FunnelPage"> | number
    content?: StringNullableFilter<"FunnelPage"> | string | null
    order?: IntFilter<"FunnelPage"> | number
    previewImage?: StringNullableFilter<"FunnelPage"> | string | null
    funnelId?: StringFilter<"FunnelPage"> | string
    funnel?: XOR<FunnelScalarRelationFilter, FunnelWhereInput>
  }, "id">

  export type FunnelPageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    visits?: SortOrder
    content?: SortOrderInput | SortOrder
    order?: SortOrder
    previewImage?: SortOrderInput | SortOrder
    funnelId?: SortOrder
    _count?: FunnelPageCountOrderByAggregateInput
    _avg?: FunnelPageAvgOrderByAggregateInput
    _max?: FunnelPageMaxOrderByAggregateInput
    _min?: FunnelPageMinOrderByAggregateInput
    _sum?: FunnelPageSumOrderByAggregateInput
  }

  export type FunnelPageScalarWhereWithAggregatesInput = {
    AND?: FunnelPageScalarWhereWithAggregatesInput | FunnelPageScalarWhereWithAggregatesInput[]
    OR?: FunnelPageScalarWhereWithAggregatesInput[]
    NOT?: FunnelPageScalarWhereWithAggregatesInput | FunnelPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FunnelPage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FunnelPage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FunnelPage"> | Date | string
    name?: StringWithAggregatesFilter<"FunnelPage"> | string
    pathName?: StringWithAggregatesFilter<"FunnelPage"> | string
    visits?: IntWithAggregatesFilter<"FunnelPage"> | number
    content?: StringNullableWithAggregatesFilter<"FunnelPage"> | string | null
    order?: IntWithAggregatesFilter<"FunnelPage"> | number
    previewImage?: StringNullableWithAggregatesFilter<"FunnelPage"> | string | null
    funnelId?: StringWithAggregatesFilter<"FunnelPage"> | string
  }

  export type AgencySidebarOptionWhereInput = {
    AND?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    OR?: AgencySidebarOptionWhereInput[]
    NOT?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    id?: StringFilter<"AgencySidebarOption"> | string
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    agencyId?: StringFilter<"AgencySidebarOption"> | string
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type AgencySidebarOptionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
    agency?: AgencyOrderByWithRelationInput
  }

  export type AgencySidebarOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    OR?: AgencySidebarOptionWhereInput[]
    NOT?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    agencyId?: StringFilter<"AgencySidebarOption"> | string
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id">

  export type AgencySidebarOptionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
    _count?: AgencySidebarOptionCountOrderByAggregateInput
    _max?: AgencySidebarOptionMaxOrderByAggregateInput
    _min?: AgencySidebarOptionMinOrderByAggregateInput
  }

  export type AgencySidebarOptionScalarWhereWithAggregatesInput = {
    AND?: AgencySidebarOptionScalarWhereWithAggregatesInput | AgencySidebarOptionScalarWhereWithAggregatesInput[]
    OR?: AgencySidebarOptionScalarWhereWithAggregatesInput[]
    NOT?: AgencySidebarOptionScalarWhereWithAggregatesInput | AgencySidebarOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencySidebarOption"> | Date | string
    name?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    link?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    icon?: EnumIconWithAggregatesFilter<"AgencySidebarOption"> | $Enums.Icon
    agencyId?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
  }

  export type SubAccountSidebarOptionWhereInput = {
    AND?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    OR?: SubAccountSidebarOptionWhereInput[]
    NOT?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    id?: StringFilter<"SubAccountSidebarOption"> | string
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    subAccountId?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
    subAccount?: XOR<SubAccountNullableScalarRelationFilter, SubAccountWhereInput> | null
  }

  export type SubAccountSidebarOptionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    icon?: SortOrder
    subAccount?: SubAccountOrderByWithRelationInput
  }

  export type SubAccountSidebarOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    OR?: SubAccountSidebarOptionWhereInput[]
    NOT?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    subAccountId?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
    subAccount?: XOR<SubAccountNullableScalarRelationFilter, SubAccountWhereInput> | null
  }, "id">

  export type SubAccountSidebarOptionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    icon?: SortOrder
    _count?: SubAccountSidebarOptionCountOrderByAggregateInput
    _max?: SubAccountSidebarOptionMaxOrderByAggregateInput
    _min?: SubAccountSidebarOptionMinOrderByAggregateInput
  }

  export type SubAccountSidebarOptionScalarWhereWithAggregatesInput = {
    AND?: SubAccountSidebarOptionScalarWhereWithAggregatesInput | SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    OR?: SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    NOT?: SubAccountSidebarOptionScalarWhereWithAggregatesInput | SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubAccountSidebarOption"> | Date | string
    name?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    link?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    subAccountId?: StringNullableWithAggregatesFilter<"SubAccountSidebarOption"> | string | null
    icon?: EnumIconWithAggregatesFilter<"SubAccountSidebarOption"> | $Enums.Icon
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    agencyId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitation"> | $Enums.Role
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    agency?: AgencyOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    agencyId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitation"> | $Enums.Role
    agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "id" | "email">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    email?: StringWithAggregatesFilter<"Invitation"> | string
    agencyId?: StringWithAggregatesFilter<"Invitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"Invitation"> | $Enums.InvitationStatus
    role?: EnumRoleWithAggregatesFilter<"Invitation"> | $Enums.Role
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    plan?: EnumPlanNullableFilter<"Subscription"> | $Enums.Plan | null
    price?: StringNullableFilter<"Subscription"> | string | null
    active?: BoolFilter<"Subscription"> | boolean
    priceId?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    currentPeriodEndDate?: DateTimeFilter<"Subscription"> | Date | string
    subscritiptionId?: StringFilter<"Subscription"> | string
    agencyId?: StringNullableFilter<"Subscription"> | string | null
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscritiptionId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    agency?: AgencyOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subscritiptionId?: string
    agencyId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    plan?: EnumPlanNullableFilter<"Subscription"> | $Enums.Plan | null
    price?: StringNullableFilter<"Subscription"> | string | null
    active?: BoolFilter<"Subscription"> | boolean
    priceId?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    currentPeriodEndDate?: DateTimeFilter<"Subscription"> | Date | string
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id" | "subscritiptionId" | "agencyId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscritiptionId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    plan?: EnumPlanNullableWithAggregatesFilter<"Subscription"> | $Enums.Plan | null
    price?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    active?: BoolWithAggregatesFilter<"Subscription"> | boolean
    priceId?: StringWithAggregatesFilter<"Subscription"> | string
    customerId?: StringWithAggregatesFilter<"Subscription"> | string
    currentPeriodEndDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    subscritiptionId?: StringWithAggregatesFilter<"Subscription"> | string
    agencyId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
  }

  export type AddOnsWhereInput = {
    AND?: AddOnsWhereInput | AddOnsWhereInput[]
    OR?: AddOnsWhereInput[]
    NOT?: AddOnsWhereInput | AddOnsWhereInput[]
    id?: StringFilter<"AddOns"> | string
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    priceId?: StringFilter<"AddOns"> | string
    agencyId?: StringNullableFilter<"AddOns"> | string | null
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type AddOnsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    agency?: AgencyOrderByWithRelationInput
  }

  export type AddOnsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    priceId?: string
    AND?: AddOnsWhereInput | AddOnsWhereInput[]
    OR?: AddOnsWhereInput[]
    NOT?: AddOnsWhereInput | AddOnsWhereInput[]
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    agencyId?: StringNullableFilter<"AddOns"> | string | null
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id" | "priceId">

  export type AddOnsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: AddOnsCountOrderByAggregateInput
    _max?: AddOnsMaxOrderByAggregateInput
    _min?: AddOnsMinOrderByAggregateInput
  }

  export type AddOnsScalarWhereWithAggregatesInput = {
    AND?: AddOnsScalarWhereWithAggregatesInput | AddOnsScalarWhereWithAggregatesInput[]
    OR?: AddOnsScalarWhereWithAggregatesInput[]
    NOT?: AddOnsScalarWhereWithAggregatesInput | AddOnsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AddOns"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AddOns"> | Date | string
    name?: StringWithAggregatesFilter<"AddOns"> | string
    active?: BoolWithAggregatesFilter<"AddOns"> | boolean
    priceId?: StringWithAggregatesFilter<"AddOns"> | string
    agencyId?: StringNullableWithAggregatesFilter<"AddOns"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agency?: AgencyCreateNestedOneWithoutUsersInput
    permissions?: PermissionsCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutAssignedInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agencyId?: string | null
    permissions?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssignedInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    permissions?: PermissionsUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutAssignedNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionsUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssignedNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agencyId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgencyCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    invitations?: InvitationCreateNestedManyWithoutAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
  }

  export type AgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
  }

  export type SubAccountCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
  }

  export type SubAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionsCreateInput = {
    id?: string
    access: boolean
    user: UserCreateNestedOneWithoutPermissionsInput
    subAccount: SubAccountCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateInput = {
    id?: string
    email: string
    subAccountId: string
    access: boolean
  }

  export type PermissionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
    subAccount?: SubAccountUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsCreateManyInput = {
    id?: string
    email: string
    subAccountId: string
    access: boolean
  }

  export type PermissionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TagCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    subAccount: SubAccountCreateNestedOneWithoutTagsInput
    tickets?: TicketCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    subAccountId: string
    tickets?: TicketUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    subAccount?: SubAccountUpdateOneRequiredWithoutTagsNestedInput
    tickets?: TicketUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    subAccountId: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    lanes?: LaneCreateNestedManyWithoutPipelineInput
    subAccount: SubAccountCreateNestedOneWithoutPipelinesInput
  }

  export type PipelineUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    subAccountId: string
    lanes?: LaneUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lanes?: LaneUpdateManyWithoutPipelineNestedInput
    subAccount?: SubAccountUpdateOneRequiredWithoutPipelinesNestedInput
  }

  export type PipelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    lanes?: LaneUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    subAccountId: string
  }

  export type PipelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    user: UserCreateNestedOneWithoutNotificationInput
    agency: AgencyCreateNestedOneWithoutNotificationsInput
    subAccount?: SubAccountCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    agencyId: string
    subAccountId?: string | null
    userId: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
    agency?: AgencyUpdateOneRequiredWithoutNotificationsNestedInput
    subAccount?: SubAccountUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    agencyId: string
    subAccountId?: string | null
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LaneCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    color: string
    pipeline: PipelineCreateNestedOneWithoutLanesInput
    tickets?: TicketCreateNestedManyWithoutLaneInput
  }

  export type LaneUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pipelineId: string
    order?: number
    color: string
    tickets?: TicketUncheckedCreateNestedManyWithoutLaneInput
  }

  export type LaneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    pipeline?: PipelineUpdateOneRequiredWithoutLanesNestedInput
    tickets?: TicketUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUncheckedUpdateManyWithoutLaneNestedInput
  }

  export type LaneCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pipelineId: string
    order?: number
    color: string
  }

  export type LaneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type LaneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    lane: LaneCreateNestedOneWithoutTicketsInput
    customer?: ContactCreateNestedOneWithoutTicketsInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    assigned?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    customer?: ContactUpdateOneWithoutTicketsNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    assigned?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TriggerCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: $Enums.TriggerTypes
    subaccount: SubAccountCreateNestedOneWithoutTriggersInput
    automations?: AutomationCreateNestedManyWithoutTriggerInput
  }

  export type TriggerUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    subAccountId: string
    type: $Enums.TriggerTypes
    automations?: AutomationUncheckedCreateNestedManyWithoutTriggerInput
  }

  export type TriggerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    subaccount?: SubAccountUpdateOneRequiredWithoutTriggersNestedInput
    automations?: AutomationUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    automations?: AutomationUncheckedUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    subAccountId: string
    type: $Enums.TriggerTypes
  }

  export type TriggerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
  }

  export type TriggerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
  }

  export type AutomationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    published?: boolean
    trigger?: TriggerCreateNestedOneWithoutAutomationsInput
    subaccount: SubAccountCreateNestedOneWithoutAutomationsInput
    actions?: ActionCreateNestedManyWithoutAutomationInput
    automationInstances?: AutomationInstanceCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    actions?: ActionUncheckedCreateNestedManyWithoutAutomationInput
    automationInstances?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    trigger?: TriggerUpdateOneWithoutAutomationsNestedInput
    subaccount?: SubAccountUpdateOneRequiredWithoutAutomationsNestedInput
    actions?: ActionUpdateManyWithoutAutomationNestedInput
    automationInstances?: AutomationInstanceUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    actions?: ActionUncheckedUpdateManyWithoutAutomationNestedInput
    automationInstances?: AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
  }

  export type AutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationInstanceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    automation: AutomationCreateNestedOneWithoutAutomationInstancesInput
  }

  export type AutomationInstanceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    automationId: string
    active?: boolean
  }

  export type AutomationInstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    automation?: AutomationUpdateOneRequiredWithoutAutomationInstancesNestedInput
  }

  export type AutomationInstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automationId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    automationId: string
    active?: boolean
  }

  export type AutomationInstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automationId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order: number
    laneId?: string
    type: $Enums.ActionType
    automation: AutomationCreateNestedOneWithoutActionsInput
  }

  export type ActionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order: number
    automationId: string
    laneId?: string
    type: $Enums.ActionType
  }

  export type ActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    automation?: AutomationUpdateOneRequiredWithoutActionsNestedInput
  }

  export type ActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    automationId?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
  }

  export type ActionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order: number
    automationId: string
    laneId?: string
    type: $Enums.ActionType
  }

  export type ActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    automationId?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
  }

  export type ContactCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    subaccount: SubAccountCreateNestedOneWithoutContactsInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    subAccountId: string
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subaccount?: SubAccountUpdateOneRequiredWithoutContactsNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    subAccountId: string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    name: string
    link: string
    subAccount: SubAccountCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    name: string
    link: string
    subAccountId: string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccount?: SubAccountUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    name: string
    link: string
    subAccountId: string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type FunnelCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    subAccount: SubAccountCreateNestedOneWithoutFunnelsInput
    funnelPages?: FunnelPageCreateNestedManyWithoutFunnelInput
    className?: ClassNameCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    funnelPages?: FunnelPageUncheckedCreateNestedManyWithoutFunnelInput
    className?: ClassNameUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    subAccount?: SubAccountUpdateOneRequiredWithoutFunnelsNestedInput
    funnelPages?: FunnelPageUpdateManyWithoutFunnelNestedInput
    className?: ClassNameUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    funnelPages?: FunnelPageUncheckedUpdateManyWithoutFunnelNestedInput
    className?: ClassNameUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
  }

  export type FunnelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    customData?: string | null
    funnel: FunnelCreateNestedOneWithoutClassNameInput
  }

  export type ClassNameUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    funnelId: string
    customData?: string | null
  }

  export type ClassNameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
    funnel?: FunnelUpdateOneRequiredWithoutClassNameNestedInput
  }

  export type ClassNameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    funnelId?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    funnelId: string
    customData?: string | null
  }

  export type ClassNameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    funnelId?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPageCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pathName?: string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
    funnel: FunnelCreateNestedOneWithoutFunnelPagesInput
  }

  export type FunnelPageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pathName?: string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
    funnelId: string
  }

  export type FunnelPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
    funnel?: FunnelUpdateOneRequiredWithoutFunnelPagesNestedInput
  }

  export type FunnelPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
    funnelId?: StringFieldUpdateOperationsInput | string
  }

  export type FunnelPageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pathName?: string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
    funnelId: string
  }

  export type FunnelPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
    funnelId?: StringFieldUpdateOperationsInput | string
  }

  export type AgencySidebarOptionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
    agency?: AgencyCreateNestedOneWithoutSidebarOptionsInput
  }

  export type AgencySidebarOptionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
    agencyId: string
  }

  export type AgencySidebarOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    agency?: AgencyUpdateOneWithoutSidebarOptionsNestedInput
  }

  export type AgencySidebarOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type AgencySidebarOptionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
    agencyId: string
  }

  export type AgencySidebarOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type AgencySidebarOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountSidebarOptionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
    subAccount?: SubAccountCreateNestedOneWithoutSidebarOptionsInput
  }

  export type SubAccountSidebarOptionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    subAccountId?: string | null
    icon?: $Enums.Icon
  }

  export type SubAccountSidebarOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    subAccount?: SubAccountUpdateOneWithoutSidebarOptionsNestedInput
  }

  export type SubAccountSidebarOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type SubAccountSidebarOptionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    subAccountId?: string | null
    icon?: $Enums.Icon
  }

  export type SubAccountSidebarOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
    agency: AgencyCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    email: string
    agencyId: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agency?: AgencyUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationCreateManyInput = {
    id?: string
    email: string
    agencyId: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type SubscriptionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscritiptionId: string
    agency?: AgencyCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscritiptionId: string
    agencyId?: string | null
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscritiptionId?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscritiptionId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscritiptionId: string
    agencyId?: string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscritiptionId?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscritiptionId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddOnsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    agency?: AgencyCreateNestedOneWithoutAddOnsInput
  }

  export type AddOnsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    agencyId?: string | null
  }

  export type AddOnsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneWithoutAddOnsNestedInput
  }

  export type AddOnsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddOnsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    agencyId?: string | null
  }

  export type AddOnsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AgencyNullableScalarRelationFilter = {
    is?: AgencyWhereInput | null
    isNot?: AgencyWhereInput | null
  }

  export type PermissionsListRelationFilter = {
    every?: PermissionsWhereInput
    some?: PermissionsWhereInput
    none?: PermissionsWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SubAccountListRelationFilter = {
    every?: SubAccountWhereInput
    some?: SubAccountWhereInput
    none?: SubAccountWhereInput
  }

  export type AgencySidebarOptionListRelationFilter = {
    every?: AgencySidebarOptionWhereInput
    some?: AgencySidebarOptionWhereInput
    none?: AgencySidebarOptionWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type AddOnsListRelationFilter = {
    every?: AddOnsWhereInput
    some?: AddOnsWhereInput
    none?: AddOnsWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencySidebarOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddOnsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
  }

  export type AgencyAvgOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
  }

  export type AgencySumOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AgencyScalarRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type SubAccountSidebarOptionListRelationFilter = {
    every?: SubAccountSidebarOptionWhereInput
    some?: SubAccountSidebarOptionWhereInput
    none?: SubAccountSidebarOptionWhereInput
  }

  export type FunnelListRelationFilter = {
    every?: FunnelWhereInput
    some?: FunnelWhereInput
    none?: FunnelWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type TriggerListRelationFilter = {
    every?: TriggerWhereInput
    some?: TriggerWhereInput
    none?: TriggerWhereInput
  }

  export type AutomationListRelationFilter = {
    every?: AutomationWhereInput
    some?: AutomationWhereInput
    none?: AutomationWhereInput
  }

  export type PipelineListRelationFilter = {
    every?: PipelineWhereInput
    some?: PipelineWhereInput
    none?: PipelineWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type SubAccountSidebarOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FunnelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriggerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubAccountCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountAvgOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type SubAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountSumOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SubAccountScalarRelationFilter = {
    is?: SubAccountWhereInput
    isNot?: SubAccountWhereInput
  }

  export type PermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
  }

  export type PermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
  }

  export type PermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    subAccountId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    subAccountId?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    subAccountId?: SortOrder
  }

  export type LaneListRelationFilter = {
    every?: LaneWhereInput
    some?: LaneWhereInput
    none?: LaneWhereInput
  }

  export type LaneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
  }

  export type PipelineMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
  }

  export type PipelineMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
  }

  export type SubAccountNullableScalarRelationFilter = {
    is?: SubAccountWhereInput | null
    isNot?: SubAccountWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
  }

  export type PipelineScalarRelationFilter = {
    is?: PipelineWhereInput
    isNot?: PipelineWhereInput
  }

  export type LaneCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    color?: SortOrder
  }

  export type LaneAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LaneMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    color?: SortOrder
  }

  export type LaneMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    color?: SortOrder
  }

  export type LaneSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type LaneScalarRelationFilter = {
    is?: LaneWhereInput
    isNot?: LaneWhereInput
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    order?: SortOrder
    value?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    order?: SortOrder
    value?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumTriggerTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypesFilter<$PrismaModel> | $Enums.TriggerTypes
  }

  export type TriggerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
    type?: SortOrder
  }

  export type TriggerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
    type?: SortOrder
  }

  export type TriggerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    subAccountId?: SortOrder
    type?: SortOrder
  }

  export type EnumTriggerTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel> | $Enums.TriggerTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypesFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypesFilter<$PrismaModel>
  }

  export type TriggerNullableScalarRelationFilter = {
    is?: TriggerWhereInput | null
    isNot?: TriggerWhereInput | null
  }

  export type ActionListRelationFilter = {
    every?: ActionWhereInput
    some?: ActionWhereInput
    none?: ActionWhereInput
  }

  export type AutomationInstanceListRelationFilter = {
    every?: AutomationInstanceWhereInput
    some?: AutomationInstanceWhereInput
    none?: AutomationInstanceWhereInput
  }

  export type ActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationScalarRelationFilter = {
    is?: AutomationWhereInput
    isNot?: AutomationWhereInput
  }

  export type AutomationInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type AutomationInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type AutomationInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type ActionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    order?: SortOrder
    automationId?: SortOrder
    laneId?: SortOrder
    type?: SortOrder
  }

  export type ActionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    order?: SortOrder
    automationId?: SortOrder
    laneId?: SortOrder
    type?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    order?: SortOrder
    automationId?: SortOrder
    laneId?: SortOrder
    type?: SortOrder
  }

  export type ActionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
  }

  export type FunnelPageListRelationFilter = {
    every?: FunnelPageWhereInput
    some?: FunnelPageWhereInput
    none?: FunnelPageWhereInput
  }

  export type ClassNameListRelationFilter = {
    every?: ClassNameWhereInput
    some?: ClassNameWhereInput
    none?: ClassNameWhereInput
  }

  export type FunnelPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassNameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FunnelCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type FunnelMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type FunnelMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type FunnelScalarRelationFilter = {
    is?: FunnelWhereInput
    isNot?: FunnelWhereInput
  }

  export type ClassNameCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrder
  }

  export type ClassNameMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrder
  }

  export type ClassNameMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    color?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrder
  }

  export type FunnelPageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunnelPageAvgOrderByAggregateInput = {
    visits?: SortOrder
    order?: SortOrder
  }

  export type FunnelPageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunnelPageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunnelPageSumOrderByAggregateInput = {
    visits?: SortOrder
    order?: SortOrder
  }

  export type EnumIconFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    notIn?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    not?: NestedEnumIconFilter<$PrismaModel> | $Enums.Icon
  }

  export type AgencySidebarOptionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencySidebarOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencySidebarOptionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
  }

  export type EnumIconWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    notIn?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    not?: NestedEnumIconWithAggregatesFilter<$PrismaModel> | $Enums.Icon
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconFilter<$PrismaModel>
    _max?: NestedEnumIconFilter<$PrismaModel>
  }

  export type SubAccountSidebarOptionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    icon?: SortOrder
  }

  export type SubAccountSidebarOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    icon?: SortOrder
  }

  export type SubAccountSidebarOptionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    icon?: SortOrder
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type EnumPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableFilter<$PrismaModel> | $Enums.Plan | null
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscritiptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscritiptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscritiptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type EnumPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanNullableFilter<$PrismaModel>
  }

  export type AddOnsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AddOnsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AddOnsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyCreateNestedOneWithoutUsersInput = {
    create?: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUsersInput
    connect?: AgencyWhereUniqueInput
  }

  export type PermissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput> | PermissionsCreateWithoutUserInput[] | PermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUserInput | PermissionsCreateOrConnectWithoutUserInput[]
    createMany?: PermissionsCreateManyUserInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAssignedInput = {
    create?: XOR<TicketCreateWithoutAssignedInput, TicketUncheckedCreateWithoutAssignedInput> | TicketCreateWithoutAssignedInput[] | TicketUncheckedCreateWithoutAssignedInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedInput | TicketCreateOrConnectWithoutAssignedInput[]
    createMany?: TicketCreateManyAssignedInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PermissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput> | PermissionsCreateWithoutUserInput[] | PermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUserInput | PermissionsCreateOrConnectWithoutUserInput[]
    createMany?: PermissionsCreateManyUserInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAssignedInput = {
    create?: XOR<TicketCreateWithoutAssignedInput, TicketUncheckedCreateWithoutAssignedInput> | TicketCreateWithoutAssignedInput[] | TicketUncheckedCreateWithoutAssignedInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedInput | TicketCreateOrConnectWithoutAssignedInput[]
    createMany?: TicketCreateManyAssignedInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AgencyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUsersInput
    upsert?: AgencyUpsertWithoutUsersInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutUsersInput, AgencyUpdateWithoutUsersInput>, AgencyUncheckedUpdateWithoutUsersInput>
  }

  export type PermissionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput> | PermissionsCreateWithoutUserInput[] | PermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUserInput | PermissionsCreateOrConnectWithoutUserInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutUserInput | PermissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PermissionsCreateManyUserInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutUserInput | PermissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutUserInput | PermissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAssignedNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedInput, TicketUncheckedCreateWithoutAssignedInput> | TicketCreateWithoutAssignedInput[] | TicketUncheckedCreateWithoutAssignedInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedInput | TicketCreateOrConnectWithoutAssignedInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedInput | TicketUpsertWithWhereUniqueWithoutAssignedInput[]
    createMany?: TicketCreateManyAssignedInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedInput | TicketUpdateWithWhereUniqueWithoutAssignedInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedInput | TicketUpdateManyWithWhereWithoutAssignedInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PermissionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput> | PermissionsCreateWithoutUserInput[] | PermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUserInput | PermissionsCreateOrConnectWithoutUserInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutUserInput | PermissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PermissionsCreateManyUserInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutUserInput | PermissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutUserInput | PermissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAssignedNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedInput, TicketUncheckedCreateWithoutAssignedInput> | TicketCreateWithoutAssignedInput[] | TicketUncheckedCreateWithoutAssignedInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedInput | TicketCreateOrConnectWithoutAssignedInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedInput | TicketUpsertWithWhereUniqueWithoutAssignedInput[]
    createMany?: TicketCreateManyAssignedInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedInput | TicketUpdateWithWhereUniqueWithoutAssignedInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedInput | TicketUpdateManyWithWhereWithoutAssignedInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SubAccountCreateNestedManyWithoutAgencyInput = {
    create?: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput> | SubAccountCreateWithoutAgencyInput[] | SubAccountUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAgencyInput | SubAccountCreateOrConnectWithoutAgencyInput[]
    createMany?: SubAccountCreateManyAgencyInputEnvelope
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
  }

  export type AgencySidebarOptionCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutAgencyInput = {
    create?: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput> | InvitationCreateWithoutAgencyInput[] | InvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAgencyInput | InvitationCreateOrConnectWithoutAgencyInput[]
    createMany?: InvitationCreateManyAgencyInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutAgencyInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutAgencyInput = {
    create?: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAgencyInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AddOnsCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SubAccountUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput> | SubAccountCreateWithoutAgencyInput[] | SubAccountUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAgencyInput | SubAccountCreateOrConnectWithoutAgencyInput[]
    createMany?: SubAccountCreateManyAgencyInputEnvelope
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
  }

  export type AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput> | InvitationCreateWithoutAgencyInput[] | InvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAgencyInput | InvitationCreateOrConnectWithoutAgencyInput[]
    createMany?: InvitationCreateManyAgencyInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutAgencyInput = {
    create?: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAgencyInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AddOnsUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAgencyInput | UserUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAgencyInput | UserUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAgencyInput | UserUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SubAccountUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput> | SubAccountCreateWithoutAgencyInput[] | SubAccountUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAgencyInput | SubAccountCreateOrConnectWithoutAgencyInput[]
    upsert?: SubAccountUpsertWithWhereUniqueWithoutAgencyInput | SubAccountUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: SubAccountCreateManyAgencyInputEnvelope
    set?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    disconnect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    delete?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    update?: SubAccountUpdateWithWhereUniqueWithoutAgencyInput | SubAccountUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: SubAccountUpdateManyWithWhereWithoutAgencyInput | SubAccountUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
  }

  export type AgencySidebarOptionUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    set?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    disconnect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    delete?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    update?: AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput | AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput> | InvitationCreateWithoutAgencyInput[] | InvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAgencyInput | InvitationCreateOrConnectWithoutAgencyInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutAgencyInput | InvitationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: InvitationCreateManyAgencyInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutAgencyInput | InvitationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutAgencyInput | InvitationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAgencyInput | NotificationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAgencyInput | NotificationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAgencyInput | NotificationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutAgencyNestedInput = {
    create?: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAgencyInput
    upsert?: SubscriptionUpsertWithoutAgencyInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutAgencyInput, SubscriptionUpdateWithoutAgencyInput>, SubscriptionUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    upsert?: AddOnsUpsertWithWhereUniqueWithoutAgencyInput | AddOnsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    set?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    disconnect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    delete?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    update?: AddOnsUpdateWithWhereUniqueWithoutAgencyInput | AddOnsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AddOnsUpdateManyWithWhereWithoutAgencyInput | AddOnsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAgencyInput | UserUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAgencyInput | UserUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAgencyInput | UserUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SubAccountUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput> | SubAccountCreateWithoutAgencyInput[] | SubAccountUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAgencyInput | SubAccountCreateOrConnectWithoutAgencyInput[]
    upsert?: SubAccountUpsertWithWhereUniqueWithoutAgencyInput | SubAccountUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: SubAccountCreateManyAgencyInputEnvelope
    set?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    disconnect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    delete?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    update?: SubAccountUpdateWithWhereUniqueWithoutAgencyInput | SubAccountUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: SubAccountUpdateManyWithWhereWithoutAgencyInput | SubAccountUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
  }

  export type AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    set?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    disconnect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    delete?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    update?: AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput | AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput> | InvitationCreateWithoutAgencyInput[] | InvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAgencyInput | InvitationCreateOrConnectWithoutAgencyInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutAgencyInput | InvitationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: InvitationCreateManyAgencyInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutAgencyInput | InvitationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutAgencyInput | InvitationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAgencyInput | NotificationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAgencyInput | NotificationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAgencyInput | NotificationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput = {
    create?: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAgencyInput
    upsert?: SubscriptionUpsertWithoutAgencyInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutAgencyInput, SubscriptionUpdateWithoutAgencyInput>, SubscriptionUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    upsert?: AddOnsUpsertWithWhereUniqueWithoutAgencyInput | AddOnsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    set?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    disconnect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    delete?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    update?: AddOnsUpdateWithWhereUniqueWithoutAgencyInput | AddOnsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AddOnsUpdateManyWithWhereWithoutAgencyInput | AddOnsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
  }

  export type AgencyCreateNestedOneWithoutSubAccountsInput = {
    create?: XOR<AgencyCreateWithoutSubAccountsInput, AgencyUncheckedCreateWithoutSubAccountsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubAccountsInput
    connect?: AgencyWhereUniqueInput
  }

  export type SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
  }

  export type PermissionsCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput> | PermissionsCreateWithoutSubAccountInput[] | PermissionsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAccountInput | PermissionsCreateOrConnectWithoutSubAccountInput[]
    createMany?: PermissionsCreateManySubAccountInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type FunnelCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<FunnelCreateWithoutSubAccountInput, FunnelUncheckedCreateWithoutSubAccountInput> | FunnelCreateWithoutSubAccountInput[] | FunnelUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelCreateOrConnectWithoutSubAccountInput | FunnelCreateOrConnectWithoutSubAccountInput[]
    createMany?: FunnelCreateManySubAccountInputEnvelope
    connect?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput> | MediaCreateWithoutSubAccountInput[] | MediaUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountInput | MediaCreateOrConnectWithoutSubAccountInput[]
    createMany?: MediaCreateManySubAccountInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutSubaccountInput = {
    create?: XOR<ContactCreateWithoutSubaccountInput, ContactUncheckedCreateWithoutSubaccountInput> | ContactCreateWithoutSubaccountInput[] | ContactUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSubaccountInput | ContactCreateOrConnectWithoutSubaccountInput[]
    createMany?: ContactCreateManySubaccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TriggerCreateNestedManyWithoutSubaccountInput = {
    create?: XOR<TriggerCreateWithoutSubaccountInput, TriggerUncheckedCreateWithoutSubaccountInput> | TriggerCreateWithoutSubaccountInput[] | TriggerUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutSubaccountInput | TriggerCreateOrConnectWithoutSubaccountInput[]
    createMany?: TriggerCreateManySubaccountInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type AutomationCreateNestedManyWithoutSubaccountInput = {
    create?: XOR<AutomationCreateWithoutSubaccountInput, AutomationUncheckedCreateWithoutSubaccountInput> | AutomationCreateWithoutSubaccountInput[] | AutomationUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutSubaccountInput | AutomationCreateOrConnectWithoutSubaccountInput[]
    createMany?: AutomationCreateManySubaccountInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type PipelineCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput> | PipelineCreateWithoutSubAccountInput[] | PipelineUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutSubAccountInput | PipelineCreateOrConnectWithoutSubAccountInput[]
    createMany?: PipelineCreateManySubAccountInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<TagCreateWithoutSubAccountInput, TagUncheckedCreateWithoutSubAccountInput> | TagCreateWithoutSubAccountInput[] | TagUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSubAccountInput | TagCreateOrConnectWithoutSubAccountInput[]
    createMany?: TagCreateManySubAccountInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput> | NotificationCreateWithoutSubAccountInput[] | NotificationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSubAccountInput | NotificationCreateOrConnectWithoutSubAccountInput[]
    createMany?: NotificationCreateManySubAccountInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
  }

  export type PermissionsUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput> | PermissionsCreateWithoutSubAccountInput[] | PermissionsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAccountInput | PermissionsCreateOrConnectWithoutSubAccountInput[]
    createMany?: PermissionsCreateManySubAccountInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type FunnelUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<FunnelCreateWithoutSubAccountInput, FunnelUncheckedCreateWithoutSubAccountInput> | FunnelCreateWithoutSubAccountInput[] | FunnelUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelCreateOrConnectWithoutSubAccountInput | FunnelCreateOrConnectWithoutSubAccountInput[]
    createMany?: FunnelCreateManySubAccountInputEnvelope
    connect?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput> | MediaCreateWithoutSubAccountInput[] | MediaUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountInput | MediaCreateOrConnectWithoutSubAccountInput[]
    createMany?: MediaCreateManySubAccountInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutSubaccountInput = {
    create?: XOR<ContactCreateWithoutSubaccountInput, ContactUncheckedCreateWithoutSubaccountInput> | ContactCreateWithoutSubaccountInput[] | ContactUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSubaccountInput | ContactCreateOrConnectWithoutSubaccountInput[]
    createMany?: ContactCreateManySubaccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TriggerUncheckedCreateNestedManyWithoutSubaccountInput = {
    create?: XOR<TriggerCreateWithoutSubaccountInput, TriggerUncheckedCreateWithoutSubaccountInput> | TriggerCreateWithoutSubaccountInput[] | TriggerUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutSubaccountInput | TriggerCreateOrConnectWithoutSubaccountInput[]
    createMany?: TriggerCreateManySubaccountInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type AutomationUncheckedCreateNestedManyWithoutSubaccountInput = {
    create?: XOR<AutomationCreateWithoutSubaccountInput, AutomationUncheckedCreateWithoutSubaccountInput> | AutomationCreateWithoutSubaccountInput[] | AutomationUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutSubaccountInput | AutomationCreateOrConnectWithoutSubaccountInput[]
    createMany?: AutomationCreateManySubaccountInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type PipelineUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput> | PipelineCreateWithoutSubAccountInput[] | PipelineUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutSubAccountInput | PipelineCreateOrConnectWithoutSubAccountInput[]
    createMany?: PipelineCreateManySubAccountInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<TagCreateWithoutSubAccountInput, TagUncheckedCreateWithoutSubAccountInput> | TagCreateWithoutSubAccountInput[] | TagUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSubAccountInput | TagCreateOrConnectWithoutSubAccountInput[]
    createMany?: TagCreateManySubAccountInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput> | NotificationCreateWithoutSubAccountInput[] | NotificationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSubAccountInput | NotificationCreateOrConnectWithoutSubAccountInput[]
    createMany?: NotificationCreateManySubAccountInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AgencyUpdateOneRequiredWithoutSubAccountsNestedInput = {
    create?: XOR<AgencyCreateWithoutSubAccountsInput, AgencyUncheckedCreateWithoutSubAccountsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubAccountsInput
    upsert?: AgencyUpsertWithoutSubAccountsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSubAccountsInput, AgencyUpdateWithoutSubAccountsInput>, AgencyUncheckedUpdateWithoutSubAccountsInput>
  }

  export type SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    upsert?: SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    set?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    disconnect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    delete?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    update?: SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput | SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
  }

  export type PermissionsUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput> | PermissionsCreateWithoutSubAccountInput[] | PermissionsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAccountInput | PermissionsCreateOrConnectWithoutSubAccountInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutSubAccountInput | PermissionsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PermissionsCreateManySubAccountInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutSubAccountInput | PermissionsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutSubAccountInput | PermissionsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type FunnelUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<FunnelCreateWithoutSubAccountInput, FunnelUncheckedCreateWithoutSubAccountInput> | FunnelCreateWithoutSubAccountInput[] | FunnelUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelCreateOrConnectWithoutSubAccountInput | FunnelCreateOrConnectWithoutSubAccountInput[]
    upsert?: FunnelUpsertWithWhereUniqueWithoutSubAccountInput | FunnelUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: FunnelCreateManySubAccountInputEnvelope
    set?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
    disconnect?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
    delete?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
    connect?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
    update?: FunnelUpdateWithWhereUniqueWithoutSubAccountInput | FunnelUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: FunnelUpdateManyWithWhereWithoutSubAccountInput | FunnelUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: FunnelScalarWhereInput | FunnelScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput> | MediaCreateWithoutSubAccountInput[] | MediaUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountInput | MediaCreateOrConnectWithoutSubAccountInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutSubAccountInput | MediaUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: MediaCreateManySubAccountInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutSubAccountInput | MediaUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutSubAccountInput | MediaUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutSubaccountNestedInput = {
    create?: XOR<ContactCreateWithoutSubaccountInput, ContactUncheckedCreateWithoutSubaccountInput> | ContactCreateWithoutSubaccountInput[] | ContactUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSubaccountInput | ContactCreateOrConnectWithoutSubaccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutSubaccountInput | ContactUpsertWithWhereUniqueWithoutSubaccountInput[]
    createMany?: ContactCreateManySubaccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutSubaccountInput | ContactUpdateWithWhereUniqueWithoutSubaccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutSubaccountInput | ContactUpdateManyWithWhereWithoutSubaccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TriggerUpdateManyWithoutSubaccountNestedInput = {
    create?: XOR<TriggerCreateWithoutSubaccountInput, TriggerUncheckedCreateWithoutSubaccountInput> | TriggerCreateWithoutSubaccountInput[] | TriggerUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutSubaccountInput | TriggerCreateOrConnectWithoutSubaccountInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutSubaccountInput | TriggerUpsertWithWhereUniqueWithoutSubaccountInput[]
    createMany?: TriggerCreateManySubaccountInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutSubaccountInput | TriggerUpdateWithWhereUniqueWithoutSubaccountInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutSubaccountInput | TriggerUpdateManyWithWhereWithoutSubaccountInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type AutomationUpdateManyWithoutSubaccountNestedInput = {
    create?: XOR<AutomationCreateWithoutSubaccountInput, AutomationUncheckedCreateWithoutSubaccountInput> | AutomationCreateWithoutSubaccountInput[] | AutomationUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutSubaccountInput | AutomationCreateOrConnectWithoutSubaccountInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutSubaccountInput | AutomationUpsertWithWhereUniqueWithoutSubaccountInput[]
    createMany?: AutomationCreateManySubaccountInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutSubaccountInput | AutomationUpdateWithWhereUniqueWithoutSubaccountInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutSubaccountInput | AutomationUpdateManyWithWhereWithoutSubaccountInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type PipelineUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput> | PipelineCreateWithoutSubAccountInput[] | PipelineUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutSubAccountInput | PipelineCreateOrConnectWithoutSubAccountInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutSubAccountInput | PipelineUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PipelineCreateManySubAccountInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutSubAccountInput | PipelineUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutSubAccountInput | PipelineUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type TagUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<TagCreateWithoutSubAccountInput, TagUncheckedCreateWithoutSubAccountInput> | TagCreateWithoutSubAccountInput[] | TagUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSubAccountInput | TagCreateOrConnectWithoutSubAccountInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutSubAccountInput | TagUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: TagCreateManySubAccountInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutSubAccountInput | TagUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: TagUpdateManyWithWhereWithoutSubAccountInput | TagUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput> | NotificationCreateWithoutSubAccountInput[] | NotificationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSubAccountInput | NotificationCreateOrConnectWithoutSubAccountInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSubAccountInput | NotificationUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: NotificationCreateManySubAccountInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSubAccountInput | NotificationUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSubAccountInput | NotificationUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    upsert?: SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    set?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    disconnect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    delete?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    update?: SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput | SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
  }

  export type PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput> | PermissionsCreateWithoutSubAccountInput[] | PermissionsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAccountInput | PermissionsCreateOrConnectWithoutSubAccountInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutSubAccountInput | PermissionsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PermissionsCreateManySubAccountInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutSubAccountInput | PermissionsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutSubAccountInput | PermissionsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type FunnelUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<FunnelCreateWithoutSubAccountInput, FunnelUncheckedCreateWithoutSubAccountInput> | FunnelCreateWithoutSubAccountInput[] | FunnelUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelCreateOrConnectWithoutSubAccountInput | FunnelCreateOrConnectWithoutSubAccountInput[]
    upsert?: FunnelUpsertWithWhereUniqueWithoutSubAccountInput | FunnelUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: FunnelCreateManySubAccountInputEnvelope
    set?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
    disconnect?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
    delete?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
    connect?: FunnelWhereUniqueInput | FunnelWhereUniqueInput[]
    update?: FunnelUpdateWithWhereUniqueWithoutSubAccountInput | FunnelUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: FunnelUpdateManyWithWhereWithoutSubAccountInput | FunnelUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: FunnelScalarWhereInput | FunnelScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput> | MediaCreateWithoutSubAccountInput[] | MediaUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountInput | MediaCreateOrConnectWithoutSubAccountInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutSubAccountInput | MediaUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: MediaCreateManySubAccountInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutSubAccountInput | MediaUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutSubAccountInput | MediaUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutSubaccountNestedInput = {
    create?: XOR<ContactCreateWithoutSubaccountInput, ContactUncheckedCreateWithoutSubaccountInput> | ContactCreateWithoutSubaccountInput[] | ContactUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSubaccountInput | ContactCreateOrConnectWithoutSubaccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutSubaccountInput | ContactUpsertWithWhereUniqueWithoutSubaccountInput[]
    createMany?: ContactCreateManySubaccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutSubaccountInput | ContactUpdateWithWhereUniqueWithoutSubaccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutSubaccountInput | ContactUpdateManyWithWhereWithoutSubaccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TriggerUncheckedUpdateManyWithoutSubaccountNestedInput = {
    create?: XOR<TriggerCreateWithoutSubaccountInput, TriggerUncheckedCreateWithoutSubaccountInput> | TriggerCreateWithoutSubaccountInput[] | TriggerUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutSubaccountInput | TriggerCreateOrConnectWithoutSubaccountInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutSubaccountInput | TriggerUpsertWithWhereUniqueWithoutSubaccountInput[]
    createMany?: TriggerCreateManySubaccountInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutSubaccountInput | TriggerUpdateWithWhereUniqueWithoutSubaccountInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutSubaccountInput | TriggerUpdateManyWithWhereWithoutSubaccountInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type AutomationUncheckedUpdateManyWithoutSubaccountNestedInput = {
    create?: XOR<AutomationCreateWithoutSubaccountInput, AutomationUncheckedCreateWithoutSubaccountInput> | AutomationCreateWithoutSubaccountInput[] | AutomationUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutSubaccountInput | AutomationCreateOrConnectWithoutSubaccountInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutSubaccountInput | AutomationUpsertWithWhereUniqueWithoutSubaccountInput[]
    createMany?: AutomationCreateManySubaccountInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutSubaccountInput | AutomationUpdateWithWhereUniqueWithoutSubaccountInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutSubaccountInput | AutomationUpdateManyWithWhereWithoutSubaccountInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type PipelineUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput> | PipelineCreateWithoutSubAccountInput[] | PipelineUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutSubAccountInput | PipelineCreateOrConnectWithoutSubAccountInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutSubAccountInput | PipelineUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PipelineCreateManySubAccountInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutSubAccountInput | PipelineUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutSubAccountInput | PipelineUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<TagCreateWithoutSubAccountInput, TagUncheckedCreateWithoutSubAccountInput> | TagCreateWithoutSubAccountInput[] | TagUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSubAccountInput | TagCreateOrConnectWithoutSubAccountInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutSubAccountInput | TagUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: TagCreateManySubAccountInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutSubAccountInput | TagUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: TagUpdateManyWithWhereWithoutSubAccountInput | TagUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput> | NotificationCreateWithoutSubAccountInput[] | NotificationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSubAccountInput | NotificationCreateOrConnectWithoutSubAccountInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSubAccountInput | NotificationUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: NotificationCreateManySubAccountInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSubAccountInput | NotificationUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSubAccountInput | NotificationUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type SubAccountCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<SubAccountCreateWithoutPermissionsInput, SubAccountUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPermissionsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermissionsInput, UserUpdateWithoutPermissionsInput>, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type SubAccountUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<SubAccountCreateWithoutPermissionsInput, SubAccountUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPermissionsInput
    upsert?: SubAccountUpsertWithoutPermissionsInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutPermissionsInput, SubAccountUpdateWithoutPermissionsInput>, SubAccountUncheckedUpdateWithoutPermissionsInput>
  }

  export type SubAccountCreateNestedOneWithoutTagsInput = {
    create?: XOR<SubAccountCreateWithoutTagsInput, SubAccountUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutTagsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type SubAccountUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<SubAccountCreateWithoutTagsInput, SubAccountUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutTagsInput
    upsert?: SubAccountUpsertWithoutTagsInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutTagsInput, SubAccountUpdateWithoutTagsInput>, SubAccountUncheckedUpdateWithoutTagsInput>
  }

  export type TicketUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTagsInput | TicketUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTagsInput | TicketUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTagsInput | TicketUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTagsInput | TicketUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTagsInput | TicketUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTagsInput | TicketUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type LaneCreateNestedManyWithoutPipelineInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
  }

  export type SubAccountCreateNestedOneWithoutPipelinesInput = {
    create?: XOR<SubAccountCreateWithoutPipelinesInput, SubAccountUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPipelinesInput
    connect?: SubAccountWhereUniqueInput
  }

  export type LaneUncheckedCreateNestedManyWithoutPipelineInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
  }

  export type LaneUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    upsert?: LaneUpsertWithWhereUniqueWithoutPipelineInput | LaneUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    set?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    disconnect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    delete?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    update?: LaneUpdateWithWhereUniqueWithoutPipelineInput | LaneUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: LaneUpdateManyWithWhereWithoutPipelineInput | LaneUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: LaneScalarWhereInput | LaneScalarWhereInput[]
  }

  export type SubAccountUpdateOneRequiredWithoutPipelinesNestedInput = {
    create?: XOR<SubAccountCreateWithoutPipelinesInput, SubAccountUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPipelinesInput
    upsert?: SubAccountUpsertWithoutPipelinesInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutPipelinesInput, SubAccountUpdateWithoutPipelinesInput>, SubAccountUncheckedUpdateWithoutPipelinesInput>
  }

  export type LaneUncheckedUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    upsert?: LaneUpsertWithWhereUniqueWithoutPipelineInput | LaneUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    set?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    disconnect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    delete?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    update?: LaneUpdateWithWhereUniqueWithoutPipelineInput | LaneUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: LaneUpdateManyWithWhereWithoutPipelineInput | LaneUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: LaneScalarWhereInput | LaneScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AgencyCreateWithoutNotificationsInput, AgencyUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutNotificationsInput
    connect?: AgencyWhereUniqueInput
  }

  export type SubAccountCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<SubAccountCreateWithoutNotificationsInput, SubAccountUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutNotificationsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type AgencyUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<AgencyCreateWithoutNotificationsInput, AgencyUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutNotificationsInput
    upsert?: AgencyUpsertWithoutNotificationsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutNotificationsInput, AgencyUpdateWithoutNotificationsInput>, AgencyUncheckedUpdateWithoutNotificationsInput>
  }

  export type SubAccountUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<SubAccountCreateWithoutNotificationsInput, SubAccountUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutNotificationsInput
    upsert?: SubAccountUpsertWithoutNotificationsInput
    disconnect?: SubAccountWhereInput | boolean
    delete?: SubAccountWhereInput | boolean
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutNotificationsInput, SubAccountUpdateWithoutNotificationsInput>, SubAccountUncheckedUpdateWithoutNotificationsInput>
  }

  export type PipelineCreateNestedOneWithoutLanesInput = {
    create?: XOR<PipelineCreateWithoutLanesInput, PipelineUncheckedCreateWithoutLanesInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutLanesInput
    connect?: PipelineWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutLaneInput = {
    create?: XOR<TicketCreateWithoutLaneInput, TicketUncheckedCreateWithoutLaneInput> | TicketCreateWithoutLaneInput[] | TicketUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutLaneInput | TicketCreateOrConnectWithoutLaneInput[]
    createMany?: TicketCreateManyLaneInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutLaneInput = {
    create?: XOR<TicketCreateWithoutLaneInput, TicketUncheckedCreateWithoutLaneInput> | TicketCreateWithoutLaneInput[] | TicketUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutLaneInput | TicketCreateOrConnectWithoutLaneInput[]
    createMany?: TicketCreateManyLaneInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type PipelineUpdateOneRequiredWithoutLanesNestedInput = {
    create?: XOR<PipelineCreateWithoutLanesInput, PipelineUncheckedCreateWithoutLanesInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutLanesInput
    upsert?: PipelineUpsertWithoutLanesInput
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutLanesInput, PipelineUpdateWithoutLanesInput>, PipelineUncheckedUpdateWithoutLanesInput>
  }

  export type TicketUpdateManyWithoutLaneNestedInput = {
    create?: XOR<TicketCreateWithoutLaneInput, TicketUncheckedCreateWithoutLaneInput> | TicketCreateWithoutLaneInput[] | TicketUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutLaneInput | TicketCreateOrConnectWithoutLaneInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutLaneInput | TicketUpsertWithWhereUniqueWithoutLaneInput[]
    createMany?: TicketCreateManyLaneInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutLaneInput | TicketUpdateWithWhereUniqueWithoutLaneInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutLaneInput | TicketUpdateManyWithWhereWithoutLaneInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutLaneNestedInput = {
    create?: XOR<TicketCreateWithoutLaneInput, TicketUncheckedCreateWithoutLaneInput> | TicketCreateWithoutLaneInput[] | TicketUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutLaneInput | TicketCreateOrConnectWithoutLaneInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutLaneInput | TicketUpsertWithWhereUniqueWithoutLaneInput[]
    createMany?: TicketCreateManyLaneInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutLaneInput | TicketUpdateWithWhereUniqueWithoutLaneInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutLaneInput | TicketUpdateManyWithWhereWithoutLaneInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type LaneCreateNestedOneWithoutTicketsInput = {
    create?: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: LaneCreateOrConnectWithoutTicketsInput
    connect?: LaneWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketsInput
    connect?: ContactWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput> | TagCreateWithoutTicketsInput[] | TagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTicketsInput | TagCreateOrConnectWithoutTicketsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TagUncheckedCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput> | TagCreateWithoutTicketsInput[] | TagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTicketsInput | TagCreateOrConnectWithoutTicketsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LaneUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: LaneCreateOrConnectWithoutTicketsInput
    upsert?: LaneUpsertWithoutTicketsInput
    connect?: LaneWhereUniqueInput
    update?: XOR<XOR<LaneUpdateToOneWithWhereWithoutTicketsInput, LaneUpdateWithoutTicketsInput>, LaneUncheckedUpdateWithoutTicketsInput>
  }

  export type ContactUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketsInput
    upsert?: ContactUpsertWithoutTicketsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTicketsInput, ContactUpdateWithoutTicketsInput>, ContactUncheckedUpdateWithoutTicketsInput>
  }

  export type TagUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput> | TagCreateWithoutTicketsInput[] | TagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTicketsInput | TagCreateOrConnectWithoutTicketsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTicketsInput | TagUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTicketsInput | TagUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTicketsInput | TagUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type UserUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type TagUncheckedUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput> | TagCreateWithoutTicketsInput[] | TagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTicketsInput | TagCreateOrConnectWithoutTicketsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTicketsInput | TagUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTicketsInput | TagUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTicketsInput | TagUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SubAccountCreateNestedOneWithoutTriggersInput = {
    create?: XOR<SubAccountCreateWithoutTriggersInput, SubAccountUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutTriggersInput
    connect?: SubAccountWhereUniqueInput
  }

  export type AutomationCreateNestedManyWithoutTriggerInput = {
    create?: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput> | AutomationCreateWithoutTriggerInput[] | AutomationUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTriggerInput | AutomationCreateOrConnectWithoutTriggerInput[]
    createMany?: AutomationCreateManyTriggerInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type AutomationUncheckedCreateNestedManyWithoutTriggerInput = {
    create?: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput> | AutomationCreateWithoutTriggerInput[] | AutomationUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTriggerInput | AutomationCreateOrConnectWithoutTriggerInput[]
    createMany?: AutomationCreateManyTriggerInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type EnumTriggerTypesFieldUpdateOperationsInput = {
    set?: $Enums.TriggerTypes
  }

  export type SubAccountUpdateOneRequiredWithoutTriggersNestedInput = {
    create?: XOR<SubAccountCreateWithoutTriggersInput, SubAccountUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutTriggersInput
    upsert?: SubAccountUpsertWithoutTriggersInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutTriggersInput, SubAccountUpdateWithoutTriggersInput>, SubAccountUncheckedUpdateWithoutTriggersInput>
  }

  export type AutomationUpdateManyWithoutTriggerNestedInput = {
    create?: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput> | AutomationCreateWithoutTriggerInput[] | AutomationUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTriggerInput | AutomationCreateOrConnectWithoutTriggerInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutTriggerInput | AutomationUpsertWithWhereUniqueWithoutTriggerInput[]
    createMany?: AutomationCreateManyTriggerInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutTriggerInput | AutomationUpdateWithWhereUniqueWithoutTriggerInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutTriggerInput | AutomationUpdateManyWithWhereWithoutTriggerInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type AutomationUncheckedUpdateManyWithoutTriggerNestedInput = {
    create?: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput> | AutomationCreateWithoutTriggerInput[] | AutomationUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTriggerInput | AutomationCreateOrConnectWithoutTriggerInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutTriggerInput | AutomationUpsertWithWhereUniqueWithoutTriggerInput[]
    createMany?: AutomationCreateManyTriggerInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutTriggerInput | AutomationUpdateWithWhereUniqueWithoutTriggerInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutTriggerInput | AutomationUpdateManyWithWhereWithoutTriggerInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type TriggerCreateNestedOneWithoutAutomationsInput = {
    create?: XOR<TriggerCreateWithoutAutomationsInput, TriggerUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: TriggerCreateOrConnectWithoutAutomationsInput
    connect?: TriggerWhereUniqueInput
  }

  export type SubAccountCreateNestedOneWithoutAutomationsInput = {
    create?: XOR<SubAccountCreateWithoutAutomationsInput, SubAccountUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutAutomationsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type ActionCreateNestedManyWithoutAutomationInput = {
    create?: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput> | ActionCreateWithoutAutomationInput[] | ActionUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutAutomationInput | ActionCreateOrConnectWithoutAutomationInput[]
    createMany?: ActionCreateManyAutomationInputEnvelope
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type AutomationInstanceCreateNestedManyWithoutAutomationInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput> | AutomationInstanceCreateWithoutAutomationInput[] | AutomationInstanceUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationInput | AutomationInstanceCreateOrConnectWithoutAutomationInput[]
    createMany?: AutomationInstanceCreateManyAutomationInputEnvelope
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
  }

  export type ActionUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput> | ActionCreateWithoutAutomationInput[] | ActionUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutAutomationInput | ActionCreateOrConnectWithoutAutomationInput[]
    createMany?: ActionCreateManyAutomationInputEnvelope
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput> | AutomationInstanceCreateWithoutAutomationInput[] | AutomationInstanceUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationInput | AutomationInstanceCreateOrConnectWithoutAutomationInput[]
    createMany?: AutomationInstanceCreateManyAutomationInputEnvelope
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
  }

  export type TriggerUpdateOneWithoutAutomationsNestedInput = {
    create?: XOR<TriggerCreateWithoutAutomationsInput, TriggerUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: TriggerCreateOrConnectWithoutAutomationsInput
    upsert?: TriggerUpsertWithoutAutomationsInput
    disconnect?: TriggerWhereInput | boolean
    delete?: TriggerWhereInput | boolean
    connect?: TriggerWhereUniqueInput
    update?: XOR<XOR<TriggerUpdateToOneWithWhereWithoutAutomationsInput, TriggerUpdateWithoutAutomationsInput>, TriggerUncheckedUpdateWithoutAutomationsInput>
  }

  export type SubAccountUpdateOneRequiredWithoutAutomationsNestedInput = {
    create?: XOR<SubAccountCreateWithoutAutomationsInput, SubAccountUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutAutomationsInput
    upsert?: SubAccountUpsertWithoutAutomationsInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutAutomationsInput, SubAccountUpdateWithoutAutomationsInput>, SubAccountUncheckedUpdateWithoutAutomationsInput>
  }

  export type ActionUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput> | ActionCreateWithoutAutomationInput[] | ActionUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutAutomationInput | ActionCreateOrConnectWithoutAutomationInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutAutomationInput | ActionUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: ActionCreateManyAutomationInputEnvelope
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutAutomationInput | ActionUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutAutomationInput | ActionUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type AutomationInstanceUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput> | AutomationInstanceCreateWithoutAutomationInput[] | AutomationInstanceUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationInput | AutomationInstanceCreateOrConnectWithoutAutomationInput[]
    upsert?: AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput | AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: AutomationInstanceCreateManyAutomationInputEnvelope
    set?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    disconnect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    delete?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    update?: AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput | AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: AutomationInstanceUpdateManyWithWhereWithoutAutomationInput | AutomationInstanceUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
  }

  export type ActionUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput> | ActionCreateWithoutAutomationInput[] | ActionUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutAutomationInput | ActionCreateOrConnectWithoutAutomationInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutAutomationInput | ActionUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: ActionCreateManyAutomationInputEnvelope
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutAutomationInput | ActionUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutAutomationInput | ActionUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput> | AutomationInstanceCreateWithoutAutomationInput[] | AutomationInstanceUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationInput | AutomationInstanceCreateOrConnectWithoutAutomationInput[]
    upsert?: AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput | AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: AutomationInstanceCreateManyAutomationInputEnvelope
    set?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    disconnect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    delete?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    update?: AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput | AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: AutomationInstanceUpdateManyWithWhereWithoutAutomationInput | AutomationInstanceUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
  }

  export type AutomationCreateNestedOneWithoutAutomationInstancesInput = {
    create?: XOR<AutomationCreateWithoutAutomationInstancesInput, AutomationUncheckedCreateWithoutAutomationInstancesInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutAutomationInstancesInput
    connect?: AutomationWhereUniqueInput
  }

  export type AutomationUpdateOneRequiredWithoutAutomationInstancesNestedInput = {
    create?: XOR<AutomationCreateWithoutAutomationInstancesInput, AutomationUncheckedCreateWithoutAutomationInstancesInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutAutomationInstancesInput
    upsert?: AutomationUpsertWithoutAutomationInstancesInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutAutomationInstancesInput, AutomationUpdateWithoutAutomationInstancesInput>, AutomationUncheckedUpdateWithoutAutomationInstancesInput>
  }

  export type AutomationCreateNestedOneWithoutActionsInput = {
    create?: XOR<AutomationCreateWithoutActionsInput, AutomationUncheckedCreateWithoutActionsInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutActionsInput
    connect?: AutomationWhereUniqueInput
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type AutomationUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<AutomationCreateWithoutActionsInput, AutomationUncheckedCreateWithoutActionsInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutActionsInput
    upsert?: AutomationUpsertWithoutActionsInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutActionsInput, AutomationUpdateWithoutActionsInput>, AutomationUncheckedUpdateWithoutActionsInput>
  }

  export type SubAccountCreateNestedOneWithoutContactsInput = {
    create?: XOR<SubAccountCreateWithoutContactsInput, SubAccountUncheckedCreateWithoutContactsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutContactsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput> | TicketCreateWithoutCustomerInput[] | TicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCustomerInput | TicketCreateOrConnectWithoutCustomerInput[]
    createMany?: TicketCreateManyCustomerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput> | TicketCreateWithoutCustomerInput[] | TicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCustomerInput | TicketCreateOrConnectWithoutCustomerInput[]
    createMany?: TicketCreateManyCustomerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type SubAccountUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<SubAccountCreateWithoutContactsInput, SubAccountUncheckedCreateWithoutContactsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutContactsInput
    upsert?: SubAccountUpsertWithoutContactsInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutContactsInput, SubAccountUpdateWithoutContactsInput>, SubAccountUncheckedUpdateWithoutContactsInput>
  }

  export type TicketUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput> | TicketCreateWithoutCustomerInput[] | TicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCustomerInput | TicketCreateOrConnectWithoutCustomerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCustomerInput | TicketUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TicketCreateManyCustomerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCustomerInput | TicketUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCustomerInput | TicketUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput> | TicketCreateWithoutCustomerInput[] | TicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCustomerInput | TicketCreateOrConnectWithoutCustomerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCustomerInput | TicketUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TicketCreateManyCustomerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCustomerInput | TicketUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCustomerInput | TicketUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type SubAccountCreateNestedOneWithoutMediaInput = {
    create?: XOR<SubAccountCreateWithoutMediaInput, SubAccountUncheckedCreateWithoutMediaInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutMediaInput
    connect?: SubAccountWhereUniqueInput
  }

  export type SubAccountUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<SubAccountCreateWithoutMediaInput, SubAccountUncheckedCreateWithoutMediaInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutMediaInput
    upsert?: SubAccountUpsertWithoutMediaInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutMediaInput, SubAccountUpdateWithoutMediaInput>, SubAccountUncheckedUpdateWithoutMediaInput>
  }

  export type SubAccountCreateNestedOneWithoutFunnelsInput = {
    create?: XOR<SubAccountCreateWithoutFunnelsInput, SubAccountUncheckedCreateWithoutFunnelsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutFunnelsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type FunnelPageCreateNestedManyWithoutFunnelInput = {
    create?: XOR<FunnelPageCreateWithoutFunnelInput, FunnelPageUncheckedCreateWithoutFunnelInput> | FunnelPageCreateWithoutFunnelInput[] | FunnelPageUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunnelPageCreateOrConnectWithoutFunnelInput | FunnelPageCreateOrConnectWithoutFunnelInput[]
    createMany?: FunnelPageCreateManyFunnelInputEnvelope
    connect?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
  }

  export type ClassNameCreateNestedManyWithoutFunnelInput = {
    create?: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput> | ClassNameCreateWithoutFunnelInput[] | ClassNameUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelInput | ClassNameCreateOrConnectWithoutFunnelInput[]
    createMany?: ClassNameCreateManyFunnelInputEnvelope
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type FunnelPageUncheckedCreateNestedManyWithoutFunnelInput = {
    create?: XOR<FunnelPageCreateWithoutFunnelInput, FunnelPageUncheckedCreateWithoutFunnelInput> | FunnelPageCreateWithoutFunnelInput[] | FunnelPageUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunnelPageCreateOrConnectWithoutFunnelInput | FunnelPageCreateOrConnectWithoutFunnelInput[]
    createMany?: FunnelPageCreateManyFunnelInputEnvelope
    connect?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
  }

  export type ClassNameUncheckedCreateNestedManyWithoutFunnelInput = {
    create?: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput> | ClassNameCreateWithoutFunnelInput[] | ClassNameUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelInput | ClassNameCreateOrConnectWithoutFunnelInput[]
    createMany?: ClassNameCreateManyFunnelInputEnvelope
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type SubAccountUpdateOneRequiredWithoutFunnelsNestedInput = {
    create?: XOR<SubAccountCreateWithoutFunnelsInput, SubAccountUncheckedCreateWithoutFunnelsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutFunnelsInput
    upsert?: SubAccountUpsertWithoutFunnelsInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutFunnelsInput, SubAccountUpdateWithoutFunnelsInput>, SubAccountUncheckedUpdateWithoutFunnelsInput>
  }

  export type FunnelPageUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<FunnelPageCreateWithoutFunnelInput, FunnelPageUncheckedCreateWithoutFunnelInput> | FunnelPageCreateWithoutFunnelInput[] | FunnelPageUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunnelPageCreateOrConnectWithoutFunnelInput | FunnelPageCreateOrConnectWithoutFunnelInput[]
    upsert?: FunnelPageUpsertWithWhereUniqueWithoutFunnelInput | FunnelPageUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: FunnelPageCreateManyFunnelInputEnvelope
    set?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
    disconnect?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
    delete?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
    connect?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
    update?: FunnelPageUpdateWithWhereUniqueWithoutFunnelInput | FunnelPageUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: FunnelPageUpdateManyWithWhereWithoutFunnelInput | FunnelPageUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: FunnelPageScalarWhereInput | FunnelPageScalarWhereInput[]
  }

  export type ClassNameUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput> | ClassNameCreateWithoutFunnelInput[] | ClassNameUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelInput | ClassNameCreateOrConnectWithoutFunnelInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutFunnelInput | ClassNameUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: ClassNameCreateManyFunnelInputEnvelope
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutFunnelInput | ClassNameUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutFunnelInput | ClassNameUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type FunnelPageUncheckedUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<FunnelPageCreateWithoutFunnelInput, FunnelPageUncheckedCreateWithoutFunnelInput> | FunnelPageCreateWithoutFunnelInput[] | FunnelPageUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunnelPageCreateOrConnectWithoutFunnelInput | FunnelPageCreateOrConnectWithoutFunnelInput[]
    upsert?: FunnelPageUpsertWithWhereUniqueWithoutFunnelInput | FunnelPageUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: FunnelPageCreateManyFunnelInputEnvelope
    set?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
    disconnect?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
    delete?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
    connect?: FunnelPageWhereUniqueInput | FunnelPageWhereUniqueInput[]
    update?: FunnelPageUpdateWithWhereUniqueWithoutFunnelInput | FunnelPageUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: FunnelPageUpdateManyWithWhereWithoutFunnelInput | FunnelPageUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: FunnelPageScalarWhereInput | FunnelPageScalarWhereInput[]
  }

  export type ClassNameUncheckedUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput> | ClassNameCreateWithoutFunnelInput[] | ClassNameUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelInput | ClassNameCreateOrConnectWithoutFunnelInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutFunnelInput | ClassNameUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: ClassNameCreateManyFunnelInputEnvelope
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutFunnelInput | ClassNameUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutFunnelInput | ClassNameUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type FunnelCreateNestedOneWithoutClassNameInput = {
    create?: XOR<FunnelCreateWithoutClassNameInput, FunnelUncheckedCreateWithoutClassNameInput>
    connectOrCreate?: FunnelCreateOrConnectWithoutClassNameInput
    connect?: FunnelWhereUniqueInput
  }

  export type FunnelUpdateOneRequiredWithoutClassNameNestedInput = {
    create?: XOR<FunnelCreateWithoutClassNameInput, FunnelUncheckedCreateWithoutClassNameInput>
    connectOrCreate?: FunnelCreateOrConnectWithoutClassNameInput
    upsert?: FunnelUpsertWithoutClassNameInput
    connect?: FunnelWhereUniqueInput
    update?: XOR<XOR<FunnelUpdateToOneWithWhereWithoutClassNameInput, FunnelUpdateWithoutClassNameInput>, FunnelUncheckedUpdateWithoutClassNameInput>
  }

  export type FunnelCreateNestedOneWithoutFunnelPagesInput = {
    create?: XOR<FunnelCreateWithoutFunnelPagesInput, FunnelUncheckedCreateWithoutFunnelPagesInput>
    connectOrCreate?: FunnelCreateOrConnectWithoutFunnelPagesInput
    connect?: FunnelWhereUniqueInput
  }

  export type FunnelUpdateOneRequiredWithoutFunnelPagesNestedInput = {
    create?: XOR<FunnelCreateWithoutFunnelPagesInput, FunnelUncheckedCreateWithoutFunnelPagesInput>
    connectOrCreate?: FunnelCreateOrConnectWithoutFunnelPagesInput
    upsert?: FunnelUpsertWithoutFunnelPagesInput
    connect?: FunnelWhereUniqueInput
    update?: XOR<XOR<FunnelUpdateToOneWithWhereWithoutFunnelPagesInput, FunnelUpdateWithoutFunnelPagesInput>, FunnelUncheckedUpdateWithoutFunnelPagesInput>
  }

  export type AgencyCreateNestedOneWithoutSidebarOptionsInput = {
    create?: XOR<AgencyCreateWithoutSidebarOptionsInput, AgencyUncheckedCreateWithoutSidebarOptionsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSidebarOptionsInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnumIconFieldUpdateOperationsInput = {
    set?: $Enums.Icon
  }

  export type AgencyUpdateOneWithoutSidebarOptionsNestedInput = {
    create?: XOR<AgencyCreateWithoutSidebarOptionsInput, AgencyUncheckedCreateWithoutSidebarOptionsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSidebarOptionsInput
    upsert?: AgencyUpsertWithoutSidebarOptionsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSidebarOptionsInput, AgencyUpdateWithoutSidebarOptionsInput>, AgencyUncheckedUpdateWithoutSidebarOptionsInput>
  }

  export type SubAccountCreateNestedOneWithoutSidebarOptionsInput = {
    create?: XOR<SubAccountCreateWithoutSidebarOptionsInput, SubAccountUncheckedCreateWithoutSidebarOptionsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutSidebarOptionsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type SubAccountUpdateOneWithoutSidebarOptionsNestedInput = {
    create?: XOR<SubAccountCreateWithoutSidebarOptionsInput, SubAccountUncheckedCreateWithoutSidebarOptionsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutSidebarOptionsInput
    upsert?: SubAccountUpsertWithoutSidebarOptionsInput
    disconnect?: SubAccountWhereInput | boolean
    delete?: SubAccountWhereInput | boolean
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutSidebarOptionsInput, SubAccountUpdateWithoutSidebarOptionsInput>, SubAccountUncheckedUpdateWithoutSidebarOptionsInput>
  }

  export type AgencyCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<AgencyCreateWithoutInvitationsInput, AgencyUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutInvitationsInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type AgencyUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<AgencyCreateWithoutInvitationsInput, AgencyUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutInvitationsInput
    upsert?: AgencyUpsertWithoutInvitationsInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutInvitationsInput, AgencyUpdateWithoutInvitationsInput>, AgencyUncheckedUpdateWithoutInvitationsInput>
  }

  export type AgencyCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<AgencyCreateWithoutSubscriptionsInput, AgencyUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubscriptionsInput
    connect?: AgencyWhereUniqueInput
  }

  export type NullableEnumPlanFieldUpdateOperationsInput = {
    set?: $Enums.Plan | null
  }

  export type AgencyUpdateOneWithoutSubscriptionsNestedInput = {
    create?: XOR<AgencyCreateWithoutSubscriptionsInput, AgencyUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubscriptionsInput
    upsert?: AgencyUpsertWithoutSubscriptionsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSubscriptionsInput, AgencyUpdateWithoutSubscriptionsInput>, AgencyUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type AgencyCreateNestedOneWithoutAddOnsInput = {
    create?: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddOnsInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyUpdateOneWithoutAddOnsNestedInput = {
    create?: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddOnsInput
    upsert?: AgencyUpsertWithoutAddOnsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAddOnsInput, AgencyUpdateWithoutAddOnsInput>, AgencyUncheckedUpdateWithoutAddOnsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumTriggerTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypesFilter<$PrismaModel> | $Enums.TriggerTypes
  }

  export type NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel> | $Enums.TriggerTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypesFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypesFilter<$PrismaModel>
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumIconFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    notIn?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    not?: NestedEnumIconFilter<$PrismaModel> | $Enums.Icon
  }

  export type NestedEnumIconWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    notIn?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    not?: NestedEnumIconWithAggregatesFilter<$PrismaModel> | $Enums.Icon
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconFilter<$PrismaModel>
    _max?: NestedEnumIconFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableFilter<$PrismaModel> | $Enums.Plan | null
  }

  export type NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanNullableFilter<$PrismaModel>
  }

  export type AgencyCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    subAccounts?: SubAccountCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    invitations?: InvitationCreateNestedManyWithoutAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutUsersInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
  }

  export type PermissionsCreateWithoutUserInput = {
    id?: string
    access: boolean
    subAccount: SubAccountCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateWithoutUserInput = {
    id?: string
    subAccountId: string
    access: boolean
  }

  export type PermissionsCreateOrConnectWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput>
  }

  export type PermissionsCreateManyUserInputEnvelope = {
    data: PermissionsCreateManyUserInput | PermissionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAssignedInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    lane: LaneCreateNestedOneWithoutTicketsInput
    customer?: ContactCreateNestedOneWithoutTicketsInput
    tags?: TagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutAssignedInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutAssignedInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssignedInput, TicketUncheckedCreateWithoutAssignedInput>
  }

  export type TicketCreateManyAssignedInputEnvelope = {
    data: TicketCreateManyAssignedInput | TicketCreateManyAssignedInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    agency: AgencyCreateNestedOneWithoutNotificationsInput
    subAccount?: SubAccountCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    agencyId: string
    subAccountId?: string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutUsersInput = {
    update: XOR<AgencyUpdateWithoutUsersInput, AgencyUncheckedUpdateWithoutUsersInput>
    create: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutUsersInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutUsersInput, AgencyUncheckedUpdateWithoutUsersInput>
  }

  export type AgencyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    subAccounts?: SubAccountUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    subAccounts?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type PermissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    update: XOR<PermissionsUpdateWithoutUserInput, PermissionsUncheckedUpdateWithoutUserInput>
    create: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput>
  }

  export type PermissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    data: XOR<PermissionsUpdateWithoutUserInput, PermissionsUncheckedUpdateWithoutUserInput>
  }

  export type PermissionsUpdateManyWithWhereWithoutUserInput = {
    where: PermissionsScalarWhereInput
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyWithoutUserInput>
  }

  export type PermissionsScalarWhereInput = {
    AND?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
    OR?: PermissionsScalarWhereInput[]
    NOT?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
    id?: StringFilter<"Permissions"> | string
    email?: StringFilter<"Permissions"> | string
    subAccountId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
  }

  export type TicketUpsertWithWhereUniqueWithoutAssignedInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssignedInput, TicketUncheckedUpdateWithoutAssignedInput>
    create: XOR<TicketCreateWithoutAssignedInput, TicketUncheckedCreateWithoutAssignedInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssignedInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssignedInput, TicketUncheckedUpdateWithoutAssignedInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssignedInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssignedInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    name?: StringFilter<"Ticket"> | string
    laneId?: StringFilter<"Ticket"> | string
    order?: IntFilter<"Ticket"> | number
    value?: DecimalNullableFilter<"Ticket"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Ticket"> | string | null
    customerId?: StringNullableFilter<"Ticket"> | string | null
    assignedUserId?: StringNullableFilter<"Ticket"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    notification?: StringFilter<"Notification"> | string
    agencyId?: StringFilter<"Notification"> | string
    subAccountId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
  }

  export type UserCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    permissions?: PermissionsCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutAssignedInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    permissions?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssignedInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgencyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput>
  }

  export type UserCreateManyAgencyInputEnvelope = {
    data: UserCreateManyAgencyInput | UserCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutAgencyInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput>
  }

  export type SubAccountCreateManyAgencyInputEnvelope = {
    data: SubAccountCreateManyAgencyInput | SubAccountCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencySidebarOptionCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
  }

  export type AgencySidebarOptionUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
  }

  export type AgencySidebarOptionCreateOrConnectWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    create: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput>
  }

  export type AgencySidebarOptionCreateManyAgencyInputEnvelope = {
    data: AgencySidebarOptionCreateManyAgencyInput | AgencySidebarOptionCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationUncheckedCreateWithoutAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationCreateOrConnectWithoutAgencyInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput>
  }

  export type InvitationCreateManyAgencyInputEnvelope = {
    data: InvitationCreateManyAgencyInput | InvitationCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    user: UserCreateNestedOneWithoutNotificationInput
    subAccount?: SubAccountCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    subAccountId?: string | null
    userId: string
  }

  export type NotificationCreateOrConnectWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput>
  }

  export type NotificationCreateManyAgencyInputEnvelope = {
    data: NotificationCreateManyAgencyInput | NotificationCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscritiptionId: string
  }

  export type SubscriptionUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscritiptionId: string
  }

  export type SubscriptionCreateOrConnectWithoutAgencyInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type AddOnsUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type AddOnsCreateOrConnectWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    create: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsCreateManyAgencyInputEnvelope = {
    data: AddOnsCreateManyAgencyInput | AddOnsCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutAgencyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAgencyInput, UserUncheckedUpdateWithoutAgencyInput>
    create: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAgencyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAgencyInput, UserUncheckedUpdateWithoutAgencyInput>
  }

  export type UserUpdateManyWithWhereWithoutAgencyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAgencyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
    avatarUrl?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    agencyId?: StringNullableFilter<"User"> | string | null
  }

  export type SubAccountUpsertWithWhereUniqueWithoutAgencyInput = {
    where: SubAccountWhereUniqueInput
    update: XOR<SubAccountUpdateWithoutAgencyInput, SubAccountUncheckedUpdateWithoutAgencyInput>
    create: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput>
  }

  export type SubAccountUpdateWithWhereUniqueWithoutAgencyInput = {
    where: SubAccountWhereUniqueInput
    data: XOR<SubAccountUpdateWithoutAgencyInput, SubAccountUncheckedUpdateWithoutAgencyInput>
  }

  export type SubAccountUpdateManyWithWhereWithoutAgencyInput = {
    where: SubAccountScalarWhereInput
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyWithoutAgencyInput>
  }

  export type SubAccountScalarWhereInput = {
    AND?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
    OR?: SubAccountScalarWhereInput[]
    NOT?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
    id?: StringFilter<"SubAccount"> | string
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    connectAccountId?: StringNullableFilter<"SubAccount"> | string | null
    name?: StringFilter<"SubAccount"> | string
    subAccountLogo?: StringFilter<"SubAccount"> | string
    companyEmail?: StringFilter<"SubAccount"> | string
    companyPhone?: StringFilter<"SubAccount"> | string
    goal?: IntFilter<"SubAccount"> | number
    address?: StringFilter<"SubAccount"> | string
    city?: StringFilter<"SubAccount"> | string
    zipCode?: StringFilter<"SubAccount"> | string
    state?: StringFilter<"SubAccount"> | string
    country?: StringFilter<"SubAccount"> | string
    agencyId?: StringFilter<"SubAccount"> | string
  }

  export type AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    update: XOR<AgencySidebarOptionUpdateWithoutAgencyInput, AgencySidebarOptionUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput>
  }

  export type AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    data: XOR<AgencySidebarOptionUpdateWithoutAgencyInput, AgencySidebarOptionUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencySidebarOptionScalarWhereInput
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencySidebarOptionScalarWhereInput = {
    AND?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
    OR?: AgencySidebarOptionScalarWhereInput[]
    NOT?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
    id?: StringFilter<"AgencySidebarOption"> | string
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    agencyId?: StringFilter<"AgencySidebarOption"> | string
  }

  export type InvitationUpsertWithWhereUniqueWithoutAgencyInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutAgencyInput, InvitationUncheckedUpdateWithoutAgencyInput>
    create: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutAgencyInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutAgencyInput, InvitationUncheckedUpdateWithoutAgencyInput>
  }

  export type InvitationUpdateManyWithWhereWithoutAgencyInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutAgencyInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    agencyId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitation"> | $Enums.Role
  }

  export type NotificationUpsertWithWhereUniqueWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAgencyInput, NotificationUncheckedUpdateWithoutAgencyInput>
    create: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAgencyInput, NotificationUncheckedUpdateWithoutAgencyInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAgencyInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAgencyInput>
  }

  export type SubscriptionUpsertWithoutAgencyInput = {
    update: XOR<SubscriptionUpdateWithoutAgencyInput, SubscriptionUncheckedUpdateWithoutAgencyInput>
    create: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutAgencyInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutAgencyInput, SubscriptionUncheckedUpdateWithoutAgencyInput>
  }

  export type SubscriptionUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscritiptionId?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscritiptionId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    update: XOR<AddOnsUpdateWithoutAgencyInput, AddOnsUncheckedUpdateWithoutAgencyInput>
    create: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    data: XOR<AddOnsUpdateWithoutAgencyInput, AddOnsUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUpdateManyWithWhereWithoutAgencyInput = {
    where: AddOnsScalarWhereInput
    data: XOR<AddOnsUpdateManyMutationInput, AddOnsUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AddOnsScalarWhereInput = {
    AND?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
    OR?: AddOnsScalarWhereInput[]
    NOT?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
    id?: StringFilter<"AddOns"> | string
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    priceId?: StringFilter<"AddOns"> | string
    agencyId?: StringNullableFilter<"AddOns"> | string | null
  }

  export type AgencyCreateWithoutSubAccountsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    invitations?: InvitationCreateNestedManyWithoutAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSubAccountsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSubAccountsInput, AgencyUncheckedCreateWithoutSubAccountsInput>
  }

  export type SubAccountSidebarOptionCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
  }

  export type SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
  }

  export type SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    create: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionCreateManySubAccountInputEnvelope = {
    data: SubAccountSidebarOptionCreateManySubAccountInput | SubAccountSidebarOptionCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type PermissionsCreateWithoutSubAccountInput = {
    id?: string
    access: boolean
    user: UserCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateWithoutSubAccountInput = {
    id?: string
    email: string
    access: boolean
  }

  export type PermissionsCreateOrConnectWithoutSubAccountInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput>
  }

  export type PermissionsCreateManySubAccountInputEnvelope = {
    data: PermissionsCreateManySubAccountInput | PermissionsCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type FunnelCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    funnelPages?: FunnelPageCreateNestedManyWithoutFunnelInput
    className?: ClassNameCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUncheckedCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    funnelPages?: FunnelPageUncheckedCreateNestedManyWithoutFunnelInput
    className?: ClassNameUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelCreateOrConnectWithoutSubAccountInput = {
    where: FunnelWhereUniqueInput
    create: XOR<FunnelCreateWithoutSubAccountInput, FunnelUncheckedCreateWithoutSubAccountInput>
  }

  export type FunnelCreateManySubAccountInputEnvelope = {
    data: FunnelCreateManySubAccountInput | FunnelCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    name: string
    link: string
  }

  export type MediaUncheckedCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    name: string
    link: string
  }

  export type MediaCreateOrConnectWithoutSubAccountInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput>
  }

  export type MediaCreateManySubAccountInputEnvelope = {
    data: MediaCreateManySubAccountInput | MediaCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutSubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    tickets?: TicketCreateNestedManyWithoutCustomerInput
  }

  export type ContactUncheckedCreateWithoutSubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type ContactCreateOrConnectWithoutSubaccountInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutSubaccountInput, ContactUncheckedCreateWithoutSubaccountInput>
  }

  export type ContactCreateManySubaccountInputEnvelope = {
    data: ContactCreateManySubaccountInput | ContactCreateManySubaccountInput[]
    skipDuplicates?: boolean
  }

  export type TriggerCreateWithoutSubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: $Enums.TriggerTypes
    automations?: AutomationCreateNestedManyWithoutTriggerInput
  }

  export type TriggerUncheckedCreateWithoutSubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: $Enums.TriggerTypes
    automations?: AutomationUncheckedCreateNestedManyWithoutTriggerInput
  }

  export type TriggerCreateOrConnectWithoutSubaccountInput = {
    where: TriggerWhereUniqueInput
    create: XOR<TriggerCreateWithoutSubaccountInput, TriggerUncheckedCreateWithoutSubaccountInput>
  }

  export type TriggerCreateManySubaccountInputEnvelope = {
    data: TriggerCreateManySubaccountInput | TriggerCreateManySubaccountInput[]
    skipDuplicates?: boolean
  }

  export type AutomationCreateWithoutSubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    published?: boolean
    trigger?: TriggerCreateNestedOneWithoutAutomationsInput
    actions?: ActionCreateNestedManyWithoutAutomationInput
    automationInstances?: AutomationInstanceCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutSubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    triggerId?: string | null
    published?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutAutomationInput
    automationInstances?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutSubaccountInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutSubaccountInput, AutomationUncheckedCreateWithoutSubaccountInput>
  }

  export type AutomationCreateManySubaccountInputEnvelope = {
    data: AutomationCreateManySubaccountInput | AutomationCreateManySubaccountInput[]
    skipDuplicates?: boolean
  }

  export type PipelineCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    lanes?: LaneCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUncheckedCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    lanes?: LaneUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelineCreateOrConnectWithoutSubAccountInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput>
  }

  export type PipelineCreateManySubAccountInputEnvelope = {
    data: PipelineCreateManySubAccountInput | PipelineCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    tickets?: TicketCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    tickets?: TicketUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutSubAccountInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutSubAccountInput, TagUncheckedCreateWithoutSubAccountInput>
  }

  export type TagCreateManySubAccountInputEnvelope = {
    data: TagCreateManySubAccountInput | TagCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    user: UserCreateNestedOneWithoutNotificationInput
    agency: AgencyCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    agencyId: string
    userId: string
  }

  export type NotificationCreateOrConnectWithoutSubAccountInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput>
  }

  export type NotificationCreateManySubAccountInputEnvelope = {
    data: NotificationCreateManySubAccountInput | NotificationCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutSubAccountsInput = {
    update: XOR<AgencyUpdateWithoutSubAccountsInput, AgencyUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<AgencyCreateWithoutSubAccountsInput, AgencyUncheckedCreateWithoutSubAccountsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSubAccountsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSubAccountsInput, AgencyUncheckedUpdateWithoutSubAccountsInput>
  }

  export type AgencyUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    update: XOR<SubAccountSidebarOptionUpdateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput>
    create: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    data: XOR<SubAccountSidebarOptionUpdateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput = {
    where: SubAccountSidebarOptionScalarWhereInput
    data: XOR<SubAccountSidebarOptionUpdateManyMutationInput, SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionScalarWhereInput = {
    AND?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
    OR?: SubAccountSidebarOptionScalarWhereInput[]
    NOT?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
    id?: StringFilter<"SubAccountSidebarOption"> | string
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    subAccountId?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
  }

  export type PermissionsUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: PermissionsWhereUniqueInput
    update: XOR<PermissionsUpdateWithoutSubAccountInput, PermissionsUncheckedUpdateWithoutSubAccountInput>
    create: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput>
  }

  export type PermissionsUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: PermissionsWhereUniqueInput
    data: XOR<PermissionsUpdateWithoutSubAccountInput, PermissionsUncheckedUpdateWithoutSubAccountInput>
  }

  export type PermissionsUpdateManyWithWhereWithoutSubAccountInput = {
    where: PermissionsScalarWhereInput
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type FunnelUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: FunnelWhereUniqueInput
    update: XOR<FunnelUpdateWithoutSubAccountInput, FunnelUncheckedUpdateWithoutSubAccountInput>
    create: XOR<FunnelCreateWithoutSubAccountInput, FunnelUncheckedCreateWithoutSubAccountInput>
  }

  export type FunnelUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: FunnelWhereUniqueInput
    data: XOR<FunnelUpdateWithoutSubAccountInput, FunnelUncheckedUpdateWithoutSubAccountInput>
  }

  export type FunnelUpdateManyWithWhereWithoutSubAccountInput = {
    where: FunnelScalarWhereInput
    data: XOR<FunnelUpdateManyMutationInput, FunnelUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type FunnelScalarWhereInput = {
    AND?: FunnelScalarWhereInput | FunnelScalarWhereInput[]
    OR?: FunnelScalarWhereInput[]
    NOT?: FunnelScalarWhereInput | FunnelScalarWhereInput[]
    id?: StringFilter<"Funnel"> | string
    createdAt?: DateTimeFilter<"Funnel"> | Date | string
    updatedAt?: DateTimeFilter<"Funnel"> | Date | string
    name?: StringFilter<"Funnel"> | string
    description?: StringNullableFilter<"Funnel"> | string | null
    published?: BoolFilter<"Funnel"> | boolean
    subDomainName?: StringNullableFilter<"Funnel"> | string | null
    favicon?: StringNullableFilter<"Funnel"> | string | null
    subAccountId?: StringFilter<"Funnel"> | string
    liveProducts?: StringNullableFilter<"Funnel"> | string | null
  }

  export type MediaUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutSubAccountInput, MediaUncheckedUpdateWithoutSubAccountInput>
    create: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutSubAccountInput, MediaUncheckedUpdateWithoutSubAccountInput>
  }

  export type MediaUpdateManyWithWhereWithoutSubAccountInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    link?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
  }

  export type ContactUpsertWithWhereUniqueWithoutSubaccountInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutSubaccountInput, ContactUncheckedUpdateWithoutSubaccountInput>
    create: XOR<ContactCreateWithoutSubaccountInput, ContactUncheckedCreateWithoutSubaccountInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutSubaccountInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutSubaccountInput, ContactUncheckedUpdateWithoutSubaccountInput>
  }

  export type ContactUpdateManyWithWhereWithoutSubaccountInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutSubaccountInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    subAccountId?: StringFilter<"Contact"> | string
  }

  export type TriggerUpsertWithWhereUniqueWithoutSubaccountInput = {
    where: TriggerWhereUniqueInput
    update: XOR<TriggerUpdateWithoutSubaccountInput, TriggerUncheckedUpdateWithoutSubaccountInput>
    create: XOR<TriggerCreateWithoutSubaccountInput, TriggerUncheckedCreateWithoutSubaccountInput>
  }

  export type TriggerUpdateWithWhereUniqueWithoutSubaccountInput = {
    where: TriggerWhereUniqueInput
    data: XOR<TriggerUpdateWithoutSubaccountInput, TriggerUncheckedUpdateWithoutSubaccountInput>
  }

  export type TriggerUpdateManyWithWhereWithoutSubaccountInput = {
    where: TriggerScalarWhereInput
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyWithoutSubaccountInput>
  }

  export type TriggerScalarWhereInput = {
    AND?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
    OR?: TriggerScalarWhereInput[]
    NOT?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
    id?: StringFilter<"Trigger"> | string
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    name?: StringFilter<"Trigger"> | string
    subAccountId?: StringFilter<"Trigger"> | string
    type?: EnumTriggerTypesFilter<"Trigger"> | $Enums.TriggerTypes
  }

  export type AutomationUpsertWithWhereUniqueWithoutSubaccountInput = {
    where: AutomationWhereUniqueInput
    update: XOR<AutomationUpdateWithoutSubaccountInput, AutomationUncheckedUpdateWithoutSubaccountInput>
    create: XOR<AutomationCreateWithoutSubaccountInput, AutomationUncheckedCreateWithoutSubaccountInput>
  }

  export type AutomationUpdateWithWhereUniqueWithoutSubaccountInput = {
    where: AutomationWhereUniqueInput
    data: XOR<AutomationUpdateWithoutSubaccountInput, AutomationUncheckedUpdateWithoutSubaccountInput>
  }

  export type AutomationUpdateManyWithWhereWithoutSubaccountInput = {
    where: AutomationScalarWhereInput
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyWithoutSubaccountInput>
  }

  export type AutomationScalarWhereInput = {
    AND?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    OR?: AutomationScalarWhereInput[]
    NOT?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    id?: StringFilter<"Automation"> | string
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    name?: StringFilter<"Automation"> | string
    triggerId?: StringNullableFilter<"Automation"> | string | null
    published?: BoolFilter<"Automation"> | boolean
    subAccountId?: StringFilter<"Automation"> | string
  }

  export type PipelineUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: PipelineWhereUniqueInput
    update: XOR<PipelineUpdateWithoutSubAccountInput, PipelineUncheckedUpdateWithoutSubAccountInput>
    create: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput>
  }

  export type PipelineUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: PipelineWhereUniqueInput
    data: XOR<PipelineUpdateWithoutSubAccountInput, PipelineUncheckedUpdateWithoutSubAccountInput>
  }

  export type PipelineUpdateManyWithWhereWithoutSubAccountInput = {
    where: PipelineScalarWhereInput
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type PipelineScalarWhereInput = {
    AND?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
    OR?: PipelineScalarWhereInput[]
    NOT?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    name?: StringFilter<"Pipeline"> | string
    subAccountId?: StringFilter<"Pipeline"> | string
  }

  export type TagUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutSubAccountInput, TagUncheckedUpdateWithoutSubAccountInput>
    create: XOR<TagCreateWithoutSubAccountInput, TagUncheckedCreateWithoutSubAccountInput>
  }

  export type TagUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutSubAccountInput, TagUncheckedUpdateWithoutSubAccountInput>
  }

  export type TagUpdateManyWithWhereWithoutSubAccountInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    subAccountId?: StringFilter<"Tag"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSubAccountInput, NotificationUncheckedUpdateWithoutSubAccountInput>
    create: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSubAccountInput, NotificationUncheckedUpdateWithoutSubAccountInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSubAccountInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type UserCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agency?: AgencyCreateNestedOneWithoutUsersInput
    tickets?: TicketCreateNestedManyWithoutAssignedInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agencyId?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutAssignedInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type SubAccountCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutPermissionsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutPermissionsInput, SubAccountUncheckedCreateWithoutPermissionsInput>
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    tickets?: TicketUpdateManyWithoutAssignedNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutAssignedNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubAccountUpsertWithoutPermissionsInput = {
    update: XOR<SubAccountUpdateWithoutPermissionsInput, SubAccountUncheckedUpdateWithoutPermissionsInput>
    create: XOR<SubAccountCreateWithoutPermissionsInput, SubAccountUncheckedCreateWithoutPermissionsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutPermissionsInput, SubAccountUncheckedUpdateWithoutPermissionsInput>
  }

  export type SubAccountUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutTagsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutTagsInput, SubAccountUncheckedCreateWithoutTagsInput>
  }

  export type TicketCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    lane: LaneCreateNestedOneWithoutTicketsInput
    customer?: ContactCreateNestedOneWithoutTicketsInput
    assigned?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
  }

  export type TicketCreateOrConnectWithoutTagsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput>
  }

  export type SubAccountUpsertWithoutTagsInput = {
    update: XOR<SubAccountUpdateWithoutTagsInput, SubAccountUncheckedUpdateWithoutTagsInput>
    create: XOR<SubAccountCreateWithoutTagsInput, SubAccountUncheckedCreateWithoutTagsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutTagsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutTagsInput, SubAccountUncheckedUpdateWithoutTagsInput>
  }

  export type SubAccountUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutTagsInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutTagsInput, TicketUncheckedUpdateWithoutTagsInput>
    create: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutTagsInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutTagsInput, TicketUncheckedUpdateWithoutTagsInput>
  }

  export type TicketUpdateManyWithWhereWithoutTagsInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutTagsInput>
  }

  export type LaneCreateWithoutPipelineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    color: string
    tickets?: TicketCreateNestedManyWithoutLaneInput
  }

  export type LaneUncheckedCreateWithoutPipelineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    color: string
    tickets?: TicketUncheckedCreateNestedManyWithoutLaneInput
  }

  export type LaneCreateOrConnectWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    create: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput>
  }

  export type LaneCreateManyPipelineInputEnvelope = {
    data: LaneCreateManyPipelineInput | LaneCreateManyPipelineInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountCreateWithoutPipelinesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutPipelinesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutPipelinesInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutPipelinesInput, SubAccountUncheckedCreateWithoutPipelinesInput>
  }

  export type LaneUpsertWithWhereUniqueWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    update: XOR<LaneUpdateWithoutPipelineInput, LaneUncheckedUpdateWithoutPipelineInput>
    create: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput>
  }

  export type LaneUpdateWithWhereUniqueWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    data: XOR<LaneUpdateWithoutPipelineInput, LaneUncheckedUpdateWithoutPipelineInput>
  }

  export type LaneUpdateManyWithWhereWithoutPipelineInput = {
    where: LaneScalarWhereInput
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyWithoutPipelineInput>
  }

  export type LaneScalarWhereInput = {
    AND?: LaneScalarWhereInput | LaneScalarWhereInput[]
    OR?: LaneScalarWhereInput[]
    NOT?: LaneScalarWhereInput | LaneScalarWhereInput[]
    id?: StringFilter<"Lane"> | string
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    name?: StringFilter<"Lane"> | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
    color?: StringFilter<"Lane"> | string
  }

  export type SubAccountUpsertWithoutPipelinesInput = {
    update: XOR<SubAccountUpdateWithoutPipelinesInput, SubAccountUncheckedUpdateWithoutPipelinesInput>
    create: XOR<SubAccountCreateWithoutPipelinesInput, SubAccountUncheckedCreateWithoutPipelinesInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutPipelinesInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutPipelinesInput, SubAccountUncheckedUpdateWithoutPipelinesInput>
  }

  export type SubAccountUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agency?: AgencyCreateNestedOneWithoutUsersInput
    permissions?: PermissionsCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutAssignedInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agencyId?: string | null
    permissions?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAssignedInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type AgencyCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    invitations?: InvitationCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutNotificationsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutNotificationsInput, AgencyUncheckedCreateWithoutNotificationsInput>
  }

  export type SubAccountCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutNotificationsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutNotificationsInput, SubAccountUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    permissions?: PermissionsUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutAssignedNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionsUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssignedNestedInput
  }

  export type AgencyUpsertWithoutNotificationsInput = {
    update: XOR<AgencyUpdateWithoutNotificationsInput, AgencyUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AgencyCreateWithoutNotificationsInput, AgencyUncheckedCreateWithoutNotificationsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutNotificationsInput, AgencyUncheckedUpdateWithoutNotificationsInput>
  }

  export type AgencyUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountUpsertWithoutNotificationsInput = {
    update: XOR<SubAccountUpdateWithoutNotificationsInput, SubAccountUncheckedUpdateWithoutNotificationsInput>
    create: XOR<SubAccountCreateWithoutNotificationsInput, SubAccountUncheckedCreateWithoutNotificationsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutNotificationsInput, SubAccountUncheckedUpdateWithoutNotificationsInput>
  }

  export type SubAccountUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type PipelineCreateWithoutLanesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    subAccount: SubAccountCreateNestedOneWithoutPipelinesInput
  }

  export type PipelineUncheckedCreateWithoutLanesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    subAccountId: string
  }

  export type PipelineCreateOrConnectWithoutLanesInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutLanesInput, PipelineUncheckedCreateWithoutLanesInput>
  }

  export type TicketCreateWithoutLaneInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customer?: ContactCreateNestedOneWithoutTicketsInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    assigned?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutLaneInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutLaneInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutLaneInput, TicketUncheckedCreateWithoutLaneInput>
  }

  export type TicketCreateManyLaneInputEnvelope = {
    data: TicketCreateManyLaneInput | TicketCreateManyLaneInput[]
    skipDuplicates?: boolean
  }

  export type PipelineUpsertWithoutLanesInput = {
    update: XOR<PipelineUpdateWithoutLanesInput, PipelineUncheckedUpdateWithoutLanesInput>
    create: XOR<PipelineCreateWithoutLanesInput, PipelineUncheckedCreateWithoutLanesInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutLanesInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutLanesInput, PipelineUncheckedUpdateWithoutLanesInput>
  }

  export type PipelineUpdateWithoutLanesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    subAccount?: SubAccountUpdateOneRequiredWithoutPipelinesNestedInput
  }

  export type PipelineUncheckedUpdateWithoutLanesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketUpsertWithWhereUniqueWithoutLaneInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutLaneInput, TicketUncheckedUpdateWithoutLaneInput>
    create: XOR<TicketCreateWithoutLaneInput, TicketUncheckedCreateWithoutLaneInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutLaneInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutLaneInput, TicketUncheckedUpdateWithoutLaneInput>
  }

  export type TicketUpdateManyWithWhereWithoutLaneInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutLaneInput>
  }

  export type LaneCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    color: string
    pipeline: PipelineCreateNestedOneWithoutLanesInput
  }

  export type LaneUncheckedCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pipelineId: string
    order?: number
    color: string
  }

  export type LaneCreateOrConnectWithoutTicketsInput = {
    where: LaneWhereUniqueInput
    create: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
  }

  export type ContactCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    subaccount: SubAccountCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    subAccountId: string
  }

  export type ContactCreateOrConnectWithoutTicketsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
  }

  export type TagCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    subAccount: SubAccountCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    subAccountId: string
  }

  export type TagCreateOrConnectWithoutTicketsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agency?: AgencyCreateNestedOneWithoutUsersInput
    permissions?: PermissionsCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
    agencyId?: string | null
    permissions?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type LaneUpsertWithoutTicketsInput = {
    update: XOR<LaneUpdateWithoutTicketsInput, LaneUncheckedUpdateWithoutTicketsInput>
    create: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    where?: LaneWhereInput
  }

  export type LaneUpdateToOneWithWhereWithoutTicketsInput = {
    where?: LaneWhereInput
    data: XOR<LaneUpdateWithoutTicketsInput, LaneUncheckedUpdateWithoutTicketsInput>
  }

  export type LaneUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    pipeline?: PipelineUpdateOneRequiredWithoutLanesNestedInput
  }

  export type LaneUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUpsertWithoutTicketsInput = {
    update: XOR<ContactUpdateWithoutTicketsInput, ContactUncheckedUpdateWithoutTicketsInput>
    create: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTicketsInput, ContactUncheckedUpdateWithoutTicketsInput>
  }

  export type ContactUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subaccount?: SubAccountUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TagUpsertWithWhereUniqueWithoutTicketsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutTicketsInput, TagUncheckedUpdateWithoutTicketsInput>
    create: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutTicketsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutTicketsInput, TagUncheckedUpdateWithoutTicketsInput>
  }

  export type TagUpdateManyWithWhereWithoutTicketsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTicketsInput>
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agency?: AgencyUpdateOneWithoutUsersNestedInput
    permissions?: PermissionsUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionsUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubAccountCreateWithoutTriggersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutTriggersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutTriggersInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutTriggersInput, SubAccountUncheckedCreateWithoutTriggersInput>
  }

  export type AutomationCreateWithoutTriggerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    published?: boolean
    subaccount: SubAccountCreateNestedOneWithoutAutomationsInput
    actions?: ActionCreateNestedManyWithoutAutomationInput
    automationInstances?: AutomationInstanceCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutTriggerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    published?: boolean
    subAccountId: string
    actions?: ActionUncheckedCreateNestedManyWithoutAutomationInput
    automationInstances?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutTriggerInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput>
  }

  export type AutomationCreateManyTriggerInputEnvelope = {
    data: AutomationCreateManyTriggerInput | AutomationCreateManyTriggerInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountUpsertWithoutTriggersInput = {
    update: XOR<SubAccountUpdateWithoutTriggersInput, SubAccountUncheckedUpdateWithoutTriggersInput>
    create: XOR<SubAccountCreateWithoutTriggersInput, SubAccountUncheckedCreateWithoutTriggersInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutTriggersInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutTriggersInput, SubAccountUncheckedUpdateWithoutTriggersInput>
  }

  export type SubAccountUpdateWithoutTriggersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutTriggersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AutomationUpsertWithWhereUniqueWithoutTriggerInput = {
    where: AutomationWhereUniqueInput
    update: XOR<AutomationUpdateWithoutTriggerInput, AutomationUncheckedUpdateWithoutTriggerInput>
    create: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput>
  }

  export type AutomationUpdateWithWhereUniqueWithoutTriggerInput = {
    where: AutomationWhereUniqueInput
    data: XOR<AutomationUpdateWithoutTriggerInput, AutomationUncheckedUpdateWithoutTriggerInput>
  }

  export type AutomationUpdateManyWithWhereWithoutTriggerInput = {
    where: AutomationScalarWhereInput
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyWithoutTriggerInput>
  }

  export type TriggerCreateWithoutAutomationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: $Enums.TriggerTypes
    subaccount: SubAccountCreateNestedOneWithoutTriggersInput
  }

  export type TriggerUncheckedCreateWithoutAutomationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    subAccountId: string
    type: $Enums.TriggerTypes
  }

  export type TriggerCreateOrConnectWithoutAutomationsInput = {
    where: TriggerWhereUniqueInput
    create: XOR<TriggerCreateWithoutAutomationsInput, TriggerUncheckedCreateWithoutAutomationsInput>
  }

  export type SubAccountCreateWithoutAutomationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutAutomationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutAutomationsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutAutomationsInput, SubAccountUncheckedCreateWithoutAutomationsInput>
  }

  export type ActionCreateWithoutAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order: number
    laneId?: string
    type: $Enums.ActionType
  }

  export type ActionUncheckedCreateWithoutAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order: number
    laneId?: string
    type: $Enums.ActionType
  }

  export type ActionCreateOrConnectWithoutAutomationInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput>
  }

  export type ActionCreateManyAutomationInputEnvelope = {
    data: ActionCreateManyAutomationInput | ActionCreateManyAutomationInput[]
    skipDuplicates?: boolean
  }

  export type AutomationInstanceCreateWithoutAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type AutomationInstanceUncheckedCreateWithoutAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type AutomationInstanceCreateOrConnectWithoutAutomationInput = {
    where: AutomationInstanceWhereUniqueInput
    create: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput>
  }

  export type AutomationInstanceCreateManyAutomationInputEnvelope = {
    data: AutomationInstanceCreateManyAutomationInput | AutomationInstanceCreateManyAutomationInput[]
    skipDuplicates?: boolean
  }

  export type TriggerUpsertWithoutAutomationsInput = {
    update: XOR<TriggerUpdateWithoutAutomationsInput, TriggerUncheckedUpdateWithoutAutomationsInput>
    create: XOR<TriggerCreateWithoutAutomationsInput, TriggerUncheckedCreateWithoutAutomationsInput>
    where?: TriggerWhereInput
  }

  export type TriggerUpdateToOneWithWhereWithoutAutomationsInput = {
    where?: TriggerWhereInput
    data: XOR<TriggerUpdateWithoutAutomationsInput, TriggerUncheckedUpdateWithoutAutomationsInput>
  }

  export type TriggerUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    subaccount?: SubAccountUpdateOneRequiredWithoutTriggersNestedInput
  }

  export type TriggerUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
  }

  export type SubAccountUpsertWithoutAutomationsInput = {
    update: XOR<SubAccountUpdateWithoutAutomationsInput, SubAccountUncheckedUpdateWithoutAutomationsInput>
    create: XOR<SubAccountCreateWithoutAutomationsInput, SubAccountUncheckedCreateWithoutAutomationsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutAutomationsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutAutomationsInput, SubAccountUncheckedUpdateWithoutAutomationsInput>
  }

  export type SubAccountUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type ActionUpsertWithWhereUniqueWithoutAutomationInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUpdateWithoutAutomationInput, ActionUncheckedUpdateWithoutAutomationInput>
    create: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutAutomationInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUpdateWithoutAutomationInput, ActionUncheckedUpdateWithoutAutomationInput>
  }

  export type ActionUpdateManyWithWhereWithoutAutomationInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyWithoutAutomationInput>
  }

  export type ActionScalarWhereInput = {
    AND?: ActionScalarWhereInput | ActionScalarWhereInput[]
    OR?: ActionScalarWhereInput[]
    NOT?: ActionScalarWhereInput | ActionScalarWhereInput[]
    id?: StringFilter<"Action"> | string
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    name?: StringFilter<"Action"> | string
    order?: IntFilter<"Action"> | number
    automationId?: StringFilter<"Action"> | string
    laneId?: StringFilter<"Action"> | string
    type?: EnumActionTypeFilter<"Action"> | $Enums.ActionType
  }

  export type AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput = {
    where: AutomationInstanceWhereUniqueInput
    update: XOR<AutomationInstanceUpdateWithoutAutomationInput, AutomationInstanceUncheckedUpdateWithoutAutomationInput>
    create: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput>
  }

  export type AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput = {
    where: AutomationInstanceWhereUniqueInput
    data: XOR<AutomationInstanceUpdateWithoutAutomationInput, AutomationInstanceUncheckedUpdateWithoutAutomationInput>
  }

  export type AutomationInstanceUpdateManyWithWhereWithoutAutomationInput = {
    where: AutomationInstanceScalarWhereInput
    data: XOR<AutomationInstanceUpdateManyMutationInput, AutomationInstanceUncheckedUpdateManyWithoutAutomationInput>
  }

  export type AutomationInstanceScalarWhereInput = {
    AND?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
    OR?: AutomationInstanceScalarWhereInput[]
    NOT?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
    id?: StringFilter<"AutomationInstance"> | string
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
  }

  export type AutomationCreateWithoutAutomationInstancesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    published?: boolean
    trigger?: TriggerCreateNestedOneWithoutAutomationsInput
    subaccount: SubAccountCreateNestedOneWithoutAutomationsInput
    actions?: ActionCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutAutomationInstancesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    actions?: ActionUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutAutomationInstancesInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutAutomationInstancesInput, AutomationUncheckedCreateWithoutAutomationInstancesInput>
  }

  export type AutomationUpsertWithoutAutomationInstancesInput = {
    update: XOR<AutomationUpdateWithoutAutomationInstancesInput, AutomationUncheckedUpdateWithoutAutomationInstancesInput>
    create: XOR<AutomationCreateWithoutAutomationInstancesInput, AutomationUncheckedCreateWithoutAutomationInstancesInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutAutomationInstancesInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutAutomationInstancesInput, AutomationUncheckedUpdateWithoutAutomationInstancesInput>
  }

  export type AutomationUpdateWithoutAutomationInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    trigger?: TriggerUpdateOneWithoutAutomationsNestedInput
    subaccount?: SubAccountUpdateOneRequiredWithoutAutomationsNestedInput
    actions?: ActionUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutAutomationInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    actions?: ActionUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationCreateWithoutActionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    published?: boolean
    trigger?: TriggerCreateNestedOneWithoutAutomationsInput
    subaccount: SubAccountCreateNestedOneWithoutAutomationsInput
    automationInstances?: AutomationInstanceCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutActionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    automationInstances?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutActionsInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutActionsInput, AutomationUncheckedCreateWithoutActionsInput>
  }

  export type AutomationUpsertWithoutActionsInput = {
    update: XOR<AutomationUpdateWithoutActionsInput, AutomationUncheckedUpdateWithoutActionsInput>
    create: XOR<AutomationCreateWithoutActionsInput, AutomationUncheckedCreateWithoutActionsInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutActionsInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutActionsInput, AutomationUncheckedUpdateWithoutActionsInput>
  }

  export type AutomationUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    trigger?: TriggerUpdateOneWithoutAutomationsNestedInput
    subaccount?: SubAccountUpdateOneRequiredWithoutAutomationsNestedInput
    automationInstances?: AutomationInstanceUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    automationInstances?: AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type SubAccountCreateWithoutContactsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutContactsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutContactsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutContactsInput, SubAccountUncheckedCreateWithoutContactsInput>
  }

  export type TicketCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    lane: LaneCreateNestedOneWithoutTicketsInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    assigned?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    assignedUserId?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutCustomerInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput>
  }

  export type TicketCreateManyCustomerInputEnvelope = {
    data: TicketCreateManyCustomerInput | TicketCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountUpsertWithoutContactsInput = {
    update: XOR<SubAccountUpdateWithoutContactsInput, SubAccountUncheckedUpdateWithoutContactsInput>
    create: XOR<SubAccountCreateWithoutContactsInput, SubAccountUncheckedCreateWithoutContactsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutContactsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutContactsInput, SubAccountUncheckedUpdateWithoutContactsInput>
  }

  export type SubAccountUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutCustomerInput, TicketUncheckedUpdateWithoutCustomerInput>
    create: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutCustomerInput, TicketUncheckedUpdateWithoutCustomerInput>
  }

  export type TicketUpdateManyWithWhereWithoutCustomerInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubAccountCreateWithoutMediaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutMediaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutMediaInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutMediaInput, SubAccountUncheckedCreateWithoutMediaInput>
  }

  export type SubAccountUpsertWithoutMediaInput = {
    update: XOR<SubAccountUpdateWithoutMediaInput, SubAccountUncheckedUpdateWithoutMediaInput>
    create: XOR<SubAccountCreateWithoutMediaInput, SubAccountUncheckedCreateWithoutMediaInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutMediaInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutMediaInput, SubAccountUncheckedUpdateWithoutMediaInput>
  }

  export type SubAccountUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountCreateWithoutFunnelsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    sidebarOptions?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutFunnelsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    sidebarOptions?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutFunnelsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutFunnelsInput, SubAccountUncheckedCreateWithoutFunnelsInput>
  }

  export type FunnelPageCreateWithoutFunnelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pathName?: string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
  }

  export type FunnelPageUncheckedCreateWithoutFunnelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pathName?: string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
  }

  export type FunnelPageCreateOrConnectWithoutFunnelInput = {
    where: FunnelPageWhereUniqueInput
    create: XOR<FunnelPageCreateWithoutFunnelInput, FunnelPageUncheckedCreateWithoutFunnelInput>
  }

  export type FunnelPageCreateManyFunnelInputEnvelope = {
    data: FunnelPageCreateManyFunnelInput | FunnelPageCreateManyFunnelInput[]
    skipDuplicates?: boolean
  }

  export type ClassNameCreateWithoutFunnelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    customData?: string | null
  }

  export type ClassNameUncheckedCreateWithoutFunnelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    customData?: string | null
  }

  export type ClassNameCreateOrConnectWithoutFunnelInput = {
    where: ClassNameWhereUniqueInput
    create: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput>
  }

  export type ClassNameCreateManyFunnelInputEnvelope = {
    data: ClassNameCreateManyFunnelInput | ClassNameCreateManyFunnelInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountUpsertWithoutFunnelsInput = {
    update: XOR<SubAccountUpdateWithoutFunnelsInput, SubAccountUncheckedUpdateWithoutFunnelsInput>
    create: XOR<SubAccountCreateWithoutFunnelsInput, SubAccountUncheckedCreateWithoutFunnelsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutFunnelsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutFunnelsInput, SubAccountUncheckedUpdateWithoutFunnelsInput>
  }

  export type SubAccountUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type FunnelPageUpsertWithWhereUniqueWithoutFunnelInput = {
    where: FunnelPageWhereUniqueInput
    update: XOR<FunnelPageUpdateWithoutFunnelInput, FunnelPageUncheckedUpdateWithoutFunnelInput>
    create: XOR<FunnelPageCreateWithoutFunnelInput, FunnelPageUncheckedCreateWithoutFunnelInput>
  }

  export type FunnelPageUpdateWithWhereUniqueWithoutFunnelInput = {
    where: FunnelPageWhereUniqueInput
    data: XOR<FunnelPageUpdateWithoutFunnelInput, FunnelPageUncheckedUpdateWithoutFunnelInput>
  }

  export type FunnelPageUpdateManyWithWhereWithoutFunnelInput = {
    where: FunnelPageScalarWhereInput
    data: XOR<FunnelPageUpdateManyMutationInput, FunnelPageUncheckedUpdateManyWithoutFunnelInput>
  }

  export type FunnelPageScalarWhereInput = {
    AND?: FunnelPageScalarWhereInput | FunnelPageScalarWhereInput[]
    OR?: FunnelPageScalarWhereInput[]
    NOT?: FunnelPageScalarWhereInput | FunnelPageScalarWhereInput[]
    id?: StringFilter<"FunnelPage"> | string
    createdAt?: DateTimeFilter<"FunnelPage"> | Date | string
    updatedAt?: DateTimeFilter<"FunnelPage"> | Date | string
    name?: StringFilter<"FunnelPage"> | string
    pathName?: StringFilter<"FunnelPage"> | string
    visits?: IntFilter<"FunnelPage"> | number
    content?: StringNullableFilter<"FunnelPage"> | string | null
    order?: IntFilter<"FunnelPage"> | number
    previewImage?: StringNullableFilter<"FunnelPage"> | string | null
    funnelId?: StringFilter<"FunnelPage"> | string
  }

  export type ClassNameUpsertWithWhereUniqueWithoutFunnelInput = {
    where: ClassNameWhereUniqueInput
    update: XOR<ClassNameUpdateWithoutFunnelInput, ClassNameUncheckedUpdateWithoutFunnelInput>
    create: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput>
  }

  export type ClassNameUpdateWithWhereUniqueWithoutFunnelInput = {
    where: ClassNameWhereUniqueInput
    data: XOR<ClassNameUpdateWithoutFunnelInput, ClassNameUncheckedUpdateWithoutFunnelInput>
  }

  export type ClassNameUpdateManyWithWhereWithoutFunnelInput = {
    where: ClassNameScalarWhereInput
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyWithoutFunnelInput>
  }

  export type ClassNameScalarWhereInput = {
    AND?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
    OR?: ClassNameScalarWhereInput[]
    NOT?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
    id?: StringFilter<"ClassName"> | string
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    funnelId?: StringFilter<"ClassName"> | string
    customData?: StringNullableFilter<"ClassName"> | string | null
  }

  export type FunnelCreateWithoutClassNameInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    subAccount: SubAccountCreateNestedOneWithoutFunnelsInput
    funnelPages?: FunnelPageCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUncheckedCreateWithoutClassNameInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    funnelPages?: FunnelPageUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelCreateOrConnectWithoutClassNameInput = {
    where: FunnelWhereUniqueInput
    create: XOR<FunnelCreateWithoutClassNameInput, FunnelUncheckedCreateWithoutClassNameInput>
  }

  export type FunnelUpsertWithoutClassNameInput = {
    update: XOR<FunnelUpdateWithoutClassNameInput, FunnelUncheckedUpdateWithoutClassNameInput>
    create: XOR<FunnelCreateWithoutClassNameInput, FunnelUncheckedCreateWithoutClassNameInput>
    where?: FunnelWhereInput
  }

  export type FunnelUpdateToOneWithWhereWithoutClassNameInput = {
    where?: FunnelWhereInput
    data: XOR<FunnelUpdateWithoutClassNameInput, FunnelUncheckedUpdateWithoutClassNameInput>
  }

  export type FunnelUpdateWithoutClassNameInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    subAccount?: SubAccountUpdateOneRequiredWithoutFunnelsNestedInput
    funnelPages?: FunnelPageUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelUncheckedUpdateWithoutClassNameInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    funnelPages?: FunnelPageUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelCreateWithoutFunnelPagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    subAccount: SubAccountCreateNestedOneWithoutFunnelsInput
    className?: ClassNameCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUncheckedCreateWithoutFunnelPagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    className?: ClassNameUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelCreateOrConnectWithoutFunnelPagesInput = {
    where: FunnelWhereUniqueInput
    create: XOR<FunnelCreateWithoutFunnelPagesInput, FunnelUncheckedCreateWithoutFunnelPagesInput>
  }

  export type FunnelUpsertWithoutFunnelPagesInput = {
    update: XOR<FunnelUpdateWithoutFunnelPagesInput, FunnelUncheckedUpdateWithoutFunnelPagesInput>
    create: XOR<FunnelCreateWithoutFunnelPagesInput, FunnelUncheckedCreateWithoutFunnelPagesInput>
    where?: FunnelWhereInput
  }

  export type FunnelUpdateToOneWithWhereWithoutFunnelPagesInput = {
    where?: FunnelWhereInput
    data: XOR<FunnelUpdateWithoutFunnelPagesInput, FunnelUncheckedUpdateWithoutFunnelPagesInput>
  }

  export type FunnelUpdateWithoutFunnelPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    subAccount?: SubAccountUpdateOneRequiredWithoutFunnelsNestedInput
    className?: ClassNameUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelUncheckedUpdateWithoutFunnelPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    className?: ClassNameUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type AgencyCreateWithoutSidebarOptionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountCreateNestedManyWithoutAgencyInput
    invitations?: InvitationCreateNestedManyWithoutAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSidebarOptionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSidebarOptionsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSidebarOptionsInput, AgencyUncheckedCreateWithoutSidebarOptionsInput>
  }

  export type AgencyUpsertWithoutSidebarOptionsInput = {
    update: XOR<AgencyUpdateWithoutSidebarOptionsInput, AgencyUncheckedUpdateWithoutSidebarOptionsInput>
    create: XOR<AgencyCreateWithoutSidebarOptionsInput, AgencyUncheckedCreateWithoutSidebarOptionsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSidebarOptionsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSidebarOptionsInput, AgencyUncheckedUpdateWithoutSidebarOptionsInput>
  }

  export type AgencyUpdateWithoutSidebarOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSidebarOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountCreateWithoutSidebarOptionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agency: AgencyCreateNestedOneWithoutSubAccountsInput
    permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelCreateNestedManyWithoutSubAccountInput
    media?: MediaCreateNestedManyWithoutSubAccountInput
    contacts?: ContactCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerCreateNestedManyWithoutSubaccountInput
    automations?: AutomationCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineCreateNestedManyWithoutSubAccountInput
    tags?: TagCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutSidebarOptionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    funnels?: FunnelUncheckedCreateNestedManyWithoutSubAccountInput
    media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSubaccountInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutSubaccountInput
    automations?: AutomationUncheckedCreateNestedManyWithoutSubaccountInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    tags?: TagUncheckedCreateNestedManyWithoutSubAccountInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutSidebarOptionsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutSidebarOptionsInput, SubAccountUncheckedCreateWithoutSidebarOptionsInput>
  }

  export type SubAccountUpsertWithoutSidebarOptionsInput = {
    update: XOR<SubAccountUpdateWithoutSidebarOptionsInput, SubAccountUncheckedUpdateWithoutSidebarOptionsInput>
    create: XOR<SubAccountCreateWithoutSidebarOptionsInput, SubAccountUncheckedCreateWithoutSidebarOptionsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutSidebarOptionsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutSidebarOptionsInput, SubAccountUncheckedUpdateWithoutSidebarOptionsInput>
  }

  export type SubAccountUpdateWithoutSidebarOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutSubAccountsNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutSidebarOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AgencyCreateWithoutInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutInvitationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    addOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutInvitationsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutInvitationsInput, AgencyUncheckedCreateWithoutInvitationsInput>
  }

  export type AgencyUpsertWithoutInvitationsInput = {
    update: XOR<AgencyUpdateWithoutInvitationsInput, AgencyUncheckedUpdateWithoutInvitationsInput>
    create: XOR<AgencyCreateWithoutInvitationsInput, AgencyUncheckedCreateWithoutInvitationsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutInvitationsInput, AgencyUncheckedUpdateWithoutInvitationsInput>
  }

  export type AgencyUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    addOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateWithoutSubscriptionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    invitations?: InvitationCreateNestedManyWithoutAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    addOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    addOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSubscriptionsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSubscriptionsInput, AgencyUncheckedCreateWithoutSubscriptionsInput>
  }

  export type AgencyUpsertWithoutSubscriptionsInput = {
    update: XOR<AgencyUpdateWithoutSubscriptionsInput, AgencyUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<AgencyCreateWithoutSubscriptionsInput, AgencyUncheckedCreateWithoutSubscriptionsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSubscriptionsInput, AgencyUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type AgencyUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    addOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    addOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateWithoutAddOnsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    invitations?: InvitationCreateNestedManyWithoutAgencyInput
    notifications?: NotificationCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionCreateNestedOneWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAddOnsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    sidebarOptions?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    subscriptions?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAddOnsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
  }

  export type AgencyUpsertWithoutAddOnsInput = {
    update: XOR<AgencyUpdateWithoutAddOnsInput, AgencyUncheckedUpdateWithoutAddOnsInput>
    create: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAddOnsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAddOnsInput, AgencyUncheckedUpdateWithoutAddOnsInput>
  }

  export type AgencyUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUpdateOneWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    subAccounts?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    sidebarOptions?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
  }

  export type PermissionsCreateManyUserInput = {
    id?: string
    subAccountId: string
    access: boolean
  }

  export type TicketCreateManyAssignedInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    agencyId: string
    subAccountId?: string | null
  }

  export type PermissionsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    subAccount?: SubAccountUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketUpdateWithoutAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    customer?: ContactUpdateOneWithoutTicketsNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    agency?: AgencyUpdateOneRequiredWithoutNotificationsNestedInput
    subAccount?: SubAccountUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    avatarUrl: string
    email: string
    role?: $Enums.Role
  }

  export type SubAccountCreateManyAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
  }

  export type AgencySidebarOptionCreateManyAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
  }

  export type InvitationCreateManyAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type NotificationCreateManyAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    subAccountId?: string | null
    userId: string
  }

  export type AddOnsCreateManyAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type UserUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    permissions?: PermissionsUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutAssignedNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    permissions?: PermissionsUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAssignedNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type SubAccountUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUpdateManyWithoutSubAccountNestedInput
    media?: MediaUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUpdateManyWithoutSubAccountNestedInput
    tags?: TagUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    sidebarOptions?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    funnels?: FunnelUncheckedUpdateManyWithoutSubAccountNestedInput
    media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSubaccountNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutSubaccountNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutSubaccountNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    tags?: TagUncheckedUpdateManyWithoutSubAccountNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type AgencySidebarOptionUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type AgencySidebarOptionUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type AgencySidebarOptionUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type InvitationUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type NotificationUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
    subAccount?: SubAccountUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountSidebarOptionCreateManySubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    link?: string
    icon?: $Enums.Icon
  }

  export type PermissionsCreateManySubAccountInput = {
    id?: string
    email: string
    access: boolean
  }

  export type FunnelCreateManySubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
  }

  export type MediaCreateManySubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    name: string
    link: string
  }

  export type ContactCreateManySubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
  }

  export type TriggerCreateManySubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    type: $Enums.TriggerTypes
  }

  export type AutomationCreateManySubaccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    triggerId?: string | null
    published?: boolean
  }

  export type PipelineCreateManySubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
  }

  export type TagCreateManySubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
  }

  export type NotificationCreateManySubAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: string
    agencyId: string
    userId: string
  }

  export type SubAccountSidebarOptionUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
  }

  export type PermissionsUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FunnelUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    funnelPages?: FunnelPageUpdateManyWithoutFunnelNestedInput
    className?: ClassNameUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    funnelPages?: FunnelPageUncheckedUpdateManyWithoutFunnelNestedInput
    className?: ClassNameUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUpdateWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
  }

  export type ContactUncheckedUpdateWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type TriggerUpdateWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    automations?: AutomationUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerUncheckedUpdateWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    automations?: AutomationUncheckedUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerUncheckedUpdateManyWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
  }

  export type AutomationUpdateWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    trigger?: TriggerUpdateOneWithoutAutomationsNestedInput
    actions?: ActionUpdateManyWithoutAutomationNestedInput
    automationInstances?: AutomationInstanceUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutAutomationNestedInput
    automationInstances?: AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateManyWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PipelineUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lanes?: LaneUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lanes?: LaneUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
    agency?: AgencyUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    customer?: ContactUpdateOneWithoutTicketsNestedInput
    assigned?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaneCreateManyPipelineInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    color: string
  }

  export type LaneUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    tickets?: TicketUncheckedUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateManyWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCreateManyLaneInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
  }

  export type TicketUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: ContactUpdateOneWithoutTicketsNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    assigned?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    subAccount?: SubAccountUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationCreateManyTriggerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    published?: boolean
    subAccountId: string
  }

  export type AutomationUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subaccount?: SubAccountUpdateOneRequiredWithoutAutomationsNestedInput
    actions?: ActionUpdateManyWithoutAutomationNestedInput
    automationInstances?: AutomationInstanceUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    actions?: ActionUncheckedUpdateManyWithoutAutomationNestedInput
    automationInstances?: AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateManyWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionCreateManyAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    order: number
    laneId?: string
    type: $Enums.ActionType
  }

  export type AutomationInstanceCreateManyAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type ActionUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
  }

  export type ActionUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
  }

  export type ActionUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
  }

  export type AutomationInstanceUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketCreateManyCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    assignedUserId?: string | null
  }

  export type TicketUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    assigned?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPageCreateManyFunnelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    pathName?: string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
  }

  export type ClassNameCreateManyFunnelInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    color: string
    customData?: string | null
  }

  export type FunnelPageUpdateWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPageUncheckedUpdateWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPageUncheckedUpdateManyWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUpdateWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateManyWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}